ida_auto.auto_apply_tail():
	
	  auto_apply_tail(tail_ea, parent_ea)
	
	
	  Plan to apply the tail_ea chunk to the parent
	  
	  @param tail_ea: linear address of start of tail (C++: ea_t)
	  @param parent_ea: linear address within parent. If BADADDR,
	                    automatically try to find parent via xrefs. (C++:
	                    ea_t)
	  

ida_auto.auto_apply_type():
	
	  auto_apply_type(caller, callee)
	
	
	  Plan to apply the callee's type to the calling point.
	  
	  
	  @param caller (C++: ea_t)
	  @param callee (C++: ea_t)
	  

ida_auto.auto_cancel():
	
	  auto_cancel(ea1, ea2)
	
	
	  Remove an address range (ea1..ea2) from queues 'AU_CODE' , 'AU_PROC' ,
	  'AU_USED' . To remove an address range from other queues use
	  'auto_unmark()' function. 'ea1' may be higher than 'ea2', the kernel
	  will swap them in this case. 'ea2' doesn't belong to the range.
	  
	  @param ea1 (C++: ea_t)
	  @param ea2 (C++: ea_t)
	  

class ida_auto.auto_display_t():
	
	    Proxy of C++ auto_display_t class
	    

ida_auto.auto_display_t.ea:
	auto_display_t_ea_get(self) -> ea_t

ida_auto.auto_display_t.state:
	auto_display_t_state_get(self) -> idastate_t

ida_auto.auto_display_t.type:
	auto_display_t_type_get(self) -> atype_t

ida_auto.auto_get():
	
	  auto_get(type, lowEA, highEA) -> ea_t
	
	
	  Retrieve an address from queues regarding their priority. Returns
	  'BADADDR' if no addresses not lower than 'lowEA' and less than
	  'highEA' are found in the queues. Otherwise *type will have queue
	  type.
	  
	  @param type (C++: atype_t  *)
	  @param lowEA (C++: ea_t)
	  @param highEA (C++: ea_t)
	  

ida_auto.auto_is_ok():
	
	  auto_is_ok() -> bool
	
	
	  Are all queues empty? (i.e. has autoanalysis finished?).
	  

ida_auto.auto_make_code():
	
	  auto_make_code(ea)
	
	
	  Plan to make code.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_auto.auto_make_proc():
	
	  auto_make_proc(ea)
	
	
	  Plan to make code&function.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_auto.auto_mark():
	
	  auto_mark(ea, type)
	
	
	  Put single address into a queue. Queues keep addresses sorted.
	  
	  
	  @param ea (C++: ea_t)
	  @param type (C++: atype_t)
	  

ida_auto.auto_mark_range():
	
	  auto_mark_range(start, end, type)
	
	
	  Put range of addresses into a queue. 'start' may be higher than 'end',
	  the kernel will swap them in this case. 'end' doesn't belong to the
	  range.
	  
	  @param start (C++: ea_t)
	  @param end (C++: ea_t)
	  @param type (C++: atype_t)
	  

ida_auto.auto_recreate_insn():
	
	  auto_recreate_insn(ea) -> int
	
	
	  Try to create instruction
	  
	  @param ea: linear address of callee (C++: ea_t)
	  @return: the length of the instruction or 0
	  

ida_auto.auto_unmark():
	
	  auto_unmark(start, end, type)
	
	
	  Remove range of addresses from a queue. 'start' may be higher than
	  'end', the kernel will swap them in this case. 'end' doesn't belong to
	  the range.
	  
	  @param start (C++: ea_t)
	  @param end (C++: ea_t)
	  @param type (C++: atype_t)
	  

ida_auto.auto_wait():
	
	  auto_wait() -> bool
	
	
	  Process everything in the queues and return true. Return false if
	  Ctrl-Break was pressed.
	  

ida_auto.enable_auto():
	
	  enable_auto(enable) -> bool
	
	
	  Temporarily enable/disable autoanalyzer. Not user-facing, but rather
	  because IDA sometimes need to turn AA on/off regardless of
	  inf.s_genflags:INFFL_AUTO
	  
	  @param enable (C++: bool)
	  @return: old state
	  

ida_auto.get_auto_display():
	
	  get_auto_display(auto_display)
	
	
	  Get structure which holds the autoanalysis indicator contents.
	  
	  
	  @param auto_display (C++: auto_display_t  *)
	  

ida_auto.get_auto_state():
	
	  get_auto_state() -> atype_t
	
	
	  Get current state of autoanalyzer. If auto_state == 'AU_NONE' , IDA is
	  currently not running the analysis (it could be temporarily
	  interrupted to perform the user's requests, for example).
	  

ida_auto.is_auto_enabled():
	
	  is_auto_enabled() -> bool
	
	
	  Get autoanalyzer state.
	  

ida_auto.may_create_stkvars():
	
	  may_create_stkvars() -> bool
	
	
	  Is it allowed to create stack variables automatically?. This function
	  should be used by IDP modules before creating stack vars.
	  

ida_auto.may_trace_sp():
	
	  may_trace_sp() -> bool
	
	
	  Is it allowed to trace stack pointer automatically?. This function
	  should be used by IDP modules before tracing sp.
	  

ida_auto.peek_auto_queue():
	
	  peek_auto_queue(low_ea, type) -> ea_t
	
	
	  Peek into a queue 'type' for an address not lower than 'low_ea'. Do
	  not remove address from the queue.
	  
	  @param low_ea (C++: ea_t)
	  @param type (C++: atype_t)
	  @return: the address or  BADADDR
	  

ida_auto.plan_and_wait():
	
	  plan_and_wait(ea1, ea2, final_pass=True) -> int
	
	
	  Analyze the specified range. Try to create instructions where
	  possible. Make the final pass over the specified range if specified.
	  This function doesn't return until the range is analyzed.
	  
	  @param ea1 (C++: ea_t)
	  @param ea2 (C++: ea_t)
	  @param final_pass (C++: bool)
	  

ida_auto.plan_ea():
	
	  plan_ea(ea)
	
	
	  Plan to perform reanalysis.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_auto.plan_range():
	
	  plan_range(sEA, eEA)
	
	
	  Plan to perform reanalysis.
	  
	  
	  @param sEA (C++: ea_t)
	  @param eEA (C++: ea_t)
	  

ida_auto.reanalyze_callers():
	
	  reanalyze_callers(ea, noret)
	
	
	  Plan to reanalyze callers of the specified address. This function will
	  add to 'AU_USED' queue all instructions that call (not jump to) the
	  specified address.
	  
	  @param ea: linear address of callee (C++: ea_t)
	  @param noret: !=0: the callee doesn't return, mark to undefine
	                subsequent instructions in the caller. 0: do nothing.
	                (C++: bool)
	  

ida_auto.revert_ida_decisions():
	
	  revert_ida_decisions(ea1, ea2)
	
	
	  Delete all analysis info that IDA generated for for the given range.
	  
	  
	  @param ea1 (C++: ea_t)
	  @param ea2 (C++: ea_t)
	  

ida_auto.set_auto_state():
	
	  set_auto_state(new_state) -> atype_t
	
	
	  Set current state of autoanalyzer.
	  
	  @param new_state: new state of autoanalyzer (C++: atype_t)
	  @return: previous state
	  

ida_auto.set_ida_state():
	
	  set_ida_state(st) -> idastate_t
	
	
	  Change IDA status indicator value
	  
	  @param st: - new indicator status (C++: idastate_t)
	  @return: old indicator status
	  

ida_auto.show_addr():
	
	  show_addr(ea)
	
	
	  Show an address on the autoanalysis indicator. The address is
	  displayed in the form " @:12345678".
	  
	  @param ea: - linear address to display (C++: ea_t)
	  

ida_auto.show_auto():
	
	  show_auto(ea, type=AU_NONE)
	
	
	  Change autoanalysis indicator value.
	  
	  @param ea: linear address being analyzed (C++: ea_t)
	  @param type: autoanalysis type (see  Autoanalysis queues ) (C++:
	               atype_t)
	  

ida_bytes.add_byte():
	
	  add_byte(ea, value)
	
	
	  Add a value to one byte of the program. This function works for wide
	  byte processors too.
	  
	  @param ea: linear address (C++: ea_t)
	  @param value: byte value (C++: uint32)
	  

ida_bytes.add_dword():
	
	  add_dword(ea, value)
	
	
	  Add a value to one dword of the program. This function works for wide
	  byte processors too. This function takes into account order of bytes
	  specified in {is_be()}this function works incorrectly if {nbits} > 16
	  
	  @param ea: linear address (C++: ea_t)
	  @param value: byte value (C++: uint64)
	  

ida_bytes.add_hidden_range():
	
	  add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
	
	
	  Mark a range of addresses as hidden. The range will be created in the
	  invisible state with the default color
	  
	  @param ea1: linear address of start of the address range (C++: ea_t)
	  @param ea2: linear address of end of the address range (C++: ea_t)
	  @param description: range parameters (C++: const char *)
	  @param header: range parameters (C++: const char *)
	  @param footer: range parameters (C++: const char *)
	  @param color (C++: bgcolor_t)
	  @return: success
	  

ida_bytes.add_mapping():
	
	  add_mapping(_from, to, size) -> bool
	
	
	  IDA supports memory mapping. References to the addresses from the
	  mapped range use data and meta-data from the mapping range.You should
	  set flag PR2_MAPPING in ph.flag2 to use memory mapping Add memory
	  mapping range.
	  
	  @param _from: start of the mapped range (nonexistent address) (C++:
	                ea_t)
	  @param to: start of the mapping range (existent address) (C++: ea_t)
	  @param size: size of the range (C++: asize_t)
	  @return: success
	  

ida_bytes.add_qword():
	
	  add_qword(ea, value)
	
	
	  Add a value to one qword of the program. This function does not work
	  for wide byte processors. This function takes into account order of
	  bytes specified in {is_be()}
	  
	  @param ea: linear address (C++: ea_t)
	  @param value: byte value (C++: uint64)
	  

ida_bytes.add_word():
	
	  add_word(ea, value)
	
	
	  Add a value to one word of the program. This function works for wide
	  byte processors too. This function takes into account order of bytes
	  specified in {is_be()}
	  
	  @param ea: linear address (C++: ea_t)
	  @param value: byte value (C++: uint64)
	  

ida_bytes.align_flag():
	
	  align_flag() -> flags_t
	
	
	  Get a flags_t representing an alignment directive.
	  

ida_bytes.append_cmt():
	
	  append_cmt(ea, str, rptble) -> bool
	
	
	  Append to an indented comment. Creates a new comment if none exists.
	  Appends a newline character and the specified string otherwise.
	  
	  @param ea: linear address (C++: ea_t)
	  @param str: comment string to append (C++: const char *)
	  @param rptble: append to repeatable comment? (C++: bool)
	  @return: success
	  

ida_bytes.attach_custom_data_format():
	
	  attach_custom_data_format(dtid, dfid) -> bool
	
	
	  Attach the data format to the data type.
	  
	  @param dtid: data type id that can use the data format. 0 means all
	               standard data types. Such data formats can be applied to
	               any data item or instruction operands. For instruction
	               operands, the  data_format_t::value_size  check is not
	               performed by the kernel. (C++: int)
	  @param dfid: data format id (C++: int)
	  

ida_bytes.bin_flag():
	
	  bin_flag() -> flags_t
	
	
	  Get number flag of the base, regardless of current processor - better
	  to use 'num_flag()'
	  

ida_bytes.bin_search():
	
	  bin_search(start_ea, end_ea, image, mask, step, flags) -> ea_t
	  

ida_bytes.byte_flag():
	
	  byte_flag() -> flags_t
	
	
	  Get a flags_t representing a byte.
	  

ida_bytes.bytesize():
	
	  bytesize(ea) -> int
	
	
	  Get number of bytes required to store a byte at the given address.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.calc_def_align():
	
	  calc_def_align(ea, mina, maxa) -> int
	
	
	  Calculate default alignment.
	  
	  
	  @param ea (C++: ea_t)
	  @param mina (C++: int)
	  @param maxa (C++: int)
	  

ida_bytes.calc_max_align():
	
	  calc_max_align(endea) -> int
	
	
	  Returns: 0..32.
	  
	  
	  @param endea (C++: ea_t)
	  

ida_bytes.calc_max_item_end():
	
	  calc_max_item_end(ea, how=15) -> ea_t
	
	
	  Calculate maximal reasonable end address of a new item. This function
	  will limit the item with the current segment bounds.
	  
	  @param ea: linear address (C++: ea_t)
	  @param how: when to stop the search. A combination of  Item end search
	              flags (C++: int)
	  @return: end of new item. If it is not possible to create an item, it
	           will return 'ea'.
	  

ida_bytes.calc_min_align():
	
	  calc_min_align(length) -> int
	
	
	  Returns: 1..32.
	  
	  
	  @param length (C++: asize_t)
	  

ida_bytes.can_define_item():
	
	  can_define_item(ea, length, flags) -> bool
	
	
	  Can define item (instruction/data) of the specified 'length', starting
	  at 'ea'?if there is an item starting at 'ea', this function ignores
	  itthis function converts to unexplored all encountered data items with
	  fixup information. Should be fixed in the future.a new item would
	  cross segment boundariesa new item would overlap with existing items
	  (except items specified by 'flags')
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  @param flags: if not 0, then the kernel will ignore the data types
	                specified by the flags and destroy them. For example:
	                1000 dw 5                  1002 db 5 ; undef
	                1003 db 5 ; undef                  1004 dw 5
	                1006 dd 5                    can_define_item(1000, 6, 0)
	                - false because of dw at 1004    can_define_item(1000,
	                6, word_flag()) - true, word at 1004 is destroyed (C++:
	                flags_t)
	  @return: 1-yes, 0-no
	  

ida_bytes.change_storage_type():
	
	  change_storage_type(start_ea, end_ea, stt) -> error_t
	
	
	  Change flag storage type for address range.
	  
	  @param start_ea: should be lower than end_ea. (C++: ea_t)
	  @param end_ea: does not belong to the range. (C++: ea_t)
	  @param stt: storage_type_t (C++: storage_type_t)
	  @return: error code
	  

ida_bytes.char_flag():
	
	  char_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.chunk_size():
	
	  chunk_size(ea) -> asize_t
	
	
	  Get size of the contiguous address block containing 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: 0 if 'ea' doesn't belong to the program.
	  

ida_bytes.chunk_start():
	
	  chunk_start(ea) -> ea_t
	
	
	  Get start of the contiguous address block containing 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if 'ea' doesn't belong to the program.
	  

ida_bytes.clr_lzero():
	
	  clr_lzero(ea, n) -> bool
	
	
	  Clear lzero bit.
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.clr_op_type():
	
	  clr_op_type(ea, n) -> bool
	
	
	  Remove operand representation information. (set operand representation
	  to be 'undefined')
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: success
	  

ida_bytes.code_flag():
	
	  code_flag() -> flags_t
	
	
	   'FF_CODE'
	  

ida_bytes.create_16bit_data():
	
	  create_16bit_data(ea, length) -> bool
	
	
	  Convert to 16-bit quantity (take byte size into account)
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_32bit_data():
	
	  create_32bit_data(ea, length) -> bool
	
	
	  Convert to 32-bit quantity (take byte size into account)
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_align():
	
	  create_align(ea, length, alignment) -> bool
	
	
	  Alignment: 0 or 2..32. If it is 0, is will be calculated.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  @param alignment (C++: int)
	  

ida_bytes.create_byte():
	
	  create_byte(ea, length) -> bool
	
	
	  Convert to byte.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_custdata():
	
	  create_custdata(ea, length, dtid, fid) -> bool
	
	
	  Convert to custom data type.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  @param dtid (C++: int)
	  @param fid (C++: int)
	  

ida_bytes.create_data():
	
	  create_data(ea, dataflag, size, tid) -> bool
	
	
	  Convert to data (byte, word, dword, etc). This function may be used to
	  create arrays.
	  
	  @param ea: linear address (C++: ea_t)
	  @param dataflag: type of data. Value of function  byte_flag() ,
	                   word_flag() , etc. (C++: flags_t)
	  @param size: size of array in bytes. should be divisible by the size
	               of one item of the specified type. for variable sized
	               items it can be specified as 0, and the kernel will try
	               to calculate the size. (C++: asize_t)
	  @param tid: type id. If the specified type is a structure, then tid is
	              structure id. Otherwise should be  BADNODE . (C++: tid_t)
	  @return: success
	  

ida_bytes.create_double():
	
	  create_double(ea, length) -> bool
	
	
	  Convert to double.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_dword():
	
	  create_dword(ea, length) -> bool
	
	
	  Convert to dword.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_float():
	
	  create_float(ea, length) -> bool
	
	
	  Convert to float.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_oword():
	
	  create_oword(ea, length) -> bool
	
	
	  Convert to octaword/xmm word.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_packed_real():
	
	  create_packed_real(ea, length) -> bool
	
	
	  Convert to packed decimal real.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_qword():
	
	  create_qword(ea, length) -> bool
	
	
	  Convert to quadword.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_strlit():
	
	  create_strlit(start, len, strtype) -> bool
	
	
	  Convert to string literal and give a meaningful name. 'start' may be
	  higher than 'end', the kernel will swap them in this case
	  
	  @param start: starting address (C++: ea_t)
	  @param len: length of the string in bytes. if 0, then
	              get_max_strlit_length()  will be used to determine the
	              length (C++: size_t)
	  @param strtype: string type. one of  String type codes (C++: int32)
	  @return: success
	  

ida_bytes.create_struct():
	
	  create_struct(ea, length, tid) -> bool
	
	
	  Convert to struct
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  @param tid (C++: tid_t)
	  

ida_bytes.create_tbyte():
	
	  create_tbyte(ea, length) -> bool
	
	
	  Convert to tbyte.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_word():
	
	  create_word(ea, length) -> bool
	
	
	  Convert to word.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_yword():
	
	  create_yword(ea, length) -> bool
	
	
	  Convert to ymm word.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.create_zword():
	
	  create_zword(ea, length) -> bool
	
	
	  Convert to zmm word.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  

ida_bytes.cust_flag():
	
	  cust_flag() -> flags_t
	
	
	  Get a flags_t representing custom type data.
	  

ida_bytes.custfmt_flag():
	
	  custfmt_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

class ida_bytes.data_format_t():
	
	    Proxy of C++ data_format_t class
	    

ida_bytes.data_format_t.hotkey:
	data_format_t_hotkey_get(self) -> char const *

ida_bytes.data_format_t.id:
	
	        __get_id(self) -> int
	        

ida_bytes.data_format_t.is_present_in_menus():
	
	        is_present_in_menus(self) -> bool
	        

ida_bytes.data_format_t.menu_name:
	data_format_t_menu_name_get(self) -> char const *

ida_bytes.data_format_t.name:
	data_format_t_name_get(self) -> char const *

ida_bytes.data_format_t.props:
	data_format_t_props_get(self) -> int

ida_bytes.data_format_t.text_width:
	data_format_t_text_width_get(self) -> int32

ida_bytes.data_format_t.value_size:
	data_format_t_value_size_get(self) -> asize_t

class ida_bytes.data_type_t():
	
	    Proxy of C++ data_type_t class
	    

ida_bytes.data_type_t.asm_keyword:
	data_type_t_asm_keyword_get(self) -> char const *

ida_bytes.data_type_t.hotkey:
	data_type_t_hotkey_get(self) -> char const *

ida_bytes.data_type_t.id:
	
	        __get_id(self) -> int
	        

ida_bytes.data_type_t.is_present_in_menus():
	
	        is_present_in_menus(self) -> bool
	        

ida_bytes.data_type_t.menu_name:
	data_type_t_menu_name_get(self) -> char const *

ida_bytes.data_type_t.name:
	data_type_t_name_get(self) -> char const *

ida_bytes.data_type_t.props:
	data_type_t_props_get(self) -> int

ida_bytes.data_type_t.value_size:
	data_type_t_value_size_get(self) -> asize_t

ida_bytes.dec_flag():
	
	  dec_flag() -> flags_t
	
	
	  Get number flag of the base, regardless of current processor - better
	  to use 'num_flag()'
	  

ida_bytes.del_hidden_range():
	
	  del_hidden_range(ea) -> bool
	
	
	  Delete hidden range.
	  
	  @param ea: any address in the hidden range (C++: ea_t)
	  @return: success
	  

ida_bytes.del_items():
	
	  del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
	
	
	  Convert item (instruction/data) to unexplored bytes. The whole item
	  (including the head and tail bytes) will be destroyed. It is allowed
	  to pass any address in the item to this function
	  
	  @param ea: any address within the first item to delete (C++: ea_t)
	  @param flags: combination of  Unexplored byte conversion flags (C++:
	                int)
	  @param nbytes: number of bytes in the range to be undefined (C++:
	                 asize_t)
	  @param may_destroy: optional routine invoked before deleting a head
	                      item. If callback returns false then item has not
	                      to be deleted and operation fails (C++:
	                      may_destroy_cb_t  *)
	  @return: true on sucessful operation, otherwise false
	  

ida_bytes.del_mapping():
	
	  del_mapping(ea)
	
	
	  Delete memory mapping range.
	  
	  @param ea: any address in the mapped range (C++: ea_t)
	  

ida_bytes.del_value():
	
	  del_value(ea)
	
	
	  Delete byte value from flags. The corresponding byte becomes
	  uninitialized.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.detach_custom_data_format():
	
	  detach_custom_data_format(dtid, dfid) -> bool
	
	
	  Detach the data format from the data type. Unregistering a custom data
	  type detaches all attached data formats, no need to detach them
	  explicitly. You still need unregister them. Unregistering a custom
	  data format detaches it from all attached data types.
	  
	  @param dtid: data type id to detach data format from (C++: int)
	  @param dfid: data format id to detach (C++: int)
	  

ida_bytes.disable_flags():
	
	  disable_flags(start_ea, end_ea) -> error_t
	
	
	  Deallocate flags for address range. Exit with an error message if not
	  enough disk space (this may occur too).
	  
	  @param start_ea: should be lower than end_ea. (C++: ea_t)
	  @param end_ea: does not belong to the range. (C++: ea_t)
	  @return: 0 if ok, otherwise return error code
	  

ida_bytes.double_flag():
	
	  double_flag() -> flags_t
	
	
	  Get a flags_t representing a double.
	  

ida_bytes.dword_flag():
	
	  dword_flag() -> flags_t
	
	
	  Get a flags_t representing a double word.
	  

ida_bytes.enable_flags():
	
	  enable_flags(start_ea, end_ea, stt) -> error_t
	
	
	  Allocate flags for address range. This function does not change the
	  storage type of existing ranges. Exit with an error message if not
	  enough disk space.
	  
	  @param start_ea: should be lower than end_ea. (C++: ea_t)
	  @param end_ea: does not belong to the range. (C++: ea_t)
	  @param stt: storage_type_t (C++: storage_type_t)
	  @return: 0 if ok, otherwise an error code
	  

ida_bytes.enum_flag():
	
	  enum_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.equal_bytes():
	
	  equal_bytes(ea, image, mask, len, sense_case) -> bool
	
	
	  Compare 'len' bytes of the program starting from 'ea' with 'image'.
	  
	  @param ea: linear address (C++: ea_t)
	  @param image: bytes to compare with (C++: const  uchar  *)
	  @param mask: array of 1/0 bytes, it's length is 'len'. 1 means to
	               perform the comparison of the corresponding byte. 0 means
	               not to perform. if mask == NULL, then all bytes of
	               'image' will be compared. if mask ==  SKIP_FF_MASK  then
	               0xFF bytes will be skipped (C++: const  uchar  *)
	  @param len: length of block to compare in bytes. (C++: size_t)
	  @param sense_case: case-sensitive comparison? (C++: bool)
	  

ida_bytes.f_has_cmt():
	
	  f_has_cmt(f, arg2) -> bool
	  

ida_bytes.f_has_dummy_name():
	
	  f_has_dummy_name(f, arg2) -> bool
	
	
	  Does the current byte have dummy (auto-generated, with special prefix)
	  name?
	  
	  
	  @param f (C++: flags_t)
	  

ida_bytes.f_has_extra_cmts():
	
	  f_has_extra_cmts(f, arg2) -> bool
	  

ida_bytes.f_has_name():
	
	  f_has_name(f, arg2) -> bool
	
	
	  Does the current byte have non-trivial (non-dummy) name?
	  
	  
	  @param f (C++: flags_t)
	  

ida_bytes.f_has_user_name():
	
	  f_has_user_name(F, arg2) -> bool
	
	
	  Does the current byte have user-specified name?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_has_xref():
	
	  f_has_xref(f, arg2) -> bool
	
	
	  Does the current byte have cross-references to it?
	  
	  
	  @param f (C++: flags_t)
	  

ida_bytes.f_is_align():
	
	  f_is_align(F, arg2) -> bool
	
	
	  See 'is_align()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_byte():
	
	  f_is_byte(F, arg2) -> bool
	
	
	  See 'is_byte()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_code():
	
	  f_is_code(F, arg2) -> bool
	
	
	  Does flag denote start of an instruction?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_custom():
	
	  f_is_custom(F, arg2) -> bool
	
	
	  See 'is_custom()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_data():
	
	  f_is_data(F, arg2) -> bool
	
	
	  Does flag denote start of data?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_double():
	
	  f_is_double(F, arg2) -> bool
	
	
	  See 'is_double()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_dword():
	
	  f_is_dword(F, arg2) -> bool
	
	
	  See 'is_dword()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_float():
	
	  f_is_float(F, arg2) -> bool
	
	
	  See 'is_float()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_head():
	
	  f_is_head(F, arg2) -> bool
	
	
	  Does flag denote start of instruction OR data?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_not_tail():
	
	  f_is_not_tail(F, arg2) -> bool
	
	
	  Does flag denote tail byte?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_oword():
	
	  f_is_oword(F, arg2) -> bool
	
	
	  See 'is_oword()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_pack_real():
	
	  f_is_pack_real(F, arg2) -> bool
	
	
	  See 'is_pack_real()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_qword():
	
	  f_is_qword(F, arg2) -> bool
	
	
	  See 'is_qword()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_strlit():
	
	  f_is_strlit(F, arg2) -> bool
	
	
	  See 'is_strlit()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_struct():
	
	  f_is_struct(F, arg2) -> bool
	
	
	  See 'is_struct()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_tail():
	
	  f_is_tail(F, arg2) -> bool
	
	
	  Does flag denote tail byte?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_tbyte():
	
	  f_is_tbyte(F, arg2) -> bool
	
	
	  See 'is_tbyte()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_word():
	
	  f_is_word(F, arg2) -> bool
	
	
	  See 'is_word()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.f_is_yword():
	
	  f_is_yword(F, arg2) -> bool
	
	
	  See 'is_yword()'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.find_byte():
	
	  find_byte(sEA, size, value, bin_search_flags) -> ea_t
	
	
	  Find forward a byte with the specified value (only 8-bit value from
	  the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6
	  
	  @param sEA: linear address (C++: ea_t)
	  @param size: number of bytes to inspect (C++: asize_t)
	  @param value: value to find (C++: uchar)
	  @param bin_search_flags: combination of  Search flags (C++: int)
	  @return: address of byte or  BADADDR
	  

ida_bytes.find_byter():
	
	  find_byter(sEA, size, value, bin_search_flags) -> ea_t
	
	
	  Find reverse a byte with the specified value (only 8-bit value from
	  the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4
	  
	  @param sEA: the lower address of the search range (C++: ea_t)
	  @param size: number of bytes to inspect (C++: asize_t)
	  @param value: value to find (C++: uchar)
	  @param bin_search_flags: combination of  Search flags (C++: int)
	  @return: address of byte or  BADADDR
	  

ida_bytes.find_custom_data_format():
	
	  find_custom_data_format(name) -> int
	
	
	  Get id of a custom data format.
	  
	  @param name: name of the custom data format (C++: const char *)
	  @return: id or -1
	  

ida_bytes.find_custom_data_type():
	
	  find_custom_data_type(name) -> int
	
	
	  Get id of a custom data type.
	  
	  @param name: name of the custom data type (C++: const char *)
	  @return: id or -1
	  

ida_bytes.float_flag():
	
	  float_flag() -> flags_t
	
	
	  Get a flags_t representing a float.
	  

ida_bytes.flt_flag():
	
	  flt_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.free_chunk():
	
	  free_chunk(bottom, size, step) -> ea_t
	
	
	  Search for a hole in the addressing space of the program.
	  
	  @param bottom: address to start searching (C++: ea_t)
	  @param size: size of desired block (C++: asize_t)
	  @param step: bit mask for the start of hole (0xF would align hole to a
	               paragraph). if 'step' is negative, the bottom address
	               with be aligned. otherwise the kernel will try to use it
	               as is and align it only when the hole is too small. (C++:
	               int32)
	  @return: start of the hole or  BADADDR
	  

ida_bytes.get_16bit():
	
	  get_16bit(ea) -> uint32
	
	
	  Get 16bits of the program at 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: 1 byte (getFullByte()) if the current processor has 16-bit
	           byte, otherwise return  get_word()
	  

ida_bytes.get_32bit():
	
	  get_32bit(ea) -> uint32
	
	
	  Get not more than 32bits of the program at 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: 32 bit value, depending on {nbits}:   if ( nbits <= 8 )
	           return get_dword(ea); if ( nbits <= 16) return
	           get_wide_word(ea); return get_wide_byte(ea);
	  

ida_bytes.get_64bit():
	
	  get_64bit(ea) -> uint64
	
	
	  Get not more than 64bits of the program at 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: 64 bit value, depending on {nbits}:   if ( nbits <= 8 )
	           return get_qword(ea); if ( nbits <= 16) return
	           get_wide_dword(ea); return get_wide_byte(ea);
	  

ida_bytes.get_8bit():
	
	  get_8bit(ea, v, nbit) -> PyObject *
	  

ida_bytes.get_byte():
	
	  get_byte(ea) -> uchar
	
	
	  Get one byte (8-bit) of the program at 'ea'. This function works only
	  for 8bit byte processors.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_bytes():
	
	  get_bytes(ea, size, gmb_flags=0x01) -> PyObject *
	
	
	  Get the specified number of bytes of the program.
	  @param ea: program address
	  @param size: number of bytes to return
	  @return: the bytes (as a str), or None in case of failure
	  

ida_bytes.get_bytes_and_mask():
	
	  get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *
	
	
	  Get the specified number of bytes of the program, and a bitmask
	  specifying what bytes are defined and what bytes are not.
	  @param ea: program address
	  @param size: number of bytes to return
	  @return: a tuple (bytes, mask), or None in case of failure.
	           Both 'bytes' and 'mask' are 'str' instances.
	  

ida_bytes.get_cmt():
	
	  get_cmt(ea, rptble) -> ssize_t
	
	
	  Get an indented comment.
	  
	  @param ea: linear address. may point to tail byte, the function will
	             find start of the item (C++: ea_t)
	  @param rptble: get repeatable comment? (C++: bool)
	  @return: size of comment or -1
	  

ida_bytes.get_custom_data_format():
	
	  get_custom_data_format(dfid) -> data_format_t
	
	
	  Get definition of a registered custom data format.
	  
	  @param dfid: data format id (C++: int)
	  @return: data format definition or NULL
	  

ida_bytes.get_custom_data_formats():
	
	  get_custom_data_formats(out, dtid) -> int
	
	
	  Get list of attached custom data formats for the specified data type.
	  
	  @param out: buffer for the output. may be NULL (C++: intvec_t  *)
	  @param dtid: data type id (C++: int)
	  @return: number of returned custom data formats. if error, returns -1
	  

ida_bytes.get_custom_data_type():
	
	  get_custom_data_type(dtid) -> data_type_t
	
	
	  Get definition of a registered custom data type.
	  
	  @param dtid: data type id (C++: int)
	  @return: data type definition or NULL
	  

ida_bytes.get_custom_data_types():
	
	  get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
	
	
	  Get list of registered custom data type ids.
	  
	  @param out: buffer for the output. may be NULL (C++: intvec_t  *)
	  @param min_size: minimum value size (C++: asize_t)
	  @param max_size: maximum value size (C++: asize_t)
	  @return: number of custom data types with the specified size limits
	  

ida_bytes.get_data_elsize():
	
	  get_data_elsize(ea, F, ti=None) -> asize_t
	
	
	  Get size of data type specified in flags 'F'.
	  
	  @param ea: linear address of the item (C++: ea_t)
	  @param F: flags (C++: flags_t)
	  @param ti: additional information about the data type. For example, if
	             the current item is a structure instance, then ti->tid is
	             structure id. Otherwise is ignored (may be NULL). If
	             specified as NULL, will be automatically retrieved from the
	             database (C++: const  opinfo_t  *)
	  @return: byte : 1 word : 2 etc...
	  

ida_bytes.get_data_value():
	
	  get_data_value(v, ea, size) -> bool
	
	
	  Get the value at of the item at 'ea'. This function works with
	  entities up to sizeof(ea_t) (bytes, word, etc)
	  
	  @param v: pointer to the result. may be NULL (C++: uval_t  *)
	  @param ea: linear address (C++: ea_t)
	  @param size: size of data to read. If 0, then the item type at 'ea'
	               will be used (C++: asize_t)
	  @return: success
	  

ida_bytes.get_db_byte():
	
	  get_db_byte(ea) -> uchar
	
	
	  Get one byte (8-bit) of the program at 'ea' from the database. Works
	  even if the debugger is active. See also 'get_dbg_byte()' to read the
	  process memory directly. This function works only for 8bit byte
	  processors.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_default_radix():
	
	  get_default_radix() -> int
	
	
	  Get default base of number for the current processor.
	  
	  @return: 2, 8, 10, 16
	  

ida_bytes.get_dword():
	
	  get_dword(ea) -> uint32
	
	
	  Get one dword (32-bit) of the program at 'ea'. This function takes
	  into account order of bytes specified in {is_be()} This function works
	  only for 8bit byte processors.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_enum_id():
	
	  get_enum_id(ea, n) -> enum_t
	
	
	  Get enum id of 'enum' operand.
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: id of enum or  BADNODE
	  

ida_bytes.get_first_hidden_range():
	
	  get_first_hidden_range() -> hidden_range_t
	
	
	  Get pointer to the first hidden range.
	  
	  @return: ptr to hidden range or NULL
	  

ida_bytes.get_flags():
	
	  get_flags(ea) -> flags_t
	
	
	  get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
	  debugging because the kernel needs to read the process memory.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_flags_by_size():
	
	  get_flags_by_size(size) -> flags_t
	
	
	  Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32.
	  For other sizes returns 0
	  
	  @param size (C++: size_t)
	  

ida_bytes.get_flags_ex():
	
	  get_flags_ex(ea, how) -> flags_t
	
	
	  Get flags for the specified address, extended form.
	  
	  
	  @param ea (C++: ea_t)
	  @param how (C++: int)
	  

ida_bytes.get_forced_operand():
	
	  get_forced_operand(ea, n) -> ssize_t
	
	
	  Get forced operand.
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, 2) (C++: int)
	  @return: size of forced operand or -1
	  

ida_bytes.get_full_data_elsize():
	
	  get_full_data_elsize(ea, F, ti=None) -> asize_t
	
	
	  Get full size of data type specified in flags 'F'. takes into account
	  processors with wide bytes e.g. returns 2 for a byte element with
	  16-bit bytes
	  
	  @param ea (C++: ea_t)
	  @param F (C++: flags_t)
	  @param ti (C++: const  opinfo_t  *)
	  

ida_bytes.get_full_flags():
	
	  get_full_flags(ea) -> flags_t
	
	
	  Get flags value for address 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: 0 if address is not present in the program
	  

ida_bytes.get_hidden_range():
	
	  get_hidden_range(ea) -> hidden_range_t
	
	
	  Get pointer to hidden range structure, in: linear address.
	  
	  @param ea: any address in the hidden range (C++: ea_t)
	  

ida_bytes.get_hidden_range_num():
	
	  get_hidden_range_num(ea) -> int
	
	
	  Get number of a hidden range.
	  
	  @param ea: any address in the hidden range (C++: ea_t)
	  @return: number of hidden range (0.. get_hidden_range_qty() -1)
	  

ida_bytes.get_hidden_range_qty():
	
	  get_hidden_range_qty() -> int
	
	
	  Get number of hidden ranges.
	  

ida_bytes.get_item_end():
	
	  get_item_end(ea) -> ea_t
	
	
	  Get the end address of the item at 'ea'. The returned address doesn't
	  belong to the current item. Unexplored bytes are counted as 1 byte
	  entities.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_item_flag():
	
	  get_item_flag(_from, n, ea, appzero) -> flags_t
	
	
	  Get flag of the item at 'ea' even if it is a tail byte of some array
	  or structure. This function is used to get flags of structure members
	  or array elements.
	  
	  @param _from: linear address of the instruction which refers to 'ea'
	                (C++: ea_t)
	  @param n: number of operand which refers to 'ea' (C++: int)
	  @param ea: the referenced address (C++: ea_t)
	  @param appzero: append a struct field name if the field offset is
	                  zero? meaningful only if the name refers to a
	                  structure. (C++: bool)
	  @return: flags or 0 (if failed)
	  

ida_bytes.get_item_head():
	
	  get_item_head(ea) -> ea_t
	
	
	  Get the start address of the item at 'ea'. If there is no current
	  item, then 'ea' will be returned (see definition at the end of
	  'bytes.hpp' source)
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_item_size():
	
	  get_item_size(ea) -> asize_t
	
	
	  Get size of item (instruction/data) in bytes. Unexplored bytes have
	  length of 1 byte. This function never returns 0.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_last_hidden_range():
	
	  get_last_hidden_range() -> hidden_range_t
	
	
	  Get pointer to the last hidden range.
	  
	  @return: ptr to hidden range or NULL
	  

ida_bytes.get_manual_insn():
	
	  get_manual_insn(ea) -> ssize_t
	
	
	  Retrieve the user-specified string for the manual instruction.
	  
	  @param ea: linear address of the instruction or data item (C++: ea_t)
	  @return: size of manual instruction or -1
	  

ida_bytes.get_mapping():
	
	  get_mapping(n) -> bool
	
	
	  Get memory mapping range by its number.
	  
	  @param n: number of mapping range (0.. get_mappings_qty() -1) (C++:
	            size_t)
	  @return: false if the specified range doesn't exist, otherwise returns
	           `from', `to', `size'
	  

ida_bytes.get_mappings_qty():
	
	  get_mappings_qty() -> size_t
	
	
	  Get number of mappings.
	  

ida_bytes.get_max_strlit_length():
	
	  get_max_strlit_length(ea, strtype, options=0) -> size_t
	
	
	  Determine maximum length of string literal.
	  
	  @param ea: starting address (C++: ea_t)
	  @param strtype: string type. one of  String type codes (C++: int32)
	  @param options: combination of  string literal length options (C++:
	                  int)
	  @return: length of the string in octets (octet==8bit)
	  

ida_bytes.get_next_hidden_range():
	
	  get_next_hidden_range(ea) -> hidden_range_t
	
	
	  Get pointer to next hidden range.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: ptr to hidden range or NULL if next hidden range doesn't
	           exist
	  

ida_bytes.get_octet():
	
	  get_octet(ea, v, nbit) -> PyObject *
	
	
	  Get 8 bits of the program at 'ea'. The main usage of this function is
	  to iterate range of bytes. Here is an example:'ea' is incremented each
	  time when a new byte is read. In the above example, it will be
	  incremented in the first loop iteration.uint64v;intnbit=0;for(...){uch
	  arbyte=get_octet(&ea,&v,&nbit);...}
	  
	  @param ea (C++: ea_t *)
	  @param v (C++: uint64  *)
	  @param nbit (C++: int *)
	  

ida_bytes.get_opinfo():
	
	  get_opinfo(buf, ea, n, flags) -> opinfo_t
	
	
	  Get additional information about an operand representation.
	  
	  @param buf: buffer to receive the result. may not be NULL (C++:
	              opinfo_t  *)
	  @param ea: linear address of item (C++: ea_t)
	  @param n: number of operand, 0 or 1 (C++: int)
	  @param flags: flags of the item (C++: flags_t)
	  @return: NULL if no additional representation information
	  

ida_bytes.get_optype_flags0():
	
	  get_optype_flags0(F) -> flags_t
	
	
	  Get flags for first operand.
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.get_optype_flags1():
	
	  get_optype_flags1(F) -> flags_t
	
	
	  Get flags for second operand.
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.get_original_byte():
	
	  get_original_byte(ea) -> uint64
	
	
	  Get original byte value (that was before patching). This function
	  works for wide byte processors too.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_original_dword():
	
	  get_original_dword(ea) -> uint64
	
	
	  Get original dword (that was before patching) This function works for
	  wide byte processors too. This function takes into account order of
	  bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_original_qword():
	
	  get_original_qword(ea) -> uint64
	
	
	  Get original qword value (that was before patching) This function
	  DOESN'T work for wide byte processors too. This function takes into
	  account order of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_original_word():
	
	  get_original_word(ea) -> uint64
	
	
	  Get original word value (that was before patching). This function
	  works for wide byte processors too. This function takes into account
	  order of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_predef_insn_cmt():
	
	  get_predef_insn_cmt(ins) -> ssize_t
	
	
	  Get predefined comment.
	  
	  @param ins: current instruction information (C++: const  insn_t  &)
	  @return: size of comment or -1
	  

ida_bytes.get_prev_hidden_range():
	
	  get_prev_hidden_range(ea) -> hidden_range_t
	
	
	  Get pointer to previous hidden range.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: ptr to hidden range or NULL if previous hidden range doesn't
	           exist
	  

ida_bytes.get_qword():
	
	  get_qword(ea) -> uint64
	
	
	  Get one qword (64-bit) of the program at 'ea'. This function takes
	  into account order of bytes specified in {is_be()} This function works
	  only for 8bit byte processors.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_radix():
	
	  get_radix(F, n) -> int
	
	
	  Get radix of the operand, in: flags. If the operand is not a number,
	  returns 'get_default_radix()'
	  
	  @param F: flags (C++: flags_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: 2, 8, 10, 16
	  

ida_bytes.get_strlit_contents():
	
	  get_strlit_contents(ea, py_len, type, flags=0) -> PyObject *
	
	
	  Get bytes contents at location, possibly converted.
	  It works even if the string has not been created in the database yet.
	  
	  Note that this will <b>always</b> return a simple string of bytes
	  (i.e., a 'str' instance), and not a string of unicode characters.
	  
	  If you want auto-conversion to unicode strings (that is: real strings),
	  you should probably be using the idautils.Strings class.
	  
	  @param ea: linear address of the string
	  @param len: length of the string in bytes (including terminating 0)
	  @param type: type of the string. Represents both the character encoding,
	               <u>and</u> the 'type' of string at the given location.
	  @param flags: combination of STRCONV_..., to perform output conversion.
	  @return: a bytes-filled str object.
	  

ida_bytes.get_stroff_path():
	
	  get_stroff_path(path, delta, ea, n) -> int
	
	
	  Get struct path of operand.
	  
	  @param path: buffer for structure path (strpath). see  nalt.hpp  for
	               more info. (C++: tid_t  *)
	  @param delta: struct offset delta (C++: adiff_t *)
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: length of strpath
	  

ida_bytes.get_wide_byte():
	
	  get_wide_byte(ea) -> uint64
	
	
	  Get one wide byte of the program at 'ea'. Some processors may access
	  more than 8bit quantity at an address. These processors have 32-bit
	  byte organization from the IDA's point of view.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_wide_dword():
	
	  get_wide_dword(ea) -> uint64
	
	
	  Get two wide words (4 'bytes') of the program at 'ea'. Some processors
	  may access more than 8bit quantity at an address. These processors
	  have 32-bit byte organization from the IDA's point of view. This
	  function takes into account order of bytes specified in {is_be()}this
	  function works incorrectly if {nbits} > 16
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_wide_word():
	
	  get_wide_word(ea) -> uint64
	
	
	  Get one wide word (2 'byte') of the program at 'ea'. Some processors
	  may access more than 8bit quantity at an address. These processors
	  have 32-bit byte organization from the IDA's point of view. This
	  function takes into account order of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_word():
	
	  get_word(ea) -> ushort
	
	
	  Get one word (16-bit) of the program at 'ea'. This function takes into
	  account order of bytes specified in {is_be()} This function works only
	  for 8bit byte processors.
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.get_zero_ranges():
	
	  get_zero_ranges(zranges, range) -> bool
	
	
	  Return set of ranges with zero initialized bytes. The returned set
	  includes only big zero initialized ranges (at least >1KB). Some zero
	  initialized byte ranges may be not included. Only zero bytes that use
	  the sparse storage method (STT_MM) are reported.
	  
	  @param zranges: pointer to the return value. can not be NULL (C++:
	                  rangeset_t  *)
	  @param range: the range of addresses to verify. can be NULL - means
	                all ranges (C++: const  range_t  *)
	  @return: true if the result is a non-empty set
	  

ida_bytes.getn_hidden_range():
	
	  getn_hidden_range(n) -> hidden_range_t
	
	
	  Get pointer to hidden range structure, in: number of hidden range.
	  
	  @param n: number of hidden range, is in range 0..
	            get_hidden_range_qty() -1 (C++: int)
	  

ida_bytes.has_any_name():
	
	  has_any_name(F) -> bool
	
	
	  Does the current byte have any name?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_auto_name():
	
	  has_auto_name(F) -> bool
	
	
	  Does the current byte have auto-generated (no special prefix) name?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_cmt():
	
	  has_cmt(F) -> bool
	
	
	  Does the current byte have an indented comment?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_dummy_name():
	
	  has_dummy_name(F) -> bool
	
	
	  Does the current byte have dummy (auto-generated, with special prefix)
	  name?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_extra_cmts():
	
	  has_extra_cmts(F) -> bool
	
	
	  Does the current byte have additional anterior or posterior lines?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_immd():
	
	  has_immd(F) -> bool
	
	
	  Has immediate value?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_name():
	
	  has_name(F) -> bool
	
	
	  Does the current byte have non-trivial (non-dummy) name?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_user_name():
	
	  has_user_name(F) -> bool
	
	
	  Does the current byte have user-specified name?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_value():
	
	  has_value(F) -> bool
	
	
	  Do flags contain byte value?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.has_xref():
	
	  has_xref(F) -> bool
	
	
	  Does the current byte have cross-references to it?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.hex_flag():
	
	  hex_flag() -> flags_t
	
	
	  Get number flag of the base, regardless of current processor - better
	  to use 'num_flag()'
	  

class ida_bytes.hidden_range_t():
	
	    Proxy of C++ hidden_range_t class
	    

ida_bytes.hidden_range_t._print():
	
	        _print(self) -> size_t
	        

ida_bytes.hidden_range_t.clear():
	
	        clear(self)
	        

ida_bytes.hidden_range_t.color:
	hidden_range_t_color_get(self) -> bgcolor_t

ida_bytes.hidden_range_t.compare():
	
	        compare(self, r) -> int
	        

ida_bytes.hidden_range_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_bytes.hidden_range_t.description:
	hidden_range_t_description_get(self) -> char *

ida_bytes.hidden_range_t.empty():
	
	        empty(self) -> bool
	        

ida_bytes.hidden_range_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_bytes.hidden_range_t.extend():
	
	        extend(self, ea)
	        

ida_bytes.hidden_range_t.footer:
	hidden_range_t_footer_get(self) -> char *

ida_bytes.hidden_range_t.header:
	hidden_range_t_header_get(self) -> char *

ida_bytes.hidden_range_t.intersect():
	
	        intersect(self, r)
	        

ida_bytes.hidden_range_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_bytes.hidden_range_t.size():
	
	        size(self) -> asize_t
	        

ida_bytes.hidden_range_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

ida_bytes.hidden_range_t.visible:
	hidden_range_t_visible_get(self) -> bool

ida_bytes.is_align():
	
	  is_align(F) -> bool
	
	
	   'FF_ALIGN'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_attached_custom_data_format():
	
	  is_attached_custom_data_format(dtid, dfid) -> bool
	  

ida_bytes.is_bnot():
	
	  is_bnot(ea, F, n) -> bool
	
	
	  Should we negate the operand?. {a_bnot} should be defined in the idp
	  module in order to work with this function
	  
	  @param ea (C++: ea_t)
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_byte():
	
	  is_byte(F) -> bool
	
	
	   'FF_BYTE'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_char():
	
	  is_char(F, n) -> bool
	
	
	  is character constant?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_char0():
	
	  is_char0(F) -> bool
	
	
	  Is the first operand character constant? (example: push 'a')
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_char1():
	
	  is_char1(F) -> bool
	
	
	  Is the second operand character constant? (example: mov al, 'a')
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_code():
	
	  is_code(F) -> bool
	
	
	  Does flag denote start of an instruction?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_custfmt():
	
	  is_custfmt(F, n) -> bool
	
	
	  is custom data format?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_custfmt0():
	
	  is_custfmt0(F) -> bool
	
	
	  Does the first operand use a custom data representation?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_custfmt1():
	
	  is_custfmt1(F) -> bool
	
	
	  Does the second operand use a custom data representation?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_custom():
	
	  is_custom(F) -> bool
	
	
	   'FF_CUSTOM'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_data():
	
	  is_data(F) -> bool
	
	
	  Does flag denote start of data?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_defarg():
	
	  is_defarg(F, n) -> bool
	
	
	  is defined?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_defarg0():
	
	  is_defarg0(F) -> bool
	
	
	  Is the first operand defined? Initially operand has no defined
	  representation.
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_defarg1():
	
	  is_defarg1(F) -> bool
	
	
	  Is the second operand defined? Initially operand has no defined
	  representation.
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_double():
	
	  is_double(F) -> bool
	
	
	   'FF_DOUBLE'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_dword():
	
	  is_dword(F) -> bool
	
	
	   'FF_DWORD'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_enum():
	
	  is_enum(F, n) -> bool
	
	
	  is enum?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_enum0():
	
	  is_enum0(F) -> bool
	
	
	  Is the first operand a symbolic constant (enum member)?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_enum1():
	
	  is_enum1(F) -> bool
	
	
	  Is the second operand a symbolic constant (enum member)?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_float():
	
	  is_float(F) -> bool
	
	
	   'FF_FLOAT'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_float0():
	
	  is_float0(F) -> bool
	
	
	  Is the first operand a floating point number?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_float1():
	
	  is_float1(F) -> bool
	
	
	  Is the second operand a floating point number?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_flow():
	
	  is_flow(F) -> bool
	
	
	  Does the previous instruction exist and pass execution flow to the
	  current byte?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_fltnum():
	
	  is_fltnum(F, n) -> bool
	
	
	  is floating point number?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_forced_operand():
	
	  is_forced_operand(ea, n) -> bool
	
	
	  Is operand manually defined?.
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, 2) (C++: int)
	  

ida_bytes.is_func():
	
	  is_func(F) -> bool
	
	
	  Is function start?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_head():
	
	  is_head(F) -> bool
	
	
	  Does flag denote start of instruction OR data?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_invsign():
	
	  is_invsign(ea, F, n) -> bool
	
	
	  Should sign of n-th operand inverted during output?. allowed values of
	  n: 0-first operand, 1-other operands
	  
	  @param ea (C++: ea_t)
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_loaded():
	
	  is_loaded(ea) -> bool
	
	
	  Does the specified address have a byte value (is initialized?)
	  
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.is_lzero():
	
	  is_lzero(ea, n) -> bool
	
	
	  Display leading zeroes in operands. The global switch for the leading
	  zeroes is in {s_genflags} The leading zeroes doesn't work if the octal
	  numbers start with 0 Display leading zeroes? (takes into account
	  {s_genflags})
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.is_manual():
	
	  is_manual(F, n) -> bool
	
	
	  is forced operand? (use 'is_forced_operand()' )
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_manual_insn():
	
	  is_manual_insn(ea) -> bool
	
	
	  Is the instruction overridden?
	  
	  @param ea: linear address of the instruction or data item (C++: ea_t)
	  

ida_bytes.is_mapped():
	
	  is_mapped(ea) -> bool
	
	
	  Is the specified address 'ea' present in the program?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.is_not_tail():
	
	  is_not_tail(F) -> bool
	
	
	  Does flag denote tail byte?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_numop():
	
	  is_numop(F, n) -> bool
	
	
	  is number (bin, oct, dec, hex)?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_numop0():
	
	  is_numop0(F) -> bool
	
	
	  Is the first operand a number (i.e. binary, octal, decimal or hex?)
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_numop1():
	
	  is_numop1(F) -> bool
	
	
	  Is the second operand a number (i.e. binary, octal, decimal or hex?)
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_off():
	
	  is_off(F, n) -> bool
	
	
	  is offset?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_off0():
	
	  is_off0(F) -> bool
	
	
	  Is the first operand offset? (example: push offset xxx)
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_off1():
	
	  is_off1(F) -> bool
	
	
	  Is the second operand offset? (example: mov ax, offset xxx)
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_oword():
	
	  is_oword(F) -> bool
	
	
	   'FF_OWORD'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_pack_real():
	
	  is_pack_real(F) -> bool
	
	
	   'FF_PACKREAL'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_qword():
	
	  is_qword(F) -> bool
	
	
	   'FF_QWORD'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_same_data_type():
	
	  is_same_data_type(F1, F2) -> bool
	
	
	  Do the given flags specify the same data type?
	  
	  
	  @param F1 (C++: flags_t)
	  @param F2 (C++: flags_t)
	  

ida_bytes.is_seg():
	
	  is_seg(F, n) -> bool
	
	
	  is segment?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_seg0():
	
	  is_seg0(F) -> bool
	
	
	  Is the first operand segment selector? (example: push seg seg001)
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_seg1():
	
	  is_seg1(F) -> bool
	
	
	  Is the second operand segment selector? (example: mov dx, seg dseg)
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_stkvar():
	
	  is_stkvar(F, n) -> bool
	
	
	  is stack variable?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_stkvar0():
	
	  is_stkvar0(F) -> bool
	
	
	  Is the first operand a stack variable?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_stkvar1():
	
	  is_stkvar1(F) -> bool
	
	
	  Is the second operand a stack variable?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_strlit():
	
	  is_strlit(F) -> bool
	
	
	   'FF_STRLIT'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_stroff():
	
	  is_stroff(F, n) -> bool
	
	
	  is struct offset?
	  
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_stroff0():
	
	  is_stroff0(F) -> bool
	
	
	  Is the first operand an offset within a struct?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_stroff1():
	
	  is_stroff1(F) -> bool
	
	
	  Is the second operand an offset within a struct?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_struct():
	
	  is_struct(F) -> bool
	
	
	   'FF_STRUCT'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_suspop():
	
	  is_suspop(ea, F, n) -> bool
	
	
	  is suspicious operand?
	  
	  
	  @param ea (C++: ea_t)
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.is_tail():
	
	  is_tail(F) -> bool
	
	
	  Does flag denote tail byte?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_tbyte():
	
	  is_tbyte(F) -> bool
	
	
	   'FF_TBYTE'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_unknown():
	
	  is_unknown(F) -> bool
	
	
	  Does flag denote unexplored byte?
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_varsize_item():
	
	  is_varsize_item(ea, F, ti=None, itemsize=None) -> int
	
	
	  Is the item at 'ea' variable size?.
	  
	  @param ea: linear address of the item (C++: ea_t)
	  @param F: flags (C++: flags_t)
	  @param ti: additional information about the data type. For example, if
	             the current item is a structure instance, then ti->tid is
	             structure id. Otherwise is ignored (may be NULL). If
	             specified as NULL, will be automatically retrieved from the
	             database (C++: const  opinfo_t  *)
	  @param itemsize: if not NULL and the item is varsize, itemsize will
	                   contain the calculated item size (for struct types,
	                   the minimal size is returned) (C++: asize_t *)
	  

ida_bytes.is_word():
	
	  is_word(F) -> bool
	
	
	   'FF_WORD'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_yword():
	
	  is_yword(F) -> bool
	
	
	   'FF_YWORD'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.is_zword():
	
	  is_zword(F) -> bool
	
	
	   'FF_ZWORD'
	  
	  
	  @param F (C++: flags_t)
	  

ida_bytes.leading_zero_important():
	
	  leading_zero_important(ea, n) -> bool
	
	
	  Check if leading zeroes are important.
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.nbits():
	
	  nbits(ea) -> int
	
	
	  Get number of bits in a byte at the given address.
	  
	  @param ea (C++: ea_t)
	  @return: {dnbits()} if the address doesn't belong to a segment,
	           otherwise the result depends on the segment type
	  

ida_bytes.next_addr():
	
	  next_addr(ea) -> ea_t
	
	
	  Get next address in the program (i.e. next address which has flags).
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if no such address exist.
	  

ida_bytes.next_chunk():
	
	  next_chunk(ea) -> ea_t
	
	
	  Get the first address of next contiguous chunk in the program.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if next chunk doesn't exist.
	  

ida_bytes.next_head():
	
	  next_head(ea, maxea) -> ea_t
	
	
	  Get start of next defined item.
	  
	  @param ea: begin search at this address (C++: ea_t)
	  @param maxea: not included in the search range (C++: ea_t)
	  @return: BADADDR  if none exists.
	  

ida_bytes.next_inited():
	
	  next_inited(ea, maxea) -> ea_t
	
	
	  Find the next initialized address.
	  
	  
	  @param ea (C++: ea_t)
	  @param maxea (C++: ea_t)
	  

ida_bytes.next_not_tail():
	
	  next_not_tail(ea) -> ea_t
	
	
	  Get address of next non-tail byte.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if none exists.
	  

ida_bytes.next_that():
	
	  next_that(ea, maxea, callable) -> ea_t
	
	
	  Find next address with a flag satisfying the function 'testf'.
	  Start searching from address 'ea'+1 and inspect bytes up to 'maxea'.
	  maxea is not included in the search range.
	  
	  @param callable: a Python callable with the following prototype:
	                   callable(flags). Return True to stop enumeration.
	  @return: the found address or BADADDR.
	  

ida_bytes.next_unknown():
	
	  next_unknown(ea, maxea) -> ea_t
	
	
	  Similar to 'next_that()' , but will find the next address that is
	  unexplored.
	  
	  
	  @param ea (C++: ea_t)
	  @param maxea (C++: ea_t)
	  

ida_bytes.num_flag():
	
	  num_flag() -> flags_t
	
	
	  Get number of default base (bin, oct, dec, hex)
	  

ida_bytes.oct_flag():
	
	  oct_flag() -> flags_t
	
	
	  Get number flag of the base, regardless of current processor - better
	  to use 'num_flag()'
	  

ida_bytes.off_flag():
	
	  off_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.op_adds_xrefs():
	
	  op_adds_xrefs(F, n) -> bool
	
	
	  Should processor module create xrefs from the operand?. Currently
	  'offset' and 'structure offset' operands create xrefs
	  
	  @param F (C++: flags_t)
	  @param n (C++: int)
	  

ida_bytes.op_bin():
	
	  op_bin(ea, n) -> bool
	
	
	  set op type to 'bin_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_chr():
	
	  op_chr(ea, n) -> bool
	
	
	  set op type to 'char_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_custfmt():
	
	  op_custfmt(ea, n, fid) -> bool
	
	
	  Set custom data format for operand (fid-custom data format id)
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  @param fid (C++: int)
	  

ida_bytes.op_dec():
	
	  op_dec(ea, n) -> bool
	
	
	  set op type to 'dec_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_enum():
	
	  op_enum(ea, n, id, serial) -> bool
	
	
	  Set operand representation to be 'enum_t'. If applied to unexplored
	  bytes, converts them to 16/32bit word data
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @param id: id of enum (C++: enum_t)
	  @param serial: the serial number of the constant in the enumeration,
	                 usually 0. the serial numbers are used if the
	                 enumeration contains several constants with the same
	                 value (C++: uchar)
	  @return: success
	  

ida_bytes.op_flt():
	
	  op_flt(ea, n) -> bool
	
	
	  set op type to 'flt_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_hex():
	
	  op_hex(ea, n) -> bool
	
	
	  set op type to 'hex_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_num():
	
	  op_num(ea, n) -> bool
	
	
	  set op type to 'num_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_oct():
	
	  op_oct(ea, n) -> bool
	
	
	  set op type to 'oct_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.op_seg():
	
	  op_seg(ea, n) -> bool
	
	
	  Set operand representation to be 'segment'. If applied to unexplored
	  bytes, converts them to 16/32bit word data
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: success
	  

ida_bytes.op_stkvar():
	
	  op_stkvar(ea, n) -> bool
	
	
	  Set operand representation to be 'stack variable'. Should be applied
	  to an instruction within a function. Should be applied after creating
	  a stack var using 'insn_t::create_stkvar()' .
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: success
	  

ida_bytes.op_stroff():
	
	  op_stroff(insn, n, path, path_len, delta) -> bool
	
	
	  Set operand representation to be 'struct offset'. If applied to
	  unexplored bytes, converts them to 16/32bit word data
	  
	  @param insn: the instruction (C++: const  insn_t  &)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @param path: structure path (strpath). see  nalt.hpp  for more info.
	               (C++: const  tid_t  *)
	  @param path_len: length of the structure path (C++: int)
	  @param delta: struct offset delta. usually 0. denotes the difference
	                between the structure base and the pointer into the
	                structure. (C++: adiff_t)
	  @return: success
	  
	  Example:
	  Python> 
	  Python> ins = ida_ua.insn_t()
	  Python> if ida_ua.decode_insn(ins, some_address):
	  Python>     path_len = 1
	  Python>     path = ida_pro.tid_array(path_len)
	  Python>     path[0] = ida_struct.get_struc_id("my_stucture_t")
	  Python>     ida_bytes.op_stroff(ins, 0, path.cast(), path_len, 0)
	  Python> 
	  

ida_bytes.oword_flag():
	
	  oword_flag() -> flags_t
	
	
	  Get a flags_t representing a octaword.
	  

ida_bytes.packreal_flag():
	
	  packreal_flag() -> flags_t
	
	
	  Get a flags_t representing a packed decimal real.
	  

ida_bytes.patch_byte():
	
	  patch_byte(ea, x) -> bool
	
	
	  Patch a byte of the program. The original value of the byte is saved
	  and can be obtained by 'get_original_byte()' . This function works for
	  wide byte processors too.
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

ida_bytes.patch_bytes():
	
	  patch_bytes(ea, buf)
	
	
	  Patch the specified number of bytes of the program. Original values of
	  bytes are saved and are available with get_original...() functions.
	  See also 'put_bytes()' .
	  
	  @param ea: linear address (C++: ea_t)
	  @param buf: buffer with new values of bytes (C++: const void *)
	  

ida_bytes.patch_dword():
	
	  patch_dword(ea, x) -> bool
	
	
	  Patch a dword of the program. The original value of the dword is saved
	  and can be obtained by 'get_original_dword()' . This function DOESN'T
	  work for wide byte processors. This function takes into account order
	  of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

ida_bytes.patch_qword():
	
	  patch_qword(ea, x) -> bool
	
	
	  Patch a qword of the program. The original value of the qword is saved
	  and can be obtained by 'get_original_qword()' . This function DOESN'T
	  work for wide byte processors. This function takes into account order
	  of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

ida_bytes.patch_word():
	
	  patch_word(ea, x) -> bool
	
	
	  Patch a word of the program. The original value of the word is saved
	  and can be obtained by 'get_original_word()' . This function works for
	  wide byte processors too. This function takes into account order of
	  bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

ida_bytes.prev_addr():
	
	  prev_addr(ea) -> ea_t
	
	
	  Get previous address in the program.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if no such address exist.
	  

ida_bytes.prev_chunk():
	
	  prev_chunk(ea) -> ea_t
	
	
	  Get the last address of previous contiguous chunk in the program.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if previous chunk doesn't exist.
	  

ida_bytes.prev_head():
	
	  prev_head(ea, minea) -> ea_t
	
	
	  Get start of previous defined item.
	  
	  @param ea: begin search at this address (C++: ea_t)
	  @param minea: included in the search range (C++: ea_t)
	  @return: BADADDR  if none exists.
	  

ida_bytes.prev_inited():
	
	  prev_inited(ea, minea) -> ea_t
	
	
	  Find the previous initialized address.
	  
	  
	  @param ea (C++: ea_t)
	  @param minea (C++: ea_t)
	  

ida_bytes.prev_not_tail():
	
	  prev_not_tail(ea) -> ea_t
	
	
	  Get address of previous non-tail byte.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if none exists.
	  

ida_bytes.prev_that():
	
	  prev_that(ea, minea, callable) -> ea_t
	
	
	  Find previous address with a flag satisfying the function 'testf'.do
	  not pass 'is_unknown()' to this function to find unexplored bytes It
	  will fail under the debugger. To find unexplored bytes, use
	  'prev_unknown()' .
	  
	  @param ea: start searching from this address - 1. (C++: ea_t)
	  @param minea: included in the search range. (C++: ea_t)
	  @return: the found address or  BADADDR .
	  

ida_bytes.prev_unknown():
	
	  prev_unknown(ea, minea) -> ea_t
	
	
	  Similar to 'prev_that()' , but will find the previous address that is
	  unexplored.
	  
	  
	  @param ea (C++: ea_t)
	  @param minea (C++: ea_t)
	  

ida_bytes.print_strlit_type():
	
	  print_strlit_type(strtype, flags=0) -> PyObject *
	
	
	  Get string type information: the string type name (possibly decorated
	  with hotkey markers), and the tooltip.
	  
	  @param strtype: the string type (C++: int32)
	  @param flags: or'ed PSTF_* constants (C++: int)
	  @return: length of generated text
	  

ida_bytes.put_byte():
	
	  put_byte(ea, x) -> bool
	
	
	  Set value of one byte of the program. This function modifies the
	  database. If the debugger is active then the debugged process memory
	  is patched too.The original value of the byte is completely lost and
	  can't be recovered by the 'get_original_byte()' function. See also
	  'put_dbg_byte()' to write to the process memory directly when the
	  debugger is active. This function can handle wide byte processors.
	  
	  @param ea: linear address (C++: ea_t)
	  @param x: byte value (C++: uint64)
	  @return: true if the database has been modified
	  

ida_bytes.put_bytes():
	
	  put_bytes(ea, buf)
	
	
	  Modify the specified number of bytes of the program. This function
	  does not save the original values of bytes. See also 'patch_bytes()' .
	  
	  @param ea: linear address (C++: ea_t)
	  @param buf: buffer with new values of bytes (C++: const void *)
	  

ida_bytes.put_dword():
	
	  put_dword(ea, x)
	
	
	  Set value of one dword of the program. This function takes into
	  account order of bytes specified in {is_be()} This function works for
	  wide byte processors too.the original value of the dword is completely
	  lost and can't be recovered by the 'get_original_dword()' function.
	  
	  @param ea: linear address (C++: ea_t)
	  @param x: dword value (C++: uint64)
	  

ida_bytes.put_qword():
	
	  put_qword(ea, x)
	
	
	  Set value of one qword (8 bytes) of the program. This function takes
	  into account order of bytes specified in {is_be()} This function
	  DOESN'T works for wide byte processors.
	  
	  @param ea: linear address (C++: ea_t)
	  @param x: qword value (C++: uint64)
	  

ida_bytes.put_word():
	
	  put_word(ea, x)
	
	
	  Set value of one word of the program. This function takes into account
	  order of bytes specified in {is_be()} This function works for wide
	  byte processors too.The original value of the word is completely lost
	  and can't be recovered by the 'get_original_word()' function. ea -
	  linear address x - word value
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

ida_bytes.qword_flag():
	
	  qword_flag() -> flags_t
	
	
	  Get a flags_t representing a quad word.
	  

ida_bytes.register_custom_data_format():
	
	  register_custom_data_format(py_df) -> int
	
	
	  Registers a custom data format with a given data type.
	  @param df: an instance of data_format_t
	  @return:
	      < 0 if failed to register
	      > 0 data format id
	  

ida_bytes.register_custom_data_type():
	
	  register_custom_data_type(py_dt) -> int
	
	
	  Registers a custom data type.
	  @param dt: an instance of the data_type_t class
	  @return:
	      < 0 if failed to register
	      > 0 data type id
	  

ida_bytes.register_data_types_and_formats():
	
	    Registers multiple data types and formats at once.
	    To register one type/format at a time use register_custom_data_type/register_custom_data_format
	
	    It employs a special table of types and formats described below:
	
	    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
	    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
	    many_formats = [
	      (pascal_data_type(), pascal_data_format()),
	      (simplevm_data_type(), simplevm_data_format()),
	      (makedword_data_format(),),
	      (simplevm_data_format(),)
	    ]
	    The first two tuples describe data types and their associated formats.
	    The last two tuples describe two data formats to be used with built-in data types.
	    The data format may be attached to several data types. The id of the
	    data format is stored in the first data_format_t object. For example:
	    assert many_formats[1][1] != -1
	    assert many_formats[2][0] != -1
	    assert many_formats[3][0] == -1
	    

ida_bytes.revert_byte():
	
	  revert_byte(ea) -> bool
	
	
	  Revert patched byte
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.seg_flag():
	
	  seg_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.set_cmt():
	
	  set_cmt(ea, comm, rptble) -> bool
	
	
	  Set an indented comment.
	  
	  @param ea: linear address (C++: ea_t)
	  @param comm: comment string   NULL: do nothing (return 0) "" : delete
	               comment (C++: const char *)
	  @param rptble: is repeatable? (C++: bool)
	  @return: success
	  

ida_bytes.set_forced_operand():
	
	  set_forced_operand(ea, n, op) -> bool
	
	
	  Set forced operand.
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, 2) (C++: int)
	  @param op: text of operand   NULL: do nothing (return 0) "" : delete
	             forced operand (C++: const char *)
	  @return: success
	  

ida_bytes.set_immd():
	
	  set_immd(ea) -> bool
	
	
	  Set 'has immediate operand' flag. Returns true if the 'FF_IMMD' bit
	  was not set and now is set
	  
	  @param ea (C++: ea_t)
	  

ida_bytes.set_lzero():
	
	  set_lzero(ea, n) -> bool
	
	
	  Set toggle lzero bit.
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.set_manual_insn():
	
	  set_manual_insn(ea, manual_insn)
	
	
	  Set manual instruction string.
	  
	  @param ea: linear address of the instruction or data item (C++: ea_t)
	  @param manual_insn: "" - delete manual string. NULL - do nothing (C++:
	                      const char *)
	  

ida_bytes.set_op_type():
	
	  set_op_type(ea, type, n) -> bool
	
	
	  (internal function) change representation of operand(s).
	  
	  @param ea: linear address (C++: ea_t)
	  @param type: new flag value (should be obtained from  char_flag() ,
	               num_flag()  and similar functions) (C++: flags_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  

ida_bytes.set_opinfo():
	
	  set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
	
	
	  Set additional information about an operand representation. This
	  function is a low level one. Only the kernel should use it.
	  
	  @param ea: linear address of the item (C++: ea_t)
	  @param n: number of operand, 0 or 1 (C++: int)
	  @param flag: flags of the item (C++: flags_t)
	  @param ti: additional representation information (C++: const  opinfo_t
	             *)
	  @param suppress_events: do not generate changing_op_type and
	                          op_type_changed events (C++: bool)
	  @return: success
	  

ida_bytes.stkvar_flag():
	
	  stkvar_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.strlit_flag():
	
	  strlit_flag() -> flags_t
	
	
	  Get a flags_t representing a string literal.
	  

ida_bytes.stroff_flag():
	
	  stroff_flag() -> flags_t
	
	
	  see 'Bits: instruction operand types'
	  

ida_bytes.stru_flag():
	
	  stru_flag() -> flags_t
	
	
	  Get a flags_t representing a struct.
	  

ida_bytes.tbyte_flag():
	
	  tbyte_flag() -> flags_t
	
	
	  Get a flags_t representing a tbyte.
	  

ida_bytes.toggle_bnot():
	
	  toggle_bnot(ea, n) -> bool
	
	
	  Toggle binary negation of operand. also see 'is_bnot()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.toggle_lzero():
	
	  toggle_lzero(ea, n) -> bool
	  

ida_bytes.toggle_sign():
	
	  toggle_sign(ea, n) -> bool
	
	
	  Toggle sign of n-th operand. allowed values of n: 0-first operand,
	  1-other operands
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

ida_bytes.unregister_custom_data_format():
	
	  unregister_custom_data_format(dfid) -> bool
	
	
	  Unregisters a custom data format
	  @param dfid: data format id
	  @return: Boolean
	  

ida_bytes.unregister_custom_data_type():
	
	  unregister_custom_data_type(dtid) -> bool
	
	
	  Unregisters a custom data type.
	  @param dtid: the data type id
	  @return: Boolean
	  

ida_bytes.unregister_data_types_and_formats():
	
	    As opposed to register_data_types_and_formats(), this function
	    unregisters multiple data types and formats at once.
	    

ida_bytes.update_hidden_range():
	
	  update_hidden_range(ha) -> bool
	
	
	  Update hidden range information in the database. You can not use this
	  function to change the range boundaries
	  
	  @param ha: range to update (C++: const  hidden_range_t  *)
	  @return: success
	  

ida_bytes.use_mapping():
	
	  use_mapping(ea) -> ea_t
	
	
	  Translate address according to current mappings.
	  
	  @param ea: address to translate (C++: ea_t)
	  @return: translated address
	  

ida_bytes.visit_patched_bytes():
	
	  visit_patched_bytes(ea1, ea2, py_callable) -> int
	
	
	  Enumerates patched bytes in the given range and invokes a callable
	  @param ea1: start address
	  @param ea2: end address
	  @param callable: a Python callable with the following prototype:
	                   callable(ea, fpos, org_val, patch_val).
	                   If the callable returns non-zero then that value will be
	                   returned to the caller and the enumeration will be
	                   interrupted.
	  @return: Zero if the enumeration was successful or the return
	           value of the callback if enumeration was interrupted.
	  

ida_bytes.word_flag():
	
	  word_flag() -> flags_t
	
	
	  Get a flags_t representing a word.
	  

ida_bytes.yword_flag():
	
	  yword_flag() -> flags_t
	
	
	  Get a flags_t representing a ymm word.
	  

ida_bytes.zword_flag():
	
	  zword_flag() -> flags_t
	
	
	  Get a flags_t representing a zmm word.
	  


=== ida_bytes EPYDOC INJECTIONS ===
ida_bytes.ALOPT_IGNCLT
"""
if set, don't stop at codepoints that are not part of the current
'culture'; accept all those that are graphical (this is typically used
used by user-initiated actions creating string literals.)
"""

ida_bytes.ALOPT_IGNHEADS
"""
don't stop if another data item is encountered. only the byte values
will be used to determine the string length. if not set, a defined
data item or instruction will truncate the string
"""

ida_bytes.ALOPT_IGNPRINT
"""
if set, don't stop at non-printable codepoints, but only at the
terminating character (or not unicode-mapped character (e.g., 0x8f in
CP1252))
"""

ida_bytes.ALOPT_MAX4K
"""
accumulated length

if string length is more than 4K, return the
"""

ida_bytes.BIN_SEARCH_BACKWARD
"""
search backward for bytes
"""

ida_bytes.BIN_SEARCH_CASE
"""
case sensitive
"""

ida_bytes.BIN_SEARCH_FORWARD
"""
search forward for bytes
"""

ida_bytes.BIN_SEARCH_INITED
"""
find_byte, find_byter: any initilized value
"""

ida_bytes.BIN_SEARCH_NOBREAK
"""
don't check for Ctrl-Break
"""

ida_bytes.BIN_SEARCH_NOCASE
"""
case insensitive
"""

ida_bytes.BIN_SEARCH_NOSHOW
"""
don't show search progress or update screen
"""

ida_bytes.DELIT_DELNAMES
"""
delete any names at the specified address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_EXPAND
"""
propagate undefined items; for example if removing an instruction
removes all references to the next instruction, then plan to convert
to unexplored the next instruction too.
"""

ida_bytes.DELIT_NOCMT
"""
reject to delete if a comment is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_NOTRUNC
"""
even if 'AF_TRFUNC' is set

don't truncate the current function
"""

ida_bytes.DELIT_NOUNAME
"""
reject to delete if a user name is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

ida_bytes.DELIT_SIMPLE
"""
simply undefine the specified item(s)
"""

ida_bytes.DTP_NODUP
"""
do not use dup construct
"""

ida_bytes.DT_TYPE
"""
Mask for DATA typing.
"""

ida_bytes.FF_0CHAR
"""
Char ('x')?
"""

ida_bytes.FF_0CUST
"""
Custom representation?
"""

ida_bytes.FF_0ENUM
"""
Enumeration?
"""

ida_bytes.FF_0FLT
"""
Floating point number?
"""

ida_bytes.FF_0FOP
"""
Forced operand?
"""

ida_bytes.FF_0NUMB
"""
Binary number?
"""

ida_bytes.FF_0NUMD
"""
Decimal number?
"""

ida_bytes.FF_0NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_0NUMO
"""
Octal number?
"""

ida_bytes.FF_0OFF
"""
Offset?
"""

ida_bytes.FF_0SEG
"""
Segment?
"""

ida_bytes.FF_0STK
"""
Stack variable?
"""

ida_bytes.FF_0STRO
"""
Struct offset?
"""

ida_bytes.FF_0VOID
"""
Void (unknown)?
"""

ida_bytes.FF_1CHAR
"""
Char ('x')?
"""

ida_bytes.FF_1CUST
"""
Custom representation?
"""

ida_bytes.FF_1ENUM
"""
Enumeration?
"""

ida_bytes.FF_1FLT
"""
Floating point number?
"""

ida_bytes.FF_1FOP
"""
Forced operand?
"""

ida_bytes.FF_1NUMB
"""
Binary number?
"""

ida_bytes.FF_1NUMD
"""
Decimal number?
"""

ida_bytes.FF_1NUMH
"""
Hexadecimal number?
"""

ida_bytes.FF_1NUMO
"""
Octal number?
"""

ida_bytes.FF_1OFF
"""
Offset?
"""

ida_bytes.FF_1SEG
"""
Segment?
"""

ida_bytes.FF_1STK
"""
Stack variable?
"""

ida_bytes.FF_1STRO
"""
Struct offset?
"""

ida_bytes.FF_1VOID
"""
Void (unknown)?
"""

ida_bytes.FF_ALIGN
"""
alignment directive
"""

ida_bytes.FF_BNOT
"""
Bitwise negation of operands.
"""

ida_bytes.FF_BYTE
"""
byte
"""

ida_bytes.FF_CODE
"""
Code ?
"""

ida_bytes.FF_COMM
"""
Has comment ?
"""

ida_bytes.FF_CUSTOM
"""
custom data type
"""

ida_bytes.FF_DATA
"""
Data ?
"""

ida_bytes.FF_DOUBLE
"""
double
"""

ida_bytes.FF_DWORD
"""
double word
"""

ida_bytes.FF_FLOAT
"""
float
"""

ida_bytes.FF_FLOW
"""
Exec flow from prev instruction.
"""

ida_bytes.FF_FUNC
"""
function start?
"""

ida_bytes.FF_IMMD
"""
Has Immediate value ?
"""

ida_bytes.FF_IVL
"""
Byte has value ?
"""

ida_bytes.FF_JUMP
"""
Has jump table or switch_info?
"""

ida_bytes.FF_LABL
"""
Has dummy name?
"""

ida_bytes.FF_LINE
"""
Has next or prev lines ?
"""

ida_bytes.FF_NAME
"""
Has name ?
"""

ida_bytes.FF_OWORD
"""
octaword/xmm word (16 bytes/128 bits)
"""

ida_bytes.FF_PACKREAL
"""
packed decimal real
"""

ida_bytes.FF_QWORD
"""
quadro word
"""

ida_bytes.FF_REF
"""
has references
"""

ida_bytes.FF_SIGN
"""
Inverted sign of operands.
"""

ida_bytes.FF_STRLIT
"""
string literal
"""

ida_bytes.FF_STRUCT
"""
struct variable
"""

ida_bytes.FF_TAIL
"""
Tail ?
"""

ida_bytes.FF_TBYTE
"""
tbyte
"""

ida_bytes.FF_UNK
"""
Unknown ?
"""

ida_bytes.FF_UNUSED
"""
unused bit (was used for variable bytes)
"""

ida_bytes.FF_WORD
"""
word
"""

ida_bytes.FF_YWORD
"""
ymm word (32 bytes/256 bits)
"""

ida_bytes.FF_ZWORD
"""
zmm word (64 bytes/512 bits)
"""

ida_bytes.GFE_VALUE
"""
get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.
"""

ida_bytes.GMB_READALL
"""
if this bit is not set, fail at first uninited byte

try to read all bytes
"""

ida_bytes.GMB_WAITBOX
"""
show wait box (may return -1 in this case)
"""

ida_bytes.ITEM_END_FIXUP
"""
stop at the first fixup
"""

ida_bytes.ITEM_END_INITED
"""
stop when initialization changes i.e.if is_loaded(ea): stop if
uninitialized byte is encounteredif !is_loaded(ea): stop if
initialized byte is encountered
"""

ida_bytes.ITEM_END_NAME
"""
stop at the first named location
"""

ida_bytes.ITEM_END_XREF
"""
stop at the first referenced location
"""

ida_bytes.MS_0TYPE
"""
Mask for 1st arg typing.
"""

ida_bytes.MS_1TYPE
"""
Mask for the type of other operands.
"""

ida_bytes.MS_CLS
"""
Mask for typing.
"""

ida_bytes.MS_CODE
"""
Mask for code bits.
"""

ida_bytes.MS_COMM
"""
Mask of common bits.
"""

ida_bytes.MS_VAL
"""
Mask for byte value.
"""

ida_bytes.OPND_ALL
"""
all operands
"""

ida_bytes.OPND_MASK
"""
mask for operand number
"""

ida_bytes.OPND_OUTER
"""
used only in set, get, del_offset() functions

outer offset base (combined with operand number).
"""

ida_bytes.PSTF_ENC
"""
if encoding is specified, append it
"""

ida_bytes.PSTF_HOTKEY
"""
have hotkey markers part of the name
"""

ida_bytes.PSTF_TBRIEF
"""
use brief name (e.g., in the 'Strings window')
"""

ida_bytes.PSTF_TINLIN
"""
use 'inline' name (e.g., in the structures comments)
"""

ida_bytes.PSTF_TMASK
"""
type mask
"""

ida_bytes.PSTF_TNORM
"""
use normal name
"""

ida_bytes.STRCONV_ESCAPE
"""
convert non-printable characters to C escapes (, , )
"""

ida_bytes.STRCONV_INCLLEN
"""
for Pascal-style strings, include the prefixing length byte(s) as
C-escaped sequence
"""

ida_bytes.STRCONV_REPLCHAR
"""
convert non-printable characters to the Unicode replacement character
(U+FFFD)
"""
=== ida_bytes EPYDOC INJECTIONS END ===
class ida_dbg.DBG_Hooks():
	
	    Proxy of C++ DBG_Hooks class
	    

ida_dbg.DBG_Hooks.dbg_bpt():
	
	        dbg_bpt(self, tid, bptea) -> int
	        

ida_dbg.DBG_Hooks.dbg_bpt_changed():
	
	        dbg_bpt_changed(self, bptev_code, bpt)
	        

ida_dbg.DBG_Hooks.dbg_exception():
	
	        dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
	        

ida_dbg.DBG_Hooks.dbg_information():
	
	        dbg_information(self, pid, tid, ea, info)
	        

ida_dbg.DBG_Hooks.dbg_library_load():
	
	        dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
	        

ida_dbg.DBG_Hooks.dbg_library_unload():
	
	        dbg_library_unload(self, pid, tid, ea, info)
	        

ida_dbg.DBG_Hooks.dbg_process_attach():
	
	        dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
	        

ida_dbg.DBG_Hooks.dbg_process_detach():
	
	        dbg_process_detach(self, pid, tid, ea)
	        

ida_dbg.DBG_Hooks.dbg_process_exit():
	
	        dbg_process_exit(self, pid, tid, ea, exit_code)
	        

ida_dbg.DBG_Hooks.dbg_process_start():
	
	        dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
	        

ida_dbg.DBG_Hooks.dbg_request_error():
	
	        dbg_request_error(self, failed_command, failed_dbg_notification)
	        

ida_dbg.DBG_Hooks.dbg_run_to():
	
	        dbg_run_to(self, pid, tid, ea)
	        

ida_dbg.DBG_Hooks.dbg_step_into():
	
	        dbg_step_into(self)
	        

ida_dbg.DBG_Hooks.dbg_step_over():
	
	        dbg_step_over(self)
	        

ida_dbg.DBG_Hooks.dbg_step_until_ret():
	
	        dbg_step_until_ret(self)
	        

ida_dbg.DBG_Hooks.dbg_suspend_process():
	
	        dbg_suspend_process(self)
	        

ida_dbg.DBG_Hooks.dbg_thread_exit():
	
	        dbg_thread_exit(self, pid, tid, ea, exit_code)
	        

ida_dbg.DBG_Hooks.dbg_thread_start():
	
	        dbg_thread_start(self, pid, tid, ea)
	        

ida_dbg.DBG_Hooks.dbg_trace():
	
	        dbg_trace(self, tid, ip) -> int
	        

ida_dbg.DBG_Hooks.hook():
	
	        hook(self) -> bool
	        

ida_dbg.DBG_Hooks.unhook():
	
	        unhook(self) -> bool
	        

ida_dbg.add_bpt():
	
	    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
	    add_bpt(bpt) -> bool
	
	
	  Add a new breakpoint in the debugged process. {Type, Synchronous
	  function - available as request, Notification, none (synchronous
	  function)}Only one breakpoint can exist at a given address.
	  
	  @param ea: any address in the process memory space. Depending on the
	             architecture, hardware breakpoints always be setup at
	             random address. For example, on x86, hardware breakpoints
	             should be aligned depending on their size. Moreover, on the
	             x86 architecture, it is impossible to setup more than 4
	             hardware breakpoints. (C++: ea_t)
	  @param size: size of the breakpoint (irrelevant for software
	               breakpoints): As for the address, hardware breakpoints
	               can't always be setup with random size. (C++: asize_t)
	  @param type: type of the breakpoint ( BPT_SOFT  for software
	               breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
	               BPT_EXEC ): try to add instruction breakpoint of the
	               appropriate type as follows: software bpt if supported,
	               hwbpt otherwise (C++: bpttype_t)
	    

ida_dbg.add_path_mapping():
	
	  add_path_mapping(src, dst)
	  

ida_dbg.add_virt_module():
	
	  add_virt_module(mod) -> bool
	  

ida_dbg.attach_process():
	
	  attach_process(pid=pid_t(-1), event_id=-1) -> int
	
	
	  Attach the debugger to a running process. {Type, Asynchronous function
	  - available as Request, Notification, 'dbg_process_attach' }This
	  function shouldn't be called as a request if 'NO_PROCESS' is used.
	  
	  @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
	              box will interactively ask the user for the process to
	              attach to. (C++: pid_t)
	  @param event_id (C++: int)
	  

class ida_dbg.bpt_location_t():
	
	    Proxy of C++ bpt_location_t class
	    

ida_dbg.bpt_location_t.compare():
	
	        compare(self, r) -> int
	        

ida_dbg.bpt_location_t.ea():
	
	        ea(self) -> ea_t
	        

ida_dbg.bpt_location_t.index:
	bpt_location_t_index_get(self) -> int

ida_dbg.bpt_location_t.info:
	bpt_location_t_info_get(self) -> ea_t

ida_dbg.bpt_location_t.is_empty_path():
	
	        is_empty_path(self) -> bool
	        

ida_dbg.bpt_location_t.lineno():
	
	        lineno(self) -> int
	        

ida_dbg.bpt_location_t.loctype:
	bpt_location_t_loctype_get(self) -> bpt_loctype_t

ida_dbg.bpt_location_t.offset():
	
	        offset(self) -> uval_t
	        

ida_dbg.bpt_location_t.path():
	
	        path(self) -> char const *
	        

ida_dbg.bpt_location_t.set_abs_bpt():
	
	        set_abs_bpt(self, a)
	        

ida_dbg.bpt_location_t.set_rel_bpt():
	
	        set_rel_bpt(self, mod, _offset)
	        

ida_dbg.bpt_location_t.set_src_bpt():
	
	        set_src_bpt(self, fn, _lineno)
	        

ida_dbg.bpt_location_t.set_sym_bpt():
	
	        set_sym_bpt(self, _symbol, _offset=0)
	        

ida_dbg.bpt_location_t.symbol():
	
	        symbol(self) -> char const *
	        

ida_dbg.bpt_location_t.type():
	
	        type(self) -> bpt_loctype_t
	        

class ida_dbg.bpt_t():
	
	    Proxy of C++ bpt_t class
	    

ida_dbg.bpt_t.badbpt():
	
	        badbpt(self) -> bool
	        

ida_dbg.bpt_t.cb:
	bpt_t_cb_get(self) -> size_t

ida_dbg.bpt_t.cndidx:
	bpt_t_cndidx_get(self) -> int

ida_dbg.bpt_t.condition:
	bpt_t_condition_get(self) -> PyObject *

ida_dbg.bpt_t.ea:
	bpt_t_ea_get(self) -> ea_t

ida_dbg.bpt_t.elang:
	bpt_t_elang_get(self) -> PyObject *

ida_dbg.bpt_t.enabled():
	
	        enabled(self) -> bool
	        

ida_dbg.bpt_t.flags:
	bpt_t_flags_get(self) -> uint32

ida_dbg.bpt_t.get_cnd_elang_idx():
	
	        get_cnd_elang_idx(self) -> size_t
	        

ida_dbg.bpt_t.get_size():
	
	        get_size(self) -> int
	        

ida_dbg.bpt_t.is_absbpt():
	
	        is_absbpt(self) -> bool
	        

ida_dbg.bpt_t.is_active():
	
	        is_active(self) -> bool
	        

ida_dbg.bpt_t.is_compiled():
	
	        is_compiled(self) -> bool
	        

ida_dbg.bpt_t.is_hwbpt():
	
	        is_hwbpt(self) -> bool
	        

ida_dbg.bpt_t.is_inactive():
	
	        is_inactive(self) -> bool
	        

ida_dbg.bpt_t.is_low_level():
	
	        is_low_level(self) -> bool
	        

ida_dbg.bpt_t.is_page_bpt():
	
	        is_page_bpt(self) -> bool
	        

ida_dbg.bpt_t.is_partially_active():
	
	        is_partially_active(self) -> bool
	        

ida_dbg.bpt_t.is_relbpt():
	
	        is_relbpt(self) -> bool
	        

ida_dbg.bpt_t.is_srcbpt():
	
	        is_srcbpt(self) -> bool
	        

ida_dbg.bpt_t.is_symbpt():
	
	        is_symbpt(self) -> bool
	        

ida_dbg.bpt_t.is_tracemodebpt():
	
	        is_tracemodebpt(self) -> bool
	        

ida_dbg.bpt_t.is_traceoffbpt():
	
	        is_traceoffbpt(self) -> bool
	        

ida_dbg.bpt_t.is_traceonbpt():
	
	        is_traceonbpt(self) -> bool
	        

ida_dbg.bpt_t.listbpt():
	
	        listbpt(self) -> bool
	        

ida_dbg.bpt_t.loc:
	bpt_t_loc_get(self) -> bpt_location_t

ida_dbg.bpt_t.pass_count:
	bpt_t_pass_count_get(self) -> int

ida_dbg.bpt_t.pid:
	bpt_t_pid_get(self) -> pid_t

ida_dbg.bpt_t.props:
	bpt_t_props_get(self) -> uint32

ida_dbg.bpt_t.set_abs_bpt():
	
	        set_abs_bpt(self, a)
	        

ida_dbg.bpt_t.set_rel_bpt():
	
	        set_rel_bpt(self, mod, o)
	        

ida_dbg.bpt_t.set_src_bpt():
	
	        set_src_bpt(self, fn, lineno)
	        

ida_dbg.bpt_t.set_sym_bpt():
	
	        set_sym_bpt(self, sym, o)
	        

ida_dbg.bpt_t.set_trace_action():
	
	        set_trace_action(self, enable, trace_types) -> bool
	        

ida_dbg.bpt_t.size:
	bpt_t_size_get(self) -> int

ida_dbg.bpt_t.tid:
	bpt_t_tid_get(self) -> thid_t

ida_dbg.bpt_t.type:
	bpt_t_type_get(self) -> bpttype_t

class ida_dbg.bpt_vec_t():
	
	    Proxy of C++ qvector<(bpt_t)> class
	    

ida_dbg.bpt_vec_t.at():
	
	        at(self, _idx) -> bpt_t
	        

ida_dbg.bpt_vec_t.begin():
	
	        begin(self) -> bpt_t
	        begin(self) -> bpt_t
	        

ida_dbg.bpt_vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_dbg.bpt_vec_t.clear():
	
	        clear(self)
	        

ida_dbg.bpt_vec_t.empty():
	
	        empty(self) -> bool
	        

ida_dbg.bpt_vec_t.end():
	
	        end(self) -> bpt_t
	        end(self) -> bpt_t
	        

ida_dbg.bpt_vec_t.erase():
	
	        erase(self, it) -> bpt_t
	        erase(self, first, last) -> bpt_t
	        

ida_dbg.bpt_vec_t.extract():
	
	        extract(self) -> bpt_t
	        

ida_dbg.bpt_vec_t.grow():
	
	        grow(self, x=bpt_t())
	        

ida_dbg.bpt_vec_t.inject():
	
	        inject(self, s, len)
	        

ida_dbg.bpt_vec_t.insert():
	
	        insert(self, it, x) -> bpt_t
	        

ida_dbg.bpt_vec_t.pop_back():
	
	        pop_back(self)
	        

ida_dbg.bpt_vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> bpt_t
	        

ida_dbg.bpt_vec_t.qclear():
	
	        qclear(self)
	        

ida_dbg.bpt_vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_dbg.bpt_vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_dbg.bpt_vec_t.size():
	
	        size(self) -> size_t
	        

ida_dbg.bpt_vec_t.swap():
	
	        swap(self, r)
	        

ida_dbg.bpt_vec_t.truncate():
	
	        truncate(self)
	        

ida_dbg.bring_debugger_to_front():
	
	  bring_debugger_to_front()
	  

ida_dbg.check_bpt():
	
	  check_bpt(ea) -> int
	
	
	  Check the breakpoint at the specified address.
	  
	  @param ea (C++: ea_t)
	  @return: one of  Breakpoint status codes
	  

ida_dbg.choose_trace_file():
	
	  choose_trace_file() -> bool
	
	
	  Show the choose trace dialog.
	  

ida_dbg.clear_requests_queue():
	
	  clear_requests_queue()
	
	
	  Clear the queue of waiting requests. {Type, Synchronous function,
	  Notification, none (synchronous function)}If a request is currently
	  running, this one isn't stopped.
	  

ida_dbg.clear_trace():
	
	  clear_trace()
	
	
	  Clear all events in the trace buffer. {Type, Synchronous function -
	  available as request, Notification, none (synchronous function)}
	  

ida_dbg.collect_stack_trace():
	
	  collect_stack_trace(tid, trace) -> bool
	  

ida_dbg.continue_process():
	
	  continue_process() -> bool
	
	
	  Continue the execution of the process in the debugger. {Type,
	  Synchronous function - available as Request, Notification, none
	  (synchronous function)}The 'continue_process()' function can be called
	  from a notification handler to force the continuation of the process.
	  In this case the request queue will not be examined, IDA will simply
	  resume execution. Usually it makes sense to call
	  'request_continue_process()' followed by 'run_requests()' , so that
	  IDA will first start a queued request (if any) and then resume the
	  application.
	  

ida_dbg.create_source_viewer():
	
	  create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *
	
	
	  Create a source code view.
	  
	  
	  @param out_ccv (C++: TWidget **)
	  @param parent (C++: TWidget *)
	  @param custview (C++: TWidget *)
	  @param sf (C++: source_file_ptr)
	  @param lines (C++: strvec_t  *)
	  @param lnnum (C++: int)
	  @param colnum (C++: int)
	  @param flags (C++: int)
	  

ida_dbg.dbg_add_bpt_tev():
	
	  dbg_add_bpt_tev(tid, ea, bp) -> bool
	
	
	  Add a new breakpoint trace element to the current trace. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param tid (C++: thid_t)
	  @param ea (C++: ea_t)
	  @param bp (C++: ea_t)
	  @return: false if the operation failed, true otherwise
	  

ida_dbg.dbg_add_call_tev():
	
	  dbg_add_call_tev(tid, caller, callee)
	
	
	  Add a new call trace element to the current trace. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param tid (C++: thid_t)
	  @param caller (C++: ea_t)
	  @param callee (C++: ea_t)
	  

ida_dbg.dbg_add_debug_event():
	
	  dbg_add_debug_event(event)
	
	
	  Add a new debug event to the current trace. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param event (C++: debug_event_t  *)
	  

ida_dbg.dbg_add_insn_tev():
	
	  dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool
	
	
	  Add a new instruction trace element to the current trace. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param tid (C++: thid_t)
	  @param ea (C++: ea_t)
	  @param save (C++: save_reg_values_t)
	  @return: false if the operation failed, true otherwise
	  

ida_dbg.dbg_add_many_tevs():
	
	  dbg_add_many_tevs(new_tevs) -> bool
	
	
	  Add many new trace elements to the current trace. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param new_tevs (C++: tevinforeg_vec_t  *)
	  @return: false if the operation failed for any  tev_info_t  object
	  

ida_dbg.dbg_add_ret_tev():
	
	  dbg_add_ret_tev(tid, ret_insn, return_to)
	
	
	  Add a new return trace element to the current trace. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param tid (C++: thid_t)
	  @param ret_insn (C++: ea_t)
	  @param return_to (C++: ea_t)
	  

ida_dbg.dbg_add_tev():
	
	  dbg_add_tev(type, tid, address)
	
	
	  Add a new trace element to the current trace. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param type (C++: tev_type_t)
	  @param tid (C++: thid_t)
	  @param address (C++: ea_t)
	  

ida_dbg.dbg_add_thread():
	
	  dbg_add_thread(tid)
	
	
	  Add a thread to the current trace. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param tid (C++: thid_t)
	  

ida_dbg.dbg_bin_search():
	
	  dbg_bin_search(start_ea, end_ea, data, srch_flags) -> drc_t
	  

ida_dbg.dbg_can_query():
	
	  dbg_can_query() -> bool
	
	
	  This function can be used to check if the debugger can be queried:
	    - debugger is loaded
	    - process is suspended
	    - process is not suspended but can take requests. In this case some requests like
	      memory read/write, bpt management succeed and register querying will fail.
	      Check if idaapi.get_process_state() < 0 to tell if the process is suspended
	  @return: Boolean
	  

ida_dbg.dbg_del_thread():
	
	  dbg_del_thread(tid)
	
	
	  Delete a thread from the current trace. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param tid (C++: thid_t)
	  

ida_dbg.dbg_is_loaded():
	
	  dbg_is_loaded() -> bool
	
	
	  Checks if a debugger is loaded
	  @return: Boolean
	  

ida_dbg.define_exception():
	
	  define_exception(code, name, desc, flags) -> char const *
	
	
	  Convenience function: define new exception code.
	  
	  @param code: exception code (can not be 0) (C++: uint)
	  @param name: exception name (can not be empty or NULL) (C++: const
	               char *)
	  @param desc: exception description (maybe NULL) (C++: const char *)
	  @param flags: combination of  Exception info flags (C++: int)
	  @return: failure message or NULL. You must call  store_exceptions()
	           if this function succeeds
	  

ida_dbg.del_bpt():
	
	    del_bpt(ea) -> bool
	    del_bpt(bptloc) -> bool
	
	
	  Delete an existing breakpoint in the debugged process. {Type,
	  Synchronous function - available as request, Notification, none
	  (synchronous function)}
	  
	  @param ea: any address in the breakpoint range (C++: ea_t)
	    

ida_dbg.del_bptgrp():
	
	  del_bptgrp(name) -> bool
	  

ida_dbg.del_virt_module():
	
	  del_virt_module(base) -> bool
	  

ida_dbg.detach_process():
	
	  detach_process() -> bool
	
	
	  Detach the debugger from the debugged process. {Type, Asynchronous
	  function - available as Request, Notification, 'dbg_process_detach' }
	  

ida_dbg.diff_trace_file():
	
	  diff_trace_file(nonnul_filename) -> bool
	
	
	  Show difference between the current trace and the one from 'filename'.
	  

ida_dbg.disable_bblk_trace():
	
	  disable_bblk_trace() -> bool
	  

ida_dbg.disable_bpt():
	
	    disable_bpt(ea) -> bool
	    disable_bpt(bptloc) -> bool
	    

ida_dbg.disable_func_trace():
	
	  disable_func_trace() -> bool
	  

ida_dbg.disable_insn_trace():
	
	  disable_insn_trace() -> bool
	  

ida_dbg.disable_step_trace():
	
	  disable_step_trace() -> bool
	  

ida_dbg.edit_manual_regions():
	
	  edit_manual_regions()
	  

ida_dbg.enable_bblk_trace():
	
	  enable_bblk_trace(enable=True) -> bool
	  

ida_dbg.enable_bpt():
	
	    enable_bpt(ea, enable=True) -> bool
	    enable_bpt(bptloc, enable=True) -> bool
	    

ida_dbg.enable_func_trace():
	
	  enable_func_trace(enable=True) -> bool
	  

ida_dbg.enable_insn_trace():
	
	  enable_insn_trace(enable=True) -> bool
	  

ida_dbg.enable_manual_regions():
	
	  enable_manual_regions(enable)
	  

ida_dbg.enable_step_trace():
	
	  enable_step_trace(enable=True) -> bool
	  

class ida_dbg.eval_ctx_t():
	
	    Proxy of C++ eval_ctx_t class
	    

ida_dbg.eval_ctx_t.ea:
	eval_ctx_t_ea_get(self) -> ea_t

ida_dbg.exist_bpt():
	
	  exist_bpt(ea) -> bool
	
	
	  Does a breakpoint exist at the given location?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_dbg.exit_process():
	
	  exit_process() -> bool
	
	
	  Terminate the debugging of the current process. {Type, Asynchronous
	  function - available as Request, Notification, 'dbg_process_exit' }
	  

ida_dbg.find_bpt():
	
	  find_bpt(bptloc, bpt) -> bool
	
	
	  Find a breakpoint by location. {Type, Synchronous function - available
	  as request, Notification, none (synchronous function)}
	  
	  @param bptloc: Breakpoint location (C++: const  bpt_location_t  &)
	  @param bpt: bpt is filled if the breakpoint was found (C++: bpt_t  *)
	  

ida_dbg.get_bblk_trace_options():
	
	  get_bblk_trace_options() -> int
	
	
	  Get current basic block tracing options. Also see 'BT_LOG_INSTS'
	  {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  

ida_dbg.get_bpt():
	
	  get_bpt(ea, bpt) -> bool
	
	
	  Get the characteristics of a breakpoint. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param ea: any address in the breakpoint range (C++: ea_t)
	  @param bpt: if not NULL, is filled with the characteristics. (C++:
	              bpt_t  *)
	  @return: false if no breakpoint exists
	  

ida_dbg.get_bpt_group():
	
	  get_bpt_group(bptloc) -> bool
	  

ida_dbg.get_bpt_qty():
	
	  get_bpt_qty() -> int
	
	
	  Get number of breakpoints. {Type, Synchronous function, Notification,
	  none (synchronous function)}
	  

ida_dbg.get_bpt_tev_ea():
	
	  get_bpt_tev_ea(n) -> ea_t
	
	
	  Get the address associated to a read, read/write or execution trace
	  event. {Type, Synchronous function, Notification, none (synchronous
	  function)}Usually, a breakpoint is associated with a read, read/write
	  or execution trace event. However, the returned address could be any
	  address in the range of this breakpoint. If the breakpoint was deleted
	  after the trace event, the address no longer corresponds to a valid
	  breakpoint.
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @return: BADADDR  if not a read, read/write or execution trace event.
	  

ida_dbg.get_bptloc_string():
	
	  get_bptloc_string(i) -> char const *
	
	
	  Helper function for 'bpt_location_t' .
	  
	  
	  @param i (C++: int)
	  

ida_dbg.get_call_tev_callee():
	
	  get_call_tev_callee(n) -> ea_t
	
	
	  Get the called function from a function call trace event. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @return: BADADDR  if not a function call event.
	  

ida_dbg.get_current_source_file():
	
	  get_current_source_file(path) -> bool
	  

ida_dbg.get_current_source_line():
	
	  get_current_source_line() -> int
	  

ida_dbg.get_current_thread():
	
	  get_current_thread() -> thid_t
	
	
	  Get current thread ID. {Type, Synchronous function, Notification, none
	  (synchronous function)}
	  

ida_dbg.get_dbg_byte():
	
	  get_dbg_byte(x, ea) -> bool
	
	
	  Get one byte of the debugged process memory.
	  
	  @param x: pointer to byte value (C++: uint32  *)
	  @param ea: linear address (C++: ea_t)
	  @return: true success
	  

ida_dbg.get_dbg_memory_info():
	
	  get_dbg_memory_info(ranges) -> int
	  

ida_dbg.get_dbg_reg_info():
	
	  get_dbg_reg_info(regname, ri) -> bool
	
	
	  Get register information {Type, Synchronous function, Notification,
	  none (synchronous function)}
	  
	  @param regname (C++: const char *)
	  @param ri (C++: register_info_t  *)
	  

ida_dbg.get_debug_event():
	
	  get_debug_event() -> debug_event_t
	
	
	  Get the current debugger event.
	  

ida_dbg.get_debugger_event_cond():
	
	  get_debugger_event_cond() -> char const *
	  

ida_dbg.get_first_module():
	
	  get_first_module(modinfo) -> bool
	  

ida_dbg.get_func_trace_options():
	
	  get_func_trace_options() -> int
	
	
	  Get current function tracing options. Also see 'FT_LOG_RET' {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  

ida_dbg.get_global_var():
	
	  get_global_var(prov, ea, name, out) -> bool
	  

ida_dbg.get_grp_bpts():
	
	  get_grp_bpts(bpts, grp_name) -> ssize_t
	  

ida_dbg.get_insn_tev_reg_mem():
	
	  get_insn_tev_reg_mem(n, memmap) -> bool
	
	
	  Read the memory pointed by register values from an instruction trace
	  event. {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @param memmap: result (C++: memreg_infos_t  *)
	  @return: false if not an instruction event or no memory is available
	  

ida_dbg.get_insn_tev_reg_result():
	
	  get_insn_tev_reg_result(n, regname, regval) -> bool
	
	
	  Read the resulting register value from an instruction trace event.
	  {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @param regname: name of desired register (C++: const char *)
	  @param regval: result (C++: regval_t  *)
	  @return: false if not an instruction trace event or register wasn't
	           modified.
	  

ida_dbg.get_insn_tev_reg_val():
	
	  get_insn_tev_reg_val(n, regname, regval) -> bool
	
	
	  Read a register value from an instruction trace event. {Type,
	  Synchronous function, Notification, none (synchronous function)}This
	  is the value of the register before the execution of the instruction.
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @param regname: name of desired register (C++: const char *)
	  @param regval: result (C++: regval_t  *)
	  @return: false if not an instruction event.
	  

ida_dbg.get_insn_trace_options():
	
	  get_insn_trace_options() -> int
	
	
	  Get current instruction tracing options. Also see 'IT_LOG_SAME_IP'
	  {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  

ida_dbg.get_ip_val():
	
	  get_ip_val() -> bool
	
	
	  Get value of the IP (program counter) register for the current thread.
	  Requires a suspended debugger.
	  

ida_dbg.get_local_var():
	
	  get_local_var(prov, ea, name, out) -> bool
	  

ida_dbg.get_local_vars():
	
	  get_local_vars(prov, ea, out) -> bool
	  

ida_dbg.get_manual_regions():
	
	    get_manual_regions(ranges)
	    get_manual_regions() -> PyObject *
	
	
	  Returns the manual memory regions
	  @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)
	    

ida_dbg.get_module_info():
	
	  get_module_info(ea, modinfo) -> bool
	  

ida_dbg.get_next_module():
	
	  get_next_module(modinfo) -> bool
	  

ida_dbg.get_process_options():
	
	  get_process_options(path, args, sdir, host, _pass, port)
	
	
	  Get process options. Any of the arguments may be NULL
	  
	  @param path (C++: qstring  *)
	  @param args (C++: qstring  *)
	  @param sdir (C++: qstring  *)
	  @param host (C++: qstring  *)
	  @param port (C++: int *)
	  

ida_dbg.get_process_state():
	
	  get_process_state() -> int
	
	
	  Return the state of the currently debugged process. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @return: one of  Debugged process states
	  

ida_dbg.get_processes():
	
	  get_processes(proclist) -> ssize_t
	
	
	  Take a snapshot of running processes and return their description.
	  {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  
	  @param proclist (C++: procinfo_vec_t  *)
	  @return: number of processes or -1 on error
	  

ida_dbg.get_reg_val():
	
	    get_reg_val(regname, regval) -> bool
	    get_reg_val(regname, ival) -> bool
	
	
	  Read a register value from the current thread. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param regname (C++: const char *)
	  @param regval (C++: regval_t  *)
	    

ida_dbg.get_reg_vals():
	
	  get_reg_vals(tid, clsmask, values) -> int
	  

ida_dbg.get_ret_tev_return():
	
	  get_ret_tev_return(n) -> ea_t
	
	
	  Get the return address from a function return trace event. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @return: BADADDR  if not a function return event.
	  

ida_dbg.get_running_notification():
	
	  get_running_notification() -> dbg_notification_t
	
	
	  Get the notification associated (if any) with the current running
	  request. {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  
	  @return: dbg_null if no running request
	  

ida_dbg.get_running_request():
	
	  get_running_request() -> ui_notification_t
	
	
	  Get the current running request. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @return: ui_null if no running request
	  

ida_dbg.get_sp_val():
	
	  get_sp_val() -> bool
	
	
	  Get value of the SP register for the current thread. Requires a
	  suspended debugger.
	  

ida_dbg.get_srcinfo_provider():
	
	  get_srcinfo_provider(name) -> srcinfo_provider_t *
	  

ida_dbg.get_step_trace_options():
	
	  get_step_trace_options() -> int
	
	
	  Get current step tracing options. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @return: Step trace options
	  

ida_dbg.get_tev_ea():
	
	  get_tev_ea(n) -> ea_t
	  

ida_dbg.get_tev_event():
	
	  get_tev_event(n, d) -> bool
	
	
	  Get the corresponding debug event, if any, for the specified tev
	  object. {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @param d: result (C++: debug_event_t  *)
	  @return: false if the tev_t object doesn't have any associated debug
	           event, true otherwise, with the debug event in "d".
	  

ida_dbg.get_tev_info():
	
	  get_tev_info(n, tev_info) -> bool
	
	
	  Get main information about a trace event. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @param tev_info: result (C++: tev_info_t  *)
	  @return: success
	  

ida_dbg.get_tev_memory_info():
	
	  get_tev_memory_info(n, mi) -> bool
	
	
	  Get the memory layout, if any, for the specified tev object. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @param mi: result (C++: meminfo_vec_t  *)
	  @return: false if the tev_t object is not of type  tev_mem , true
	           otherwise, with the new memory layout in "mi".
	  

ida_dbg.get_tev_qty():
	
	  get_tev_qty() -> int
	
	
	  Get number of trace events available in trace buffer. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  

ida_dbg.get_tev_tid():
	
	  get_tev_tid(n) -> int
	  

ida_dbg.get_tev_type():
	
	  get_tev_type(n) -> int
	  

ida_dbg.get_thread_qty():
	
	  get_thread_qty() -> int
	
	
	  Get number of threads. {Type, Synchronous function, Notification, none
	  (synchronous function)}
	  

ida_dbg.get_trace_base_address():
	
	  get_trace_base_address() -> ea_t
	
	
	  Get the base address of the current trace. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @return: the base address of the currently loaded trace
	  

ida_dbg.get_trace_file_desc():
	
	  get_trace_file_desc(filename) -> bool
	
	
	  Get the file header of the specified trace file.
	  
	  
	  @param filename (C++: const char *)
	  

ida_dbg.get_trace_platform():
	
	  get_trace_platform() -> char const *
	
	
	  Get platform name of current trace.
	  

ida_dbg.getn_bpt():
	
	  getn_bpt(n, bpt) -> bool
	
	
	  Get the characteristics of a breakpoint. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param n: number of breakpoint, is in range 0.. get_bpt_qty() -1 (C++:
	            int)
	  @param bpt: filled with the characteristics. (C++: bpt_t  *)
	  @return: false if no breakpoint exists
	  

ida_dbg.getn_thread():
	
	  getn_thread(n) -> thid_t
	
	
	  Get the ID of a thread. {Type, Synchronous function, Notification,
	  none (synchronous function)}
	  
	  @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
	            int)
	  @return: NO_THREAD  if the thread doesn't exist.
	  

ida_dbg.getn_thread_name():
	
	  getn_thread_name(n) -> char const *
	
	
	  Get the NAME of a thread {Type, Synchronous function, Notification,
	  none (synchronous function)}
	  
	  @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
	            for the current thread (C++: int)
	  @return: thread name or NULL if the thread doesn't exist.
	  

ida_dbg.graph_trace():
	
	  graph_trace() -> bool
	
	
	  Show the trace callgraph.
	  

ida_dbg.handle_debug_event():
	
	  handle_debug_event(ev, rqflags) -> int
	  

ida_dbg.hide_all_bpts():
	
	  hide_all_bpts() -> int
	  

ida_dbg.internal_get_sreg_base():
	
	  internal_get_sreg_base(tid, sreg_value) -> ea_t
	
	
	  Get the sreg base, for the given thread.
	  
	  @return: The sreg base, or BADADDR on failure.
	  

ida_dbg.internal_ioctl():
	
	  internal_ioctl(fn, buf, poutbuf, poutsize) -> int
	  

ida_dbg.invalidate_dbg_state():
	
	  invalidate_dbg_state(dbginv) -> int
	
	
	  Invalidate cached debugger information. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param dbginv: Debugged process invalidation options (C++: int)
	  @return: current debugger state (one of  Debugged process states )
	  

ida_dbg.invalidate_dbgmem_config():
	
	  invalidate_dbgmem_config()
	
	
	  Invalidate the debugged process memory configuration. Call this
	  function if the debugged process might have changed its memory layout
	  (allocated more memory, for example)
	  

ida_dbg.invalidate_dbgmem_contents():
	
	  invalidate_dbgmem_contents(ea, size)
	
	
	  Invalidate the debugged process memory contents. Call this function
	  each time the process has been stopped or the process memory is
	  modified. If ea == 'BADADDR' , then the whole memory contents will be
	  invalidated
	  
	  @param ea (C++: ea_t)
	  @param size (C++: asize_t)
	  

ida_dbg.is_bblk_trace_enabled():
	
	  is_bblk_trace_enabled() -> bool
	  

ida_dbg.is_debugger_busy():
	
	  is_debugger_busy() -> bool
	
	
	  Is the debugger busy?. Some debuggers do not accept any commands while
	  the debugged application is running. For such a debugger, it is unsafe
	  to do anything with the database (even simple queries like get_byte
	  may lead to undesired consequences). Returns: true if the debugged
	  application is running under such a debugger
	  

ida_dbg.is_debugger_memory():
	
	  is_debugger_memory(ea) -> bool
	
	
	  Is the address mapped to debugger memory?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_dbg.is_debugger_on():
	
	  is_debugger_on() -> bool
	
	
	  Is the debugger currently running?
	  

ida_dbg.is_func_trace_enabled():
	
	  is_func_trace_enabled() -> bool
	
	
	  Get current state of functions tracing. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  

ida_dbg.is_insn_trace_enabled():
	
	  is_insn_trace_enabled() -> bool
	
	
	  Get current state of instructions tracing. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  

ida_dbg.is_reg_custom():
	
	  is_reg_custom(regname) -> bool
	
	
	  Does a register contain a value of a custom data type? {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param regname (C++: const char *)
	  

ida_dbg.is_reg_float():
	
	  is_reg_float(regname) -> bool
	
	
	  Does a register contain a floating point value? {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param regname (C++: const char *)
	  

ida_dbg.is_reg_integer():
	
	  is_reg_integer(regname) -> bool
	
	
	  Does a register contain an integer value? {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param regname (C++: const char *)
	  

ida_dbg.is_request_running():
	
	  is_request_running() -> bool
	
	
	  Is a request currently running?
	  

ida_dbg.is_step_trace_enabled():
	
	  is_step_trace_enabled() -> bool
	
	
	  Get current state of step tracing. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  

ida_dbg.is_valid_trace_file():
	
	  is_valid_trace_file(filename) -> bool
	
	
	  Is the specified file a valid trace file for the current database?
	  
	  
	  @param filename (C++: const char *)
	  

ida_dbg.list_bptgrps():
	
	    list_bptgrps(bptgrps) -> size_t
	    list_bptgrps() -> PyObject *
	    

ida_dbg.load_debugger():
	
	  load_debugger(dbgname, use_remote) -> bool
	  

ida_dbg.load_trace_file():
	
	  load_trace_file(filename) -> bool
	
	
	  Load a recorded trace file in the trace window. If the call succeeds
	  and 'buf' is not null, the description of the trace stored in the
	  binary trace file will be returned in 'buf'
	  
	  @param filename (C++: const char *)
	  

class ida_dbg.memreg_info_t():
	
	    Proxy of C++ memreg_info_t class
	    

ida_dbg.memreg_info_t.bytes:
	
	        get_bytes(self) -> PyObject *
	        

ida_dbg.memreg_info_t.ea:
	memreg_info_t_ea_get(self) -> ea_t

ida_dbg.memreg_info_t.get_bytes():
	
	        get_bytes(self) -> PyObject *
	        

class ida_dbg.memreg_infos_t():
	
	    Proxy of C++ qvector<(memreg_info_t)> class
	    

ida_dbg.memreg_infos_t.at():
	
	        at(self, _idx) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.begin():
	
	        begin(self) -> memreg_info_t
	        begin(self) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_dbg.memreg_infos_t.clear():
	
	        clear(self)
	        

ida_dbg.memreg_infos_t.empty():
	
	        empty(self) -> bool
	        

ida_dbg.memreg_infos_t.end():
	
	        end(self) -> memreg_info_t
	        end(self) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.erase():
	
	        erase(self, it) -> memreg_info_t
	        erase(self, first, last) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.extract():
	
	        extract(self) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.grow():
	
	        grow(self, x=memreg_info_t())
	        

ida_dbg.memreg_infos_t.inject():
	
	        inject(self, s, len)
	        

ida_dbg.memreg_infos_t.insert():
	
	        insert(self, it, x) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.pop_back():
	
	        pop_back(self)
	        

ida_dbg.memreg_infos_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> memreg_info_t
	        

ida_dbg.memreg_infos_t.qclear():
	
	        qclear(self)
	        

ida_dbg.memreg_infos_t.reserve():
	
	        reserve(self, cnt)
	        

ida_dbg.memreg_infos_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_dbg.memreg_infos_t.size():
	
	        size(self) -> size_t
	        

ida_dbg.memreg_infos_t.swap():
	
	        swap(self, r)
	        

ida_dbg.memreg_infos_t.truncate():
	
	        truncate(self)
	        

ida_dbg.move_bpt_to_grp():
	
	  move_bpt_to_grp(bpt, grp_name)
	
	
	  Sets new group for the breakpoint
	  

ida_dbg.put_dbg_byte():
	
	  put_dbg_byte(ea, x) -> bool
	
	
	  Change one byte of the debugged process memory.
	  
	  @param ea: linear address (C++: ea_t)
	  @param x: byte value (C++: uint32)
	  @return: true if the process memory has been modified
	  

ida_dbg.read_dbg_memory():
	
	  read_dbg_memory(ea, buffer, size) -> ssize_t
	  

ida_dbg.refresh_debugger_memory():
	
	  refresh_debugger_memory() -> PyObject *
	
	
	  Refreshes the debugger memory
	  @return: Nothing
	  

ida_dbg.rename_bptgrp():
	
	  rename_bptgrp(old_name, new_name) -> bool
	  

ida_dbg.request_add_bpt():
	
	    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
	    request_add_bpt(bpt) -> bool
	
	
	  Post an 'add_bpt(ea_t, asize_t, bpttype_t)' request.
	  
	  
	  @param ea (C++: ea_t)
	  @param size (C++: asize_t)
	  @param type (C++: bpttype_t)
	    

ida_dbg.request_attach_process():
	
	  request_attach_process(pid, event_id) -> int
	
	
	  Post an 'attach_process()' request.
	  
	  
	  @param pid (C++: pid_t)
	  @param event_id (C++: int)
	  

ida_dbg.request_clear_trace():
	
	  request_clear_trace()
	
	
	  Post a 'clear_trace()' request.
	  

ida_dbg.request_continue_process():
	
	  request_continue_process() -> bool
	
	
	  Post a 'continue_process()' request.This requires an explicit call to
	  'run_requests()'
	  

ida_dbg.request_del_bpt():
	
	    request_del_bpt(ea) -> bool
	    request_del_bpt(bptloc) -> bool
	
	
	  Post a 'del_bpt(ea_t)' request.
	  
	  
	  @param ea (C++: ea_t)
	    

ida_dbg.request_detach_process():
	
	  request_detach_process() -> bool
	
	
	  Post a 'detach_process()' request.
	  

ida_dbg.request_disable_bblk_trace():
	
	  request_disable_bblk_trace() -> bool
	  

ida_dbg.request_disable_bpt():
	
	    request_disable_bpt(ea) -> bool
	    request_disable_bpt(bptloc) -> bool
	    

ida_dbg.request_disable_func_trace():
	
	  request_disable_func_trace() -> bool
	  

ida_dbg.request_disable_insn_trace():
	
	  request_disable_insn_trace() -> bool
	  

ida_dbg.request_disable_step_trace():
	
	  request_disable_step_trace() -> bool
	  

ida_dbg.request_enable_bblk_trace():
	
	  request_enable_bblk_trace(enable=True) -> bool
	  

ida_dbg.request_enable_bpt():
	
	    request_enable_bpt(ea, enable=True) -> bool
	    request_enable_bpt(bptloc, enable=True) -> bool
	    

ida_dbg.request_enable_func_trace():
	
	  request_enable_func_trace(enable=True) -> bool
	  

ida_dbg.request_enable_insn_trace():
	
	  request_enable_insn_trace(enable=True) -> bool
	  

ida_dbg.request_enable_step_trace():
	
	  request_enable_step_trace(enable=True) -> bool
	  

ida_dbg.request_exit_process():
	
	  request_exit_process() -> bool
	
	
	  Post an 'exit_process()' request.
	  

ida_dbg.request_resume_thread():
	
	  request_resume_thread(tid) -> int
	
	
	  Post a 'resume_thread()' request.
	  
	  
	  @param tid (C++: thid_t)
	  

ida_dbg.request_run_to():
	
	  request_run_to(ea, pid=pid_t(-1), tid=0) -> bool
	
	
	  Post a 'run_to()' request.
	  
	  
	  @param ea (C++: ea_t)
	  @param pid (C++: pid_t)
	  @param tid (C++: thid_t)
	  

ida_dbg.request_select_thread():
	
	  request_select_thread(tid) -> bool
	
	
	  Post a 'select_thread()' request.
	  
	  
	  @param tid (C++: thid_t)
	  

ida_dbg.request_set_bblk_trace_options():
	
	  request_set_bblk_trace_options(options)
	
	
	  Post a 'set_bblk_trace_options()' request.
	  
	  
	  @param options (C++: int)
	  

ida_dbg.request_set_func_trace_options():
	
	  request_set_func_trace_options(options)
	
	
	  Post a 'set_func_trace_options()' request.
	  
	  
	  @param options (C++: int)
	  

ida_dbg.request_set_insn_trace_options():
	
	  request_set_insn_trace_options(options)
	
	
	  Post a 'set_insn_trace_options()' request.
	  
	  
	  @param options (C++: int)
	  

ida_dbg.request_set_reg_val():
	
	  request_set_reg_val(regname, regval) -> bool
	
	
	  Post a 'set_reg_val()' request.
	  
	  
	  @param regname (C++: const char *)
	  @param regval (C++: const  regval_t  *)
	  

ida_dbg.request_set_resume_mode():
	
	  request_set_resume_mode(tid, mode) -> bool
	
	
	  Post a 'set_resume_mode()' request.
	  
	  
	  @param tid (C++: thid_t)
	  @param mode (C++: resume_mode_t)
	  

ida_dbg.request_set_step_trace_options():
	
	  request_set_step_trace_options(options)
	
	
	  Post a 'set_step_trace_options()' request.
	  
	  
	  @param options (C++: int)
	  

ida_dbg.request_start_process():
	
	  request_start_process(path=None, args=None, sdir=None) -> int
	
	
	  Post a 'start_process()' request.
	  
	  
	  @param path (C++: const char *)
	  @param args (C++: const char *)
	  @param sdir (C++: const char *)
	  

ida_dbg.request_step_into():
	
	  request_step_into() -> bool
	
	
	  Post a 'step_into()' request.
	  

ida_dbg.request_step_over():
	
	  request_step_over() -> bool
	
	
	  Post a 'step_over()' request.
	  

ida_dbg.request_step_until_ret():
	
	  request_step_until_ret() -> bool
	
	
	  Post a 'step_until_ret()' request.
	  

ida_dbg.request_suspend_process():
	
	  request_suspend_process() -> bool
	
	
	  Post a 'suspend_process()' request.
	  

ida_dbg.request_suspend_thread():
	
	  request_suspend_thread(tid) -> int
	
	
	  Post a 'suspend_thread()' request.
	  
	  
	  @param tid (C++: thid_t)
	  

ida_dbg.resume_thread():
	
	  resume_thread(tid) -> int
	
	
	  Resume thread. {Type, Synchronous function - available as request,
	  Notification, none (synchronous function)}
	  
	  @param tid: thread id (C++: thid_t)
	  

ida_dbg.retrieve_exceptions():
	
	  retrieve_exceptions() -> excvec_t
	
	
	  Retrieve the exception information. You may freely modify the returned
	  vector and add/edit/delete exceptions You must call
	  'store_exceptions()' after any modifications Note: exceptions with
	  code zero, multiple exception codes or names are prohibited
	  

ida_dbg.run_requests():
	
	  run_requests() -> bool
	
	
	  Execute requests until all requests are processed or an asynchronous
	  function is called. {Type, Synchronous function, Notification, none
	  (synchronous function)}If called from a notification handler, the
	  execution of requests will be postponed to the end of the execution of
	  all notification handlers.
	  
	  @return: false if not all requests could be processed (indicates an
	           asynchronous function was started)
	  

ida_dbg.run_to():
	
	  run_to(ea, pid=pid_t(-1), tid=0) -> bool
	
	
	  Execute the process until the given address is reached. If no process
	  is active, a new process is started. Technically, the debugger sets up
	  a temporary breakpoint at the given address, and continues (or starts)
	  the execution of the whole process. So, all threads continue their
	  execution! {Type, Asynchronous function - available as Request,
	  Notification, 'dbg_run_to' }
	  
	  @param ea: target address (C++: ea_t)
	  @param pid: not used yet. please do not specify this parameter. (C++:
	              pid_t)
	  @param tid: not used yet. please do not specify this parameter. (C++:
	              thid_t)
	  

ida_dbg.save_trace_file():
	
	  save_trace_file(filename, description) -> bool
	
	
	  Save the current trace in the specified file.
	  
	  
	  @param filename (C++: const char *)
	  @param description (C++: const char *)
	  

ida_dbg.select_thread():
	
	  select_thread(tid) -> bool
	
	
	  Select the given thread as the current debugged thread. All thread
	  related execution functions will work on this thread. The process must
	  be suspended to select a new thread. {Type, Synchronous function -
	  available as request, Notification, none (synchronous function)}
	  
	  @param tid: ID of the thread to select (C++: thid_t)
	  @return: false if the thread doesn't exist.
	  

ida_dbg.send_dbg_command():
	
	    Send a direct command to the debugger backend, and
	    retrieve the result as a string.
	
	    Note: any double-quotes in 'command' must be backslash-escaped.
	    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
	
	    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure
	    

ida_dbg.set_bblk_trace_options():
	
	  set_bblk_trace_options(options)
	
	
	  Modify basic block tracing options (see 'BT_LOG_INSTS' )
	  
	  
	  @param options (C++: int)
	  

ida_dbg.set_bpt_group():
	
	  set_bpt_group(bpt, grp_name)
	  

ida_dbg.set_bptloc_group():
	
	  set_bptloc_group(bptloc, grp_name) -> bool
	  

ida_dbg.set_bptloc_string():
	
	  set_bptloc_string(s) -> int
	
	
	  Helper function for 'bpt_location_t' .
	  
	  
	  @param s (C++: const char *)
	  

ida_dbg.set_debugger_event_cond():
	
	  set_debugger_event_cond(nonnul_cond)
	  

ida_dbg.set_debugger_options():
	
	  set_debugger_options(options) -> uint
	
	
	  Set debugger options. Replaces debugger options with the specification
	  combination 'Debugger options'
	  
	  @param options (C++: uint)
	  @return: the old debugger options
	  

ida_dbg.set_func_trace_options():
	
	  set_func_trace_options(options)
	
	
	  Modify function tracing options. {Type, Synchronous function -
	  available as request, Notification, none (synchronous function)}
	  
	  @param options (C++: int)
	  

ida_dbg.set_highlight_trace_options():
	
	  set_highlight_trace_options(hilight, color, diff)
	
	
	  Set highlight trace parameters.
	  
	  
	  @param hilight (C++: bool)
	  @param color (C++: bgcolor_t)
	  @param diff (C++: bgcolor_t)
	  

ida_dbg.set_insn_trace_options():
	
	  set_insn_trace_options(options)
	
	
	  Modify instruction tracing options. {Type, Synchronous function -
	  available as request, Notification, none (synchronous function)}
	  
	  @param options (C++: int)
	  

ida_dbg.set_manual_regions():
	
	  set_manual_regions(ranges)
	  

ida_dbg.set_process_options():
	
	  set_process_options(path, args, sdir, host, _pass, port)
	
	
	  Set process options. Any of the arguments may be NULL, which means 'do
	  not modify'
	  
	  @param path (C++: const char *)
	  @param args (C++: const char *)
	  @param sdir (C++: const char *)
	  @param host (C++: const char *)
	  @param port (C++: int)
	  

ida_dbg.set_process_state():
	
	  set_process_state(newstate, p_thid, dbginv) -> int
	
	
	  Set new state for the debugged process. Notifies the IDA kernel about
	  the change of the debugged process state. For example, a debugger
	  module could call this function when it knows that the process is
	  suspended for a short period of time. Some IDA API calls can be made
	  only when the process is suspended. The process state is usually
	  restored before returning control to the caller. You must know that it
	  is ok to change the process state, doing it at arbitrary moments may
	  crash the application or IDA. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @param newstate: new process state (one of  Debugged process states )
	                   if  DSTATE_NOTASK  is passed then the state is not
	                   changed (C++: int)
	  @param p_thid: ptr to new thread id. may be NULL or pointer to
	                 NO_THREAD . the pointed variable will contain the old
	                 thread id upon return (C++: thid_t  *)
	  @param dbginv: Debugged process invalidation options (C++: int)
	  @return: old debugger state (one of  Debugged process states )
	  

ida_dbg.set_reg_val():
	
	    set_reg_val(regname, regval) -> bool
	    set_reg_val(regname, ival) -> bool
	    set_reg_val(tid, regidx, value) -> int
	
	
	  Write a register value to the current thread. {Type, Synchronous
	  function - available as Request, Notification, none (synchronous
	  function)}
	  
	  @param regname (C++: const char *)
	  @param regval (C++: const  regval_t  *)
	    

ida_dbg.set_remote_debugger():
	
	  set_remote_debugger(host, _pass, port=-1)
	
	
	  Set remote debugging options. Should be used before starting the
	  debugger.
	  
	  @param host: If empty, IDA will use local debugger. If NULL, the host
	               will not be set. (C++: const char *)
	  @param port: If -1, the default port number will be used (C++: int)
	  

ida_dbg.set_resume_mode():
	
	  set_resume_mode(tid, mode) -> bool
	
	
	  How to resume the application. Set resume mode but do not resume
	  process.
	  
	  @param tid (C++: thid_t)
	  @param mode (C++: resume_mode_t)
	  

ida_dbg.set_step_trace_options():
	
	  set_step_trace_options(options)
	
	
	  Modify step tracing options. {Type, Synchronous function - available
	  as request, Notification, none (synchronous function)}
	  
	  @param options (C++: int)
	  

ida_dbg.set_trace_base_address():
	
	  set_trace_base_address(ea)
	
	
	  Set the base address of the current trace. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @param ea (C++: ea_t)
	  

ida_dbg.set_trace_file_desc():
	
	  set_trace_file_desc(filename, description) -> bool
	
	
	  Change the description of the specified trace file.
	  
	  
	  @param filename (C++: const char *)
	  @param description (C++: const char *)
	  

ida_dbg.set_trace_platform():
	
	  set_trace_platform(platform)
	
	
	  Set platform name of current trace.
	  
	  
	  @param platform (C++: const char *)
	  

ida_dbg.set_trace_size():
	
	  set_trace_size(size) -> bool
	
	
	  Specify the new size of the circular buffer. {Type, Synchronous
	  function, Notification, none (synchronous function)}If you specify 0,
	  all available memory can be quickly used !!!
	  
	  @param size: if 0, buffer isn't circular and events are never removed.
	               If the new size is smaller than the existing number of
	               trace events, a corresponding number of trace events are
	               removed. (C++: int)
	  

ida_dbg.srcdbg_request_step_into():
	
	  srcdbg_request_step_into() -> bool
	  

ida_dbg.srcdbg_request_step_over():
	
	  srcdbg_request_step_over() -> bool
	  

ida_dbg.srcdbg_request_step_until_ret():
	
	  srcdbg_request_step_until_ret() -> bool
	  

ida_dbg.srcdbg_step_into():
	
	  srcdbg_step_into() -> bool
	  

ida_dbg.srcdbg_step_over():
	
	  srcdbg_step_over() -> bool
	  

ida_dbg.srcdbg_step_until_ret():
	
	  srcdbg_step_until_ret() -> bool
	  

ida_dbg.start_process():
	
	  start_process(path=None, args=None, sdir=None) -> int
	
	
	  Start a process in the debugger. {Type, Asynchronous function -
	  available as Request, Notification, 'dbg_process_start' }You can also
	  use the 'run_to()' function to easily start the execution of a process
	  until a given address is reached.For all parameters, a NULL value
	  indicates the debugger will take the value from the defined Process
	  Options.
	  
	  @param path: path to the executable to start (C++: const char *)
	  @param args: arguments to pass to process (C++: const char *)
	  @param sdir: starting directory for the process (C++: const char *)
	  

ida_dbg.step_into():
	
	  step_into() -> bool
	
	
	  Execute one instruction in the current thread. Other threads are kept
	  suspended. {Type, Asynchronous function - available as Request,
	  Notification, 'dbg_step_into' }
	  

ida_dbg.step_over():
	
	  step_over() -> bool
	
	
	  Execute one instruction in the current thread, but without entering
	  into functions. Others threads keep suspended. {Type, Asynchronous
	  function - available as Request, Notification, 'dbg_step_over' }
	  

ida_dbg.step_until_ret():
	
	  step_until_ret() -> bool
	
	
	  Execute instructions in the current thread until a function return
	  instruction is executed (aka "step out"). Other threads are kept
	  suspended. {Type, Asynchronous function - available as Request,
	  Notification, 'dbg_step_until_ret' }
	  

ida_dbg.store_exceptions():
	
	  store_exceptions() -> bool
	
	
	  Update the exception information stored in the debugger module by
	  invoking its dbg->set_exception_info callback
	  

ida_dbg.suspend_process():
	
	  suspend_process() -> bool
	
	
	  Suspend the process in the debugger. { Type,Synchronous function (if
	  in a notification handler)Asynchronous function (everywhere
	  else)available as Request, Notification,none (if in a notification
	  handler) 'dbg_suspend_process' (everywhere else) }The
	  'suspend_process()' function can be called from a notification handler
	  to force the stopping of the process. In this case, no notification
	  will be generated. When you suspend a process, the running command is
	  always aborted.
	  

ida_dbg.suspend_thread():
	
	  suspend_thread(tid) -> int
	
	
	  Suspend thread. Suspending a thread may deadlock the whole application
	  if the suspended was owning some synchronization objects. {Type,
	  Synchronous function - available as request, Notification, none
	  (synchronous function)}
	  
	  @param tid: thread id (C++: thid_t)
	  

class ida_dbg.tev_info_reg_t():
	
	    Proxy of C++ tev_info_reg_t class
	    

ida_dbg.tev_info_reg_t.info:
	tev_info_reg_t_info_get(self) -> tev_info_t

ida_dbg.tev_info_reg_t.registers:
	tev_info_reg_t_registers_get(self) -> tev_reg_values_t

class ida_dbg.tev_info_t():
	
	    Proxy of C++ tev_info_t class
	    

ida_dbg.tev_info_t.ea:
	tev_info_t_ea_get(self) -> ea_t

ida_dbg.tev_info_t.tid:
	tev_info_t_tid_get(self) -> thid_t

ida_dbg.tev_info_t.type:
	tev_info_t_type_get(self) -> tev_type_t

class ida_dbg.tev_reg_value_t():
	
	    Proxy of C++ tev_reg_value_t class
	    

ida_dbg.tev_reg_value_t.reg_idx:
	tev_reg_value_t_reg_idx_get(self) -> int

ida_dbg.tev_reg_value_t.value:
	tev_reg_value_t_value_get(self) -> regval_t

class ida_dbg.tev_reg_values_t():
	
	    Proxy of C++ qvector<(tev_reg_value_t)> class
	    

ida_dbg.tev_reg_values_t.at():
	
	        at(self, _idx) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.begin():
	
	        begin(self) -> tev_reg_value_t
	        begin(self) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_dbg.tev_reg_values_t.clear():
	
	        clear(self)
	        

ida_dbg.tev_reg_values_t.empty():
	
	        empty(self) -> bool
	        

ida_dbg.tev_reg_values_t.end():
	
	        end(self) -> tev_reg_value_t
	        end(self) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.erase():
	
	        erase(self, it) -> tev_reg_value_t
	        erase(self, first, last) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.extract():
	
	        extract(self) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.grow():
	
	        grow(self, x=tev_reg_value_t())
	        

ida_dbg.tev_reg_values_t.inject():
	
	        inject(self, s, len)
	        

ida_dbg.tev_reg_values_t.insert():
	
	        insert(self, it, x) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.pop_back():
	
	        pop_back(self)
	        

ida_dbg.tev_reg_values_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> tev_reg_value_t
	        

ida_dbg.tev_reg_values_t.qclear():
	
	        qclear(self)
	        

ida_dbg.tev_reg_values_t.reserve():
	
	        reserve(self, cnt)
	        

ida_dbg.tev_reg_values_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_dbg.tev_reg_values_t.size():
	
	        size(self) -> size_t
	        

ida_dbg.tev_reg_values_t.swap():
	
	        swap(self, r)
	        

ida_dbg.tev_reg_values_t.truncate():
	
	        truncate(self)
	        

class ida_dbg.tevinforeg_vec_t():
	
	    Proxy of C++ qvector<(tev_info_reg_t)> class
	    

ida_dbg.tevinforeg_vec_t.at():
	
	        at(self, _idx) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.begin():
	
	        begin(self) -> tev_info_reg_t
	        begin(self) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_dbg.tevinforeg_vec_t.clear():
	
	        clear(self)
	        

ida_dbg.tevinforeg_vec_t.empty():
	
	        empty(self) -> bool
	        

ida_dbg.tevinforeg_vec_t.end():
	
	        end(self) -> tev_info_reg_t
	        end(self) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.erase():
	
	        erase(self, it) -> tev_info_reg_t
	        erase(self, first, last) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.extract():
	
	        extract(self) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.grow():
	
	        grow(self, x=tev_info_reg_t())
	        

ida_dbg.tevinforeg_vec_t.inject():
	
	        inject(self, s, len)
	        

ida_dbg.tevinforeg_vec_t.insert():
	
	        insert(self, it, x) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.pop_back():
	
	        pop_back(self)
	        

ida_dbg.tevinforeg_vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> tev_info_reg_t
	        

ida_dbg.tevinforeg_vec_t.qclear():
	
	        qclear(self)
	        

ida_dbg.tevinforeg_vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_dbg.tevinforeg_vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_dbg.tevinforeg_vec_t.size():
	
	        size(self) -> size_t
	        

ida_dbg.tevinforeg_vec_t.swap():
	
	        swap(self, r)
	        

ida_dbg.tevinforeg_vec_t.truncate():
	
	        truncate(self)
	        

ida_dbg.update_bpt():
	
	  update_bpt(bpt) -> bool
	
	
	  Update modifiable characteristics of an existing breakpoint. To update
	  the breakpoint location, use 'change_bptlocs()' {Type, Synchronous
	  function, Notification, none (synchronous function)}Only the following
	  fields can be modified: 'bpt_t::cndbody'  'bpt_t::pass_count'
	  'bpt_t::flags'  'bpt_t::size'  'bpt_t::type' Changing some properties
	  will require removing and then re-adding the breakpoint to the process
	  memory (or the debugger backend), which can lead to race conditions
	  (i.e., breakpoint(s) can be missed) in case the process is not
	  suspended. Here are a list of scenarios that will require the
	  breakpoint to be removed & then re-added: 'bpt_t::size' is modified
	  'bpt_t::type' is modified 'bpt_t::flags' 's BPT_ENABLED is modified
	  'bpt_t::flags' 's BPT_LOWCND is changed 'bpt_t::flags' 's BPT_LOWCND
	  remains set, but cndbody changed
	  
	  @param bpt (C++: const  bpt_t  *)
	  

ida_dbg.wait_for_next_event():
	
	  wait_for_next_event(wfne, timeout) -> dbg_event_code_t
	
	
	  Wait for the next event.This function (optionally) resumes the process
	  execution, and waits for a debugger event until a possible timeout
	  occurs.
	  
	  @param wfne: combination of  Wait for debugger event flags  constants
	               (C++: int)
	  @param timeout: number of seconds to wait, -1-infinity (C++: int)
	  @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
	           0)
	  

ida_dbg.write_dbg_memory():
	
	  write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t
	  


=== ida_dbg EPYDOC INJECTIONS ===
ida_dbg.BKPT_ACTIVE
"""
active?
"""

ida_dbg.BKPT_BADBPT
"""
failed to write the bpt to the process memory (at least one location)
"""

ida_dbg.BKPT_CNDREADY
"""
condition has been compiled
"""

ida_dbg.BKPT_FAKEPEND
"""
bpt of the same type is active at the same address(es)

fake pending bpt: it is inactive but another
"""

ida_dbg.BKPT_LISTBPT
"""
include in bpt list (user-defined bpt)
"""

ida_dbg.BKPT_PAGE
"""
only after writing the bpt to the process.

written to the process as a page bpt. is available
"""

ida_dbg.BKPT_PARTIAL
"""
partially active? (some locations were not written yet)
"""

ida_dbg.BKPT_TRACE
"""
trace bpt; should not be deleted when the process gets suspended
"""

ida_dbg.BPTCK_ACT
"""
breakpoint is active (written to the process)
"""

ida_dbg.BPTCK_NO
"""
breakpoint is disabled
"""

ida_dbg.BPTCK_NONE
"""
breakpoint does not exist
"""

ida_dbg.BPTCK_YES
"""
breakpoint is enabled
"""

ida_dbg.BPTEV_ADDED
"""
Breakpoint has been added.
"""

ida_dbg.BPTEV_CHANGED
"""
Breakpoint has been modified.
"""

ida_dbg.BPTEV_REMOVED
"""
Breakpoint has been removed.
"""

ida_dbg.BPT_BRK
"""
suspend execution upon hit
"""

ida_dbg.BPT_ELANG_SHIFT
"""
index of the extlang (scripting language) of the condition
"""

ida_dbg.BPT_ENABLED
"""
enabled?
"""

ida_dbg.BPT_LOWCND
"""
condition is calculated at low level (on the server side)
"""

ida_dbg.BPT_TRACE
"""
add trace information upon hit
"""

ida_dbg.BPT_TRACEON
"""
enable tracing when the breakpoint is reached
"""

ida_dbg.BPT_TRACE_BBLK
"""
basic block tracing
"""

ida_dbg.BPT_TRACE_FUNC
"""
function tracing
"""

ida_dbg.BPT_TRACE_INSN
"""
instruction tracing
"""

ida_dbg.BPT_TRACE_TYPES
"""
trace insns, functions, and basic blocks. if any of 'BPT_TRACE_TYPES'
bits are set but 'BPT_TRACEON' is clear, then turn off tracing for the
specified trace types
"""

ida_dbg.BPT_UPDMEM
"""
refresh the memory layout and contents before evaluating bpt condition
"""

ida_dbg.BT_LOG_INSTS
"""
log all instructions in the current basic block
"""

ida_dbg.DBGINV_ALL
"""
invalidate everything
"""

ida_dbg.DBGINV_MEMCFG
"""
invalidate cached process segmentation
"""

ida_dbg.DBGINV_MEMORY
"""
invalidate cached memory contents
"""

ida_dbg.DBGINV_NONE
"""
invalidate nothing
"""

ida_dbg.DBGINV_REDRAW
"""
refresh the screen
"""

ida_dbg.DBGINV_REGS
"""
invalidate cached register values
"""

ida_dbg.DOPT_BPT_MSGS
"""
log breakpoints
"""

ida_dbg.DOPT_END_BPT
"""
evaluate event condition on process end
"""

ida_dbg.DOPT_ENTRY_BPT
"""
break on program entry point
"""

ida_dbg.DOPT_EXCDLG
"""
exception dialogs:
"""

ida_dbg.DOPT_INFO_BPT
"""
break on debugging information
"""

ida_dbg.DOPT_INFO_MSGS
"""
log debugging info events
"""

ida_dbg.DOPT_LIB_BPT
"""
break on library load/unload
"""

ida_dbg.DOPT_LIB_MSGS
"""
log library loads/unloads
"""

ida_dbg.DOPT_LOAD_DINFO
"""
automatically load debug files (pdb)
"""

ida_dbg.DOPT_REAL_MEMORY
"""
do not hide breakpoint instructions
"""

ida_dbg.DOPT_REDO_STACK
"""
reconstruct the stack
"""

ida_dbg.DOPT_SEGM_MSGS
"""
log debugger segments modifications
"""

ida_dbg.DOPT_START_BPT
"""
break on process start
"""

ida_dbg.DOPT_TEMP_HWBPT
"""
when possible use hardware bpts for temp bpts
"""

ida_dbg.DOPT_THREAD_BPT
"""
break on thread start/exit
"""

ida_dbg.DOPT_THREAD_MSGS
"""
log thread starts/exits
"""

ida_dbg.DSTATE_NOTASK
"""
no process is currently debugged
"""

ida_dbg.DSTATE_RUN
"""
process is running
"""

ida_dbg.DSTATE_SUSP
"""
process is suspended and will not continue
"""

ida_dbg.EXCDLG_ALWAYS
"""
always display
"""

ida_dbg.EXCDLG_NEVER
"""
never display exception dialogs
"""

ida_dbg.EXCDLG_UNKNOWN
"""
display for unknown exceptions
"""

ida_dbg.FT_LOG_RET
"""
function tracing will log returning instructions
"""

ida_dbg.IT_LOG_SAME_IP
"""
instruction tracing will log instructions whose IP doesn't change
"""

ida_dbg.ST_ALREADY_LOGGED
"""
step tracing will be disabled when IP is already logged
"""

ida_dbg.ST_DIFFERENTIAL
"""
tracing: log only new instructions
"""

ida_dbg.ST_OPTIONS_MASK
"""
mask of available options, to ensure compatibility with newer IDA
versions
"""

ida_dbg.ST_OVER_DEBUG_SEG
"""
step tracing will be disabled when IP is in a debugger segment
"""

ida_dbg.ST_OVER_LIB_FUNC
"""
step tracing will be disabled when IP is in a library function
"""

ida_dbg.ST_SKIP_LOOPS
"""
step tracing will try to skip loops already recorded
"""

ida_dbg.WFNE_ANY
"""
return the first event (even if it doesn't suspend the process)
"""

ida_dbg.WFNE_CONT
"""
continue from the suspended state
"""

ida_dbg.WFNE_NOWAIT
"""
(to be used with 'WFNE_CONT' )

do not wait for any event, immediately return 'DEC_TIMEOUT'
"""

ida_dbg.WFNE_SILENT
"""
1: be slient, 0:display modal boxes if necessary
"""

ida_dbg.WFNE_SUSP
"""
wait until the process gets suspended
"""

ida_dbg.WFNE_USEC
"""
(minimum non-zero timeout is 40000us)

timeout is specified in microseconds
"""
=== ida_dbg EPYDOC INJECTIONS END ===
ida_diskio.close_linput():
	
	  close_linput(li)
	
	
	  Close loader input.
	  
	  
	  @param li (C++: linput_t *)
	  

ida_diskio.create_bytearray_linput():
	
	  create_bytearray_linput(s) -> linput_t *
	
	
	  Trivial memory linput.
	  

ida_diskio.create_generic_linput():
	
	  create_generic_linput(gl) -> linput_t *
	
	
	  Create a generic linput
	  
	  @param gl: linput description. this object will be destroyed by
	             close_linput()  using "delete gl;" (C++: generic_linput_t
	             *)
	  

ida_diskio.create_memory_linput():
	
	  create_memory_linput(start, size) -> linput_t *
	
	
	  Create a linput for process memory. This linput will use
	  read_dbg_memory() to read data.
	  
	  @param start: starting address of the input (C++: ea_t)
	  @param size: size of the memory area to represent as linput if
	               unknown, may be passed as 0 (C++: asize_t)
	  

ida_diskio.eclose():
	
	  eclose(fp)
	  

ida_diskio.enumerate_files():
	
	  enumerate_files(path, fname, callback) -> PyObject *
	
	
	  Enumerate files in the specified directory while the callback returns 0.
	  @param path: directory to enumerate files in
	  @param fname: mask of file names to enumerate
	  @param callback: a callable object that takes the filename as
	                   its first argument and it returns 0 to continue
	                   enumeration or non-zero to stop enumeration.
	  @return:
	      None in case of script errors
	      tuple(code, fname) : If the callback returns non-zero
	  

ida_diskio.fopenA():
	
	  fopenA(file) -> FILE *
	
	
	  Open a file for append in text mode, deny none.
	  
	  @param file (C++: const char *)
	  @return: NULL if failure
	  

ida_diskio.fopenM():
	
	  fopenM(file) -> FILE *
	
	
	  Open a file for read/write in binary mode, deny write.
	  
	  @param file (C++: const char *)
	  @return: NULL if failure
	  

ida_diskio.fopenRB():
	
	  fopenRB(file) -> FILE *
	
	
	  Open a file for read in binary mode, deny none.
	  
	  @param file (C++: const char *)
	  @return: NULL if failure
	  

ida_diskio.fopenRT():
	
	  fopenRT(file) -> FILE *
	
	
	  Open a file for read in text mode, deny none.
	  
	  @param file (C++: const char *)
	  @return: NULL if failure
	  

ida_diskio.fopenWB():
	
	  fopenWB(file) -> FILE *
	
	
	  Open a new file for write in binary mode, deny read/write. If a file
	  exists, it will be removed.
	  
	  @param file (C++: const char *)
	  @return: NULL if failure
	  

ida_diskio.fopenWT():
	
	  fopenWT(file) -> FILE *
	
	
	  Open a new file for write in text mode, deny write. If a file exists,
	  it will be removed.
	  
	  @param file (C++: const char *)
	  @return: NULL if failure
	  

class ida_diskio.generic_linput_t():
	
	    Proxy of C++ generic_linput_t class
	    

ida_diskio.generic_linput_t.blocksize:
	generic_linput_t_blocksize_get(self) -> uint32

ida_diskio.generic_linput_t.filesize:
	generic_linput_t_filesize_get(self) -> uint64

ida_diskio.generic_linput_t.read():
	
	        read(self, off, buffer, nbytes) -> ssize_t
	        

ida_diskio.get_ida_subdirs():
	
	  get_ida_subdirs(subdir, flags=0) -> int
	
	
	  Get list of directories in which to find a specific IDA resource (see
	  'IDA subdirectories' ). The order of the resulting list is as
	  follows:[$IDAUSR/subdir (0..N entries)]$ENVVAR for backwards
	  compatibility with some subdirs that could be overriden with
	  environment variables, such as $IDASGN, $IDAIDS, $IDAIDC, and
	  $IDATIL.$IDADIR/subdir
	  
	  @param subdir (C++: const char *)
	  @param flags (C++: int)
	  @return: number of directories appended to 'dirs'
	  

ida_diskio.get_linput_type():
	
	  get_linput_type(li) -> linput_type_t
	
	
	  Get linput type.
	  
	  
	  @param li (C++: linput_t *)
	  

ida_diskio.get_special_folder():
	
	  get_special_folder(csidl) -> bool
	
	
	  Get a folder location by CSIDL (see 'Common CSIDLs' ). Path should be
	  of at least MAX_PATH size
	  
	  @param csidl (C++: int)
	  

ida_diskio.get_user_idadir():
	
	  get_user_idadir() -> char const *
	
	
	  Get user ida related directory.if $IDAUSR is defined:the first element
	  in $IDAUSRelsedefault user directory ($HOME/.idapro or APPDATAHex-
	  Rays/IDA Pro)
	  

ida_diskio.getsysfile():
	
	  getsysfile(filename, subdir) -> char *
	
	
	  Search for IDA system file. This function searches for a file in:each
	  directory specified by IDAUSR%ida directory [+ subdir] and returns the
	  first match.
	  
	  @param filename (C++: const char *)
	  @param subdir (C++: const char *)
	  @return: NULL if not found, otherwise a pointer to full file name.
	  

ida_diskio.idadir():
	
	  idadir(subdir) -> char const *
	
	
	  Get IDA directory (if subdir==NULL) or the specified subdirectory (see
	  'IDA subdirectories' )
	  
	  @param subdir (C++: const char *)
	  

class ida_diskio.linput_buffer_t():
	
	    Proxy of C++ linput_buffer_t class
	    

ida_diskio.linput_buffer_t.eof():
	
	        eof(self) -> bool
	        

ida_diskio.linput_buffer_t.read():
	
	        read(self, buf, n) -> ssize_t
	        

ida_diskio.open_linput():
	
	  open_linput(file, remote) -> linput_t *
	
	
	  Open loader input.
	  
	  
	  @param file (C++: const char *)
	  @param remote (C++: bool)
	  

ida_diskio.qlgetz():
	
	  qlgetz(li, fpos) -> char *
	
	
	  Read a zero-terminated string from the input. If fpos == -1 then no
	  seek will be performed.
	  
	  @param li (C++: linput_t *)
	  @param fpos (C++: int64)
	  


=== ida_diskio EPYDOC INJECTIONS ===
ida_diskio.IDA_SUBDIR_IDP
"""
append the processor name as a subdirectory
"""
=== ida_diskio EPYDOC INJECTIONS END ===
ida_entry.add_entry():
	
	  add_entry(ord, ea, name, makecode, flags=0x0) -> bool
	
	
	  Add an entry point to the list of entry points.
	  
	  @param ord: ordinal number if ordinal number is equal to 'ea' then
	              ordinal is not used (C++: uval_t)
	  @param ea: linear address (C++: ea_t)
	  @param name: name of entry point. If the specified location already
	               has a name, the old name will be appended to the regular
	               comment. If name == NULL, then the old name will be
	               retained. (C++: const char *)
	  @param makecode: should the kernel convert bytes at the entry point to
	                   instruction(s) (C++: bool)
	  @param flags: See AEF_* (C++: int)
	  @return: success (currently always true)
	  

ida_entry.get_entry():
	
	  get_entry(ord) -> ea_t
	
	
	  Get entry point address by its ordinal
	  
	  @param ord: ordinal number of entry point (C++: uval_t)
	  @return: address or  BADADDR
	  

ida_entry.get_entry_forwarder():
	
	  get_entry_forwarder(ord) -> ssize_t
	
	
	  Get forwarder name for the entry point by its ordinal.
	  
	  @param ord: ordinal number of entry point (C++: uval_t)
	  @return: size of entry forwarder name or -1
	  

ida_entry.get_entry_name():
	
	  get_entry_name(ord) -> ssize_t
	
	
	  Get name of the entry point by its ordinal.
	  
	  @param ord: ordinal number of entry point (C++: uval_t)
	  @return: size of entry name or -1
	  

ida_entry.get_entry_ordinal():
	
	  get_entry_ordinal(idx) -> uval_t
	
	
	  Get ordinal number of an entry point.
	  
	  @param idx: internal number of entry point. Should be in the range 0..
	              get_entry_qty() -1 (C++: size_t)
	  @return: ordinal number or 0.
	  

ida_entry.get_entry_qty():
	
	  get_entry_qty() -> size_t
	
	
	  Get number of entry points.
	  

ida_entry.rename_entry():
	
	  rename_entry(ord, name, flags=0x0) -> bool
	
	
	  Rename entry point.
	  
	  @param ord: ordinal number of the entry point (C++: uval_t)
	  @param name: name of entry point. If the specified location already
	               has a name, the old name will be appended to a repeatable
	               comment. (C++: const char *)
	  @param flags: See AEF_* (C++: int)
	  @return: success
	  

ida_entry.set_entry_forwarder():
	
	  set_entry_forwarder(ord, name, flags=0x0) -> bool
	
	
	  Set forwarder name for ordinal.
	  
	  @param ord: ordinal number of the entry point (C++: uval_t)
	  @param name: forwarder name for entry point. (C++: const char *)
	  @param flags: See AEF_* (C++: int)
	  @return: success
	  


=== ida_entry EPYDOC INJECTIONS ===
ida_entry.AEF_IDBENC
"""
non-ASCII bytes will be decoded accordingly

the name is given in the IDB encoding;
"""

ida_entry.AEF_UTF8
"""
the name is given in UTF-8 (default)
"""
=== ida_entry EPYDOC INJECTIONS END ===
ida_enum.add_enum():
	
	  add_enum(idx, name, flag) -> enum_t
	
	
	  Add new enum type.if idx== 'BADADDR' then add as the last idxif
	  name==NULL then generate a unique name "enum_%d"
	  
	  @param idx (C++: size_t)
	  @param name (C++: const char *)
	  @param flag (C++: flags_t)
	  

ida_enum.add_enum_member():
	
	  add_enum_member(id, name, value, bmask=(bmask_t(-1))) -> int
	
	
	  Add member to enum type.
	  
	  @param id (C++: enum_t)
	  @param name (C++: const char *)
	  @param value (C++: uval_t)
	  @param bmask (C++: bmask_t)
	  @return: 0 if ok, otherwise one of  Add enum member result codes
	  

ida_enum.del_enum():
	
	  del_enum(id)
	
	
	  Delete an enum type.
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.del_enum_member():
	
	  del_enum_member(id, value, serial, bmask) -> bool
	
	
	  Delete member of enum type.
	  
	  
	  @param id (C++: enum_t)
	  @param value (C++: uval_t)
	  @param serial (C++: uchar)
	  @param bmask (C++: bmask_t)
	  

class ida_enum.enum_member_visitor_t():
	
	    Proxy of C++ enum_member_visitor_t class
	    

ida_enum.enum_member_visitor_t.visit_enum_member():
	
	        visit_enum_member(self, cid, value) -> int
	        

ida_enum.for_all_enum_members():
	
	  for_all_enum_members(id, cv) -> int
	
	
	  Visit all members of a given enum.
	  
	  
	  @param id (C++: enum_t)
	  @param cv (C++: enum_member_visitor_t  &)
	  

ida_enum.get_bmask_cmt():
	
	  get_bmask_cmt(id, bmask, repeatable) -> ssize_t
	  

ida_enum.get_bmask_name():
	
	  get_bmask_name(id, bmask) -> ssize_t
	  

ida_enum.get_enum():
	
	  get_enum(name) -> enum_t
	
	
	  Get enum by name.
	  
	  
	  @param name (C++: const char *)
	  

ida_enum.get_enum_cmt():
	
	  get_enum_cmt(id, repeatable) -> ssize_t
	
	
	  Get enum comment.
	  
	  
	  @param id (C++: enum_t)
	  @param repeatable (C++: bool)
	  

ida_enum.get_enum_flag():
	
	  get_enum_flag(id) -> flags_t
	
	
	  Get flags determining the representation of the enum. (currently they
	  define the numeric base: octal, decimal, hex, bin) and signness.
	  
	  @param id (C++: enum_t)
	  

ida_enum.get_enum_idx():
	
	  get_enum_idx(id) -> uval_t
	
	
	  Get serial number of enum. The serial number determines the place of
	  the enum in the enum window.
	  
	  @param id (C++: enum_t)
	  

ida_enum.get_enum_member():
	
	  get_enum_member(id, value, serial, mask) -> const_t
	
	
	  Find an enum member by enum, value and bitmaskif serial -1, return a
	  member with any serial
	  
	  @param id (C++: enum_t)
	  @param value (C++: uval_t)
	  @param serial (C++: int)
	  @param mask (C++: bmask_t)
	  

ida_enum.get_enum_member_bmask():
	
	  get_enum_member_bmask(id) -> bmask_t
	
	
	  Get bitmask of an enum member.
	  
	  
	  @param id (C++: const_t)
	  

ida_enum.get_enum_member_by_name():
	
	  get_enum_member_by_name(name) -> const_t
	
	
	  Get a reference to an enum member by its name.
	  
	  
	  @param name (C++: const char *)
	  

ida_enum.get_enum_member_cmt():
	
	  get_enum_member_cmt(id, repeatable) -> ssize_t
	
	
	  Get enum member's comment.
	  
	  
	  @param id (C++: const_t)
	  @param repeatable (C++: bool)
	  

ida_enum.get_enum_member_enum():
	
	  get_enum_member_enum(id) -> enum_t
	
	
	  Get the parent enum of an enum member.
	  
	  
	  @param id (C++: const_t)
	  

ida_enum.get_enum_member_name():
	
	  get_enum_member_name(id) -> ssize_t
	
	
	  Get name of an enum member by const_t.
	  
	  
	  @param id (C++: const_t)
	  

ida_enum.get_enum_member_serial():
	
	  get_enum_member_serial(cid) -> uchar
	
	
	  Get serial number of an enum member.
	  
	  
	  @param cid (C++: const_t)
	  

ida_enum.get_enum_member_value():
	
	  get_enum_member_value(id) -> uval_t
	
	
	  Get value of an enum member.
	  
	  
	  @param id (C++: const_t)
	  

ida_enum.get_enum_name():
	
	  get_enum_name(id) -> ssize_t
	
	
	  Get name of enum.
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.get_enum_qty():
	
	  get_enum_qty() -> size_t
	
	
	  Get number of declared 'enum_t' types.
	  

ida_enum.get_enum_size():
	
	  get_enum_size(id) -> size_t
	
	
	  Get the number of the members of the enum.
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.get_enum_type_ordinal():
	
	  get_enum_type_ordinal(id) -> int32
	
	
	  Get corresponding type ordinal number.
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.get_enum_width():
	
	  get_enum_width(id) -> size_t
	
	
	  Get the width of a enum element allowed values: 0
	  (unspecified),1,2,4,8,16,32,64
	  
	  @param id (C++: enum_t)
	  

ida_enum.get_first_bmask():
	
	  get_first_bmask(id) -> bmask_t
	
	
	  Get first bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @return: the smallest bitmask for enum, or DEFMASK
	  

ida_enum.get_first_enum_member():
	
	  get_first_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
	  

ida_enum.get_first_serial_enum_member():
	
	  get_first_serial_enum_member(id, value, bmask) -> const_t
	  

ida_enum.get_last_bmask():
	
	  get_last_bmask(id) -> bmask_t
	
	
	  Get last bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @return: the biggest bitmask for enum, or DEFMASK
	  

ida_enum.get_last_enum_member():
	
	  get_last_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
	  

ida_enum.get_last_serial_enum_member():
	
	  get_last_serial_enum_member(id, value, bmask) -> const_t
	  

ida_enum.get_next_bmask():
	
	  get_next_bmask(id, bmask) -> bmask_t
	
	
	  Get next bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @param bmask (C++: bmask_t)
	  @return: value of a bitmask with value higher than the specified
	           value, or DEFMASK
	  

ida_enum.get_next_enum_member():
	
	  get_next_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
	  

ida_enum.get_next_serial_enum_member():
	
	  get_next_serial_enum_member(in_out_serial, first_cid) -> const_t
	  

ida_enum.get_prev_bmask():
	
	  get_prev_bmask(id, bmask) -> bmask_t
	
	
	  Get prev bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @param bmask (C++: bmask_t)
	  @return: value of a bitmask with value lower than the specified value,
	           or DEFMASK
	  

ida_enum.get_prev_enum_member():
	
	  get_prev_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
	  

ida_enum.get_prev_serial_enum_member():
	
	  get_prev_serial_enum_member(in_out_serial, first_cid) -> const_t
	  

ida_enum.getn_enum():
	
	  getn_enum(n) -> enum_t
	
	
	  Get enum by its ordinal number (0..n).
	  
	  
	  @param n (C++: size_t)
	  

ida_enum.is_bf():
	
	  is_bf(id) -> bool
	
	
	  Is enum a bitfield? (otherwise - plain enum, no bitmasks except for
	  'DEFMASK' are allowed)
	  
	  @param id (C++: enum_t)
	  

ida_enum.is_enum_fromtil():
	
	  is_enum_fromtil(id) -> bool
	
	
	  Does enum come from type library?
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.is_enum_hidden():
	
	  is_enum_hidden(id) -> bool
	
	
	  Is enum collapsed?
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.is_ghost_enum():
	
	  is_ghost_enum(id) -> bool
	
	
	  Is a ghost copy of a local type?
	  
	  
	  @param id (C++: enum_t)
	  

ida_enum.is_one_bit_mask():
	
	  is_one_bit_mask(mask) -> bool
	
	
	  Is bitmask one bit?
	  
	  
	  @param mask (C++: bmask_t)
	  

ida_enum.set_bmask_cmt():
	
	  set_bmask_cmt(id, bmask, cmt, repeatable) -> bool
	  

ida_enum.set_bmask_name():
	
	  set_bmask_name(id, bmask, name) -> bool
	  

ida_enum.set_enum_bf():
	
	  set_enum_bf(id, bf) -> bool
	
	
	  Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
	  
	  
	  @param id (C++: enum_t)
	  @param bf (C++: bool)
	  

ida_enum.set_enum_cmt():
	
	  set_enum_cmt(id, cmt, repeatable) -> bool
	
	
	  Set comment for enum type.
	  
	  
	  @param id (C++: enum_t)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

ida_enum.set_enum_flag():
	
	  set_enum_flag(id, flag) -> bool
	
	
	  Set data representation flags.
	  
	  
	  @param id (C++: enum_t)
	  @param flag (C++: flags_t)
	  

ida_enum.set_enum_fromtil():
	
	  set_enum_fromtil(id, fromtil) -> bool
	
	
	  Specify that enum comes from a type library.
	  
	  
	  @param id (C++: enum_t)
	  @param fromtil (C++: bool)
	  

ida_enum.set_enum_ghost():
	
	  set_enum_ghost(id, ghost) -> bool
	
	
	  Specify that enum is a ghost copy of a local type.
	  
	  
	  @param id (C++: enum_t)
	  @param ghost (C++: bool)
	  

ida_enum.set_enum_hidden():
	
	  set_enum_hidden(id, hidden) -> bool
	
	
	  Collapse enum.
	  
	  
	  @param id (C++: enum_t)
	  @param hidden (C++: bool)
	  

ida_enum.set_enum_idx():
	
	  set_enum_idx(id, idx) -> bool
	
	
	  Set serial number of enum. Also see 'get_enum_idx()' .
	  
	  @param id (C++: enum_t)
	  @param idx (C++: size_t)
	  

ida_enum.set_enum_member_cmt():
	
	  set_enum_member_cmt(id, cmt, repeatable) -> bool
	
	
	  Set comment for enum member.
	  
	  
	  @param id (C++: const_t)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

ida_enum.set_enum_member_name():
	
	  set_enum_member_name(id, name) -> bool
	
	
	  Set name of enum member.
	  
	  
	  @param id (C++: const_t)
	  @param name (C++: const char *)
	  

ida_enum.set_enum_name():
	
	  set_enum_name(id, name) -> bool
	
	
	  Set name of enum type.
	  
	  
	  @param id (C++: enum_t)
	  @param name (C++: const char *)
	  

ida_enum.set_enum_type_ordinal():
	
	  set_enum_type_ordinal(id, ord)
	
	
	  Set corresponding type ordinal number.
	  
	  
	  @param id (C++: enum_t)
	  @param ord (C++: int32)
	  

ida_enum.set_enum_width():
	
	  set_enum_width(id, width) -> bool
	
	
	  See comment for 'get_enum_width()'
	  
	  
	  @param id (C++: enum_t)
	  @param width (C++: int)
	  


=== ida_enum EPYDOC INJECTIONS ===
ida_enum.DEFMASK
"""
default bitmask
"""

ida_enum.ENUM_MEMBER_ERROR_ENUM
"""
bad enum id
"""

ida_enum.ENUM_MEMBER_ERROR_ILLV
"""
bad bmask and value combination (~bmask & value != 0)
"""

ida_enum.ENUM_MEMBER_ERROR_MASK
"""
bad bmask
"""

ida_enum.ENUM_MEMBER_ERROR_NAME
"""
already have member with this name (bad name)
"""

ida_enum.ENUM_MEMBER_ERROR_VALUE
"""
already have 256 members with this value
"""
=== ida_enum EPYDOC INJECTIONS END ===
ida_expr.add_idc_class():
	
	  add_idc_class(name, super=None) -> idc_class_t *
	
	
	  Create a new IDC class.
	  
	  @param name: name of the new class (C++: const char *)
	  @param super: the base class for the new class. if the new class is
	                not based on any other class, pass NULL (C++: const
	                idc_class_t *)
	  @return: pointer to the created class. If such a class already exists,
	           a pointer to it will be returned. Pointers to other existing
	           classes may be invalidated by this call.
	  

ida_expr.add_idc_func():
	
	    Extends the IDC language by exposing a new IDC function that is backed up by a Python function
	
	    @param name: IDC function name to expose
	    @param fp: Python callable that will receive the arguments and return a tuple.
	    @param args: Arguments. A tuple of idaapi.VT_XXX constants
	    @param flags: IDC function flags. A combination of EXTFUN_XXX constants
	
	    @return: Boolean
	
	
	    Add an IDC function. This function does not modify the predefined
	    kernel functions. Example:staticerror_tidaapimyfunc5(idc_value_t*argv,
	    idc_value_t*res){msg("myfunciscalledwitharg0=%aandarg1=%s
	",argv[0].n
	    um,argv[1].str);res->num=5;//let'sreturn5returneOk;}staticconstcharmyf
	    unc5_args[]={VT_LONG,VT_STR,0};staticconstext_idcfunc_tmyfunc_desc={"M
	    yFunc5",myfunc5,myfunc5_args,NULL,0,EXTFUN_BASE};//afterthis:add_idc_f
	    unc(myfunc_desc);//thereisanewIDCfunctionwhichcanbecalledlikethis:MyFu
	    nc5(0x123,"test");If the function already exists, it will be replaced
	    by the new function
	    
	    @return: success
	    

ida_expr.add_idc_gvar():
	
	  add_idc_gvar(name) -> idc_value_t
	
	
	  Add global IDC variable.
	  
	  @param name: name of the global variable (C++: const char *)
	  @return: pointer to the created variable or existing variable. NB: the
	           returned pointer is valid until a new global var is added.
	  

ida_expr.compile_idc_file():
	
	  compile_idc_file(nonnul_line) -> bool
	  

ida_expr.compile_idc_snippet():
	
	  compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> bool
	
	
	  Compile text with IDC statements.
	  
	  @param func: name of the function to create out of the snippet (C++:
	               const char *)
	  @param text: text to compile (C++: const char *)
	  @param resolver: callback object to get values of undefined variables
	                   This object will be called if IDC function contains
	                   references to undefined variables. May be NULL. (C++:
	                   idc_resolver_t  *)
	  @param only_safe_funcs: if true, any calls to functions without
	                          EXTFUN_SAFE  flag will lead to a compilation
	                          error. (C++: bool)
	  

ida_expr.compile_idc_text():
	
	  compile_idc_text(nonnul_line) -> bool
	  

ida_expr.copy_idcv():
	
	  copy_idcv(dst, src) -> error_t
	
	
	  Copy 'src' to 'dst'. For idc objects only a reference is copied.
	  
	  @param dst (C++: idc_value_t  *)
	  @param src (C++: const  idc_value_t  &)
	  

ida_expr.create_idcv_ref():
	
	  create_idcv_ref(ref, v) -> bool
	
	
	  Create a variable reference. Currently only references to global
	  variables can be created.
	  
	  @param ref: ptr to the result (C++: idc_value_t  *)
	  @param v: variable to reference (C++: const  idc_value_t  *)
	  @return: success
	  

ida_expr.deep_copy_idcv():
	
	  deep_copy_idcv(dst, src) -> error_t
	
	
	  Deep copy an IDC object. This function performs deep copy of idc
	  objects. If 'src' is not an object, 'copy_idcv()' will be called
	  
	  @param dst (C++: idc_value_t  *)
	  @param src (C++: const  idc_value_t  &)
	  

ida_expr.del_idc_func():
	
	    Unregisters the specified IDC function
	
	    @param name: IDC function name to unregister
	
	    @return: Boolean
	
	
	    Delete an IDC function
	    

ida_expr.del_idcv_attr():
	
	  del_idcv_attr(obj, attr) -> error_t
	
	
	  Delete an object attribute.
	  
	  @param obj: variable that holds an object reference (C++: idc_value_t
	              *)
	  @param attr: attribute name (C++: const char *)
	  @return: error code, eOk on success
	  

ida_expr.deref_idcv():
	
	  deref_idcv(v, vref_flags) -> idc_value_t
	
	
	  Dereference a 'VT_REF' variable.
	  
	  @param v: variable to dereference (C++: idc_value_t  *)
	  @param vref_flags: Dereference IDC variable flags (C++: int)
	  @return: pointer to the dereference result or NULL. If returns NULL,
	           qerrno is set to eExecBadRef "Illegal variable reference"
	  

ida_expr.eval_expr():
	
	  eval_expr(rv, where, line) -> bool
	
	
	  Compile and calculate an expression.
	  
	  @param rv: pointer to the result (C++: idc_value_t  *)
	  @param where: the current linear address in the addressing space of
	                the program being disassembled. If will be used to
	                resolve names of local variables etc. if not applicable,
	                then should be  BADADDR . (C++: ea_t)
	  @param line: the expression to evaluate (C++: const char *)
	  

ida_expr.eval_idc_expr():
	
	  eval_idc_expr(rv, where, line) -> bool
	
	
	  Same as 'eval_expr()' , but will always use the IDC interpreter
	  regardless of the currently installed extlang.
	  
	  @param rv (C++: idc_value_t  *)
	  @param where (C++: ea_t)
	  

ida_expr.exec_idc_script():
	
	  exec_idc_script(result, path, func, args, argsnum) -> bool
	
	
	  Compile and execute IDC function(s) from file.
	  
	  @param result: ptr to  idc_value_t  to hold result of the function. If
	                 execution fails, this variable will contain the
	                 exception information. You may pass NULL if you are not
	                 interested in the returned value. (C++: idc_value_t  *)
	  @param path: text file containing text of IDC functions (C++: const
	               char *)
	  @param func: function name to execute (C++: const char *)
	  @param args: array of parameters (C++: const  idc_value_t)
	  @param argsnum: number of parameters to pass to 'fname' This number
	                  should be equal to number of parameters the function
	                  expects. (C++: size_t)
	  

ida_expr.exec_system_script():
	
	  exec_system_script(file, complain_if_no_file=True) -> bool
	
	
	  Compile and execute "main" function from system file.
	  
	  @param file: file name with IDC function(s). The file will be searched
	               in the idc subdir of ida (C++: const char *)
	  @param complain_if_no_file: 1: display warning if the file is not
	                              found 0: don't complain if file doesn't
	                              exist (C++: bool)
	  

ida_expr.find_idc_class():
	
	  find_idc_class(name) -> idc_class_t *
	
	
	  Find an existing IDC class by its name.
	  
	  @param name: name of the class (C++: const char *)
	  @return: pointer to the class or NULL. The returned pointer is valid
	           until a new call to  add_idc_class()
	  

ida_expr.find_idc_func():
	
	  find_idc_func(prefix, n=0) -> bool
	  

ida_expr.find_idc_gvar():
	
	  find_idc_gvar(name) -> idc_value_t
	
	
	  Find an existing global IDC variable by its name.
	  
	  @param name: name of the global variable (C++: const char *)
	  @return: pointer to the variable or NULL. NB: the returned pointer is
	           valid until a new global var is added. FIXME: it is difficult
	           to use this function in a thread safe manner
	  

ida_expr.first_idcv_attr():
	
	  first_idcv_attr(obj) -> char const *
	  

ida_expr.free_idcv():
	
	  free_idcv(v)
	
	
	  Free storage used by 'VT_STR' / 'VT_OBJ' IDC variables. After this
	  call the variable has a numeric value 0
	  
	  @param v (C++: idc_value_t  *)
	  

ida_expr.get_idc_filename():
	
	  get_idc_filename(file) -> char *
	
	
	  Get full name of IDC file name. Search for file in list of include
	  directories, IDCPATH directory and the current directory.
	  
	  @param file: file name without full path (C++: const char *)
	  @return: NULL is file not found. otherwise returns pointer to buf
	  

ida_expr.get_idcv_attr():
	
	  get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t
	
	
	  Get an object attribute.
	  
	  @param res: buffer for the attribute value (C++: idc_value_t  *)
	  @param obj: variable that holds an object reference. if obj is NULL it
	              searches global variables, then user functions (C++: const
	              idc_value_t  *)
	  @param attr: attribute name (C++: const char *)
	  @param may_use_getattr: may call getattr functions to calculate the
	                          attribute if it does not exist (C++: bool)
	  @return: error code, eOk on success
	  

ida_expr.get_idcv_class_name():
	
	  get_idcv_class_name(obj) -> error_t
	
	
	  Retrieves the IDC object class name.
	  
	  @param obj: class instance variable (C++: const  idc_value_t  *)
	  @return: error code, eOk on success
	  

ida_expr.get_idcv_slice():
	
	  get_idcv_slice(res, v, i1, i2, flags=0) -> error_t
	
	
	  Get slice.
	  
	  @param res: output variable that will contain the slice (C++:
	              idc_value_t  *)
	  @param v: input variable (string or object) (C++: const  idc_value_t
	            *)
	  @param i1: slice start index (C++: uval_t)
	  @param i2: slice end index (excluded) (C++: uval_t)
	  @param flags: IDC variable slice flags  or 0 (C++: int)
	  @return: eOk if success
	  

class ida_expr.highlighter_cbs_t():
	
	    Proxy of C++ highlighter_cbs_t class
	    

ida_expr.highlighter_cbs_t.cur_block_state():
	
	        cur_block_state(self) -> int32
	        

ida_expr.highlighter_cbs_t.prev_block_state():
	
	        prev_block_state(self) -> int32
	        

ida_expr.highlighter_cbs_t.set_block_state():
	
	        set_block_state(self, arg0)
	        

ida_expr.highlighter_cbs_t.set_style():
	
	        set_style(self, arg0, arg1, arg2)
	        

class ida_expr.idc_global_t():
	
	    Proxy of C++ idc_global_t class
	    

ida_expr.idc_global_t.name:
	idc_global_t_name_get(self) -> qstring *

ida_expr.idc_global_t.value:
	idc_global_t_value_get(self) -> idc_value_t

class ida_expr.idc_value_t():
	
	    Proxy of C++ idc_value_t class
	    

ida_expr.idc_value_t.c_str():
	
	        c_str(self) -> char const *
	        

ida_expr.idc_value_t.clear():
	
	        clear(self)
	        

ida_expr.idc_value_t.create_empty_string():
	
	        create_empty_string(self)
	        

ida_expr.idc_value_t.e:
	idc_value_t_e_get(self) -> ushort [6]

ida_expr.idc_value_t.funcidx:
	idc_value_t_funcidx_get(self) -> int

ida_expr.idc_value_t.i64:
	idc_value_t_i64_get(self) -> int64

ida_expr.idc_value_t.is_convertible():
	
	        is_convertible(self) -> bool
	        

ida_expr.idc_value_t.is_integral():
	
	        is_integral(self) -> bool
	        

ida_expr.idc_value_t.is_zero():
	
	        is_zero(self) -> bool
	        

ida_expr.idc_value_t.num:
	idc_value_t_num_get(self) -> sval_t

ida_expr.idc_value_t.obj:
	idc_value_t_obj_get(self) -> idc_object_t *

ida_expr.idc_value_t.pvoid:
	idc_value_t_pvoid_get(self) -> void *

ida_expr.idc_value_t.qstr():
	
	        qstr(self) -> qstring
	        qstr(self) -> qstring const &
	        

ida_expr.idc_value_t.reserve:
	idc_value_t_reserve_get(self) -> uchar [sizeof(qstring)]

ida_expr.idc_value_t.set_float():
	
	        set_float(self, f)
	        

ida_expr.idc_value_t.set_int64():
	
	        set_int64(self, v)
	        

ida_expr.idc_value_t.set_long():
	
	        set_long(self, v)
	        

ida_expr.idc_value_t.set_pvoid():
	
	        set_pvoid(self, p)
	        

ida_expr.idc_value_t.set_string():
	
	        set_string(self, _str, len)
	        set_string(self, _str)
	        set_string(self, _str)
	        

ida_expr.idc_value_t.swap():
	
	        swap(self, v)
	        

ida_expr.idc_value_t.u_str():
	
	        u_str(self) -> uchar const *
	        

ida_expr.idc_value_t.vtype:
	idc_value_t_vtype_get(self) -> char

class ida_expr.idc_values_t():
	
	    Proxy of C++ qvector<(idc_value_t)> class
	    

ida_expr.idc_values_t.at():
	
	        at(self, _idx) -> idc_value_t
	        

ida_expr.idc_values_t.begin():
	
	        begin(self) -> idc_value_t
	        begin(self) -> idc_value_t
	        

ida_expr.idc_values_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_expr.idc_values_t.clear():
	
	        clear(self)
	        

ida_expr.idc_values_t.empty():
	
	        empty(self) -> bool
	        

ida_expr.idc_values_t.end():
	
	        end(self) -> idc_value_t
	        end(self) -> idc_value_t
	        

ida_expr.idc_values_t.erase():
	
	        erase(self, it) -> idc_value_t
	        erase(self, first, last) -> idc_value_t
	        

ida_expr.idc_values_t.extract():
	
	        extract(self) -> idc_value_t
	        

ida_expr.idc_values_t.grow():
	
	        grow(self, x=idc_value_t())
	        

ida_expr.idc_values_t.inject():
	
	        inject(self, s, len)
	        

ida_expr.idc_values_t.insert():
	
	        insert(self, it, x) -> idc_value_t
	        

ida_expr.idc_values_t.pop_back():
	
	        pop_back(self)
	        

ida_expr.idc_values_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> idc_value_t
	        

ida_expr.idc_values_t.qclear():
	
	        qclear(self)
	        

ida_expr.idc_values_t.reserve():
	
	        reserve(self, cnt)
	        

ida_expr.idc_values_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_expr.idc_values_t.size():
	
	        size(self) -> size_t
	        

ida_expr.idc_values_t.swap():
	
	        swap(self, r)
	        

ida_expr.idc_values_t.truncate():
	
	        truncate(self)
	        

ida_expr.idcv_float():
	
	  idcv_float(v) -> error_t
	
	
	  Convert IDC variable to a floating point.
	  
	  
	  @param v (C++: idc_value_t  *)
	  

ida_expr.idcv_int64():
	
	  idcv_int64(v) -> error_t
	
	
	  Convert IDC variable to a 64bit number.
	  
	  @param v (C++: idc_value_t  *)
	  @return: v = 0 if impossible to convert to int64
	  

ida_expr.idcv_long():
	
	  idcv_long(v) -> error_t
	
	
	  Convert IDC variable to a long (32/64bit) number.
	  
	  @param v (C++: idc_value_t  *)
	  @return: v = 0 if impossible to convert to long
	  

ida_expr.idcv_num():
	
	  idcv_num(v) -> error_t
	
	
	  Convert IDC variable to a long number.
	  
	  @param v (C++: idc_value_t  *)
	  @return: v = 0 if IDC variable = "false" string v = 1 if IDC variable
	           = "true" string v = number if IDC variable is number or
	           string containing a number eTypeConflict if IDC variable =
	           empty string
	  

ida_expr.idcv_object():
	
	  idcv_object(v, icls=None) -> error_t
	
	
	  Create an IDC object. The original value of 'v' is discarded (freed).
	  
	  @param v: variable to hold the object. any previous value will be
	            cleaned (C++: idc_value_t  *)
	  @param icls: ptr to the desired class. NULL means "object" class this
	               ptr must be returned by  add_idc_class()  or
	               find_idc_class() (C++: const idc_class_t *)
	  @return: always eOk
	  

ida_expr.idcv_string():
	
	  idcv_string(v) -> error_t
	
	
	  Convert IDC variable to a text string.
	  
	  
	  @param v (C++: idc_value_t  *)
	  

ida_expr.last_idcv_attr():
	
	  last_idcv_attr(obj) -> char const *
	  

ida_expr.move_idcv():
	
	  move_idcv(dst, src) -> error_t
	
	
	  Move 'src' to 'dst'. This function is more effective than copy_idcv
	  since it never copies big amounts of data.
	  
	  @param dst (C++: idc_value_t  *)
	  @param src (C++: idc_value_t  *)
	  

ida_expr.next_idcv_attr():
	
	  next_idcv_attr(obj, attr) -> char const *
	  

ida_expr.prev_idcv_attr():
	
	  prev_idcv_attr(obj, attr) -> char const *
	  

ida_expr.print_idcv():
	
	  print_idcv(v, name=None, indent=0) -> bool
	
	
	  Get text representation of 'idc_value_t' .
	  
	  
	  @param v (C++: const  idc_value_t  &)
	  @param name (C++: const char *)
	  @param indent (C++: int)
	  

ida_expr.py_add_idc_func():
	
	  py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool
	  

ida_expr.py_get_call_idc_func():
	
	  py_get_call_idc_func() -> size_t
	  

ida_expr.pyw_convert_defvals():
	
	  pyw_convert_defvals(out, py_seq) -> bool
	  

ida_expr.pyw_register_idc_func():
	
	  pyw_register_idc_func(name, args, py_fp) -> size_t
	  

ida_expr.pyw_unregister_idc_func():
	
	  pyw_unregister_idc_func(ctxptr) -> bool
	  

ida_expr.set_header_path():
	
	  set_header_path(path, add) -> bool
	
	
	  Set or append a header path. IDA looks for the include files in the
	  appended header paths, then in the ida executable directory.
	  
	  @param path: list of directories to add (separated by ';') may be
	               NULL, in this case nothing is added (C++: const char *)
	  @param add: true: append. false: remove old paths. (C++: bool)
	  

ida_expr.set_idcv_attr():
	
	  set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t
	
	
	  Set an object attribute.
	  
	  @param obj: variable that holds an object reference. if obj is NULL
	              then it tries to modify a global variable with the
	              attribute name (C++: idc_value_t  *)
	  @param attr: attribute name (C++: const char *)
	  @param value: new attribute value (C++: const  idc_value_t  &)
	  @param may_use_setattr: may call setattr functions for the class (C++:
	                          bool)
	  @return: error code, eOk on success
	  

ida_expr.set_idcv_slice():
	
	  set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t
	
	
	  Set slice.
	  
	  @param v: variable to modify (string or object) (C++: idc_value_t  *)
	  @param i1: slice start index (C++: uval_t)
	  @param i2: slice end index (excluded) (C++: uval_t)
	  @param flags: IDC variable slice flags  or 0 (C++: int)
	  @return: eOk on success
	  

ida_expr.swap_idcvs():
	
	  swap_idcvs(v1, v2)
	
	
	  Swap 2 variables.
	  
	  
	  @param v1 (C++: idc_value_t  *)
	  @param v2 (C++: idc_value_t  *)
	  


=== ida_expr EPYDOC INJECTIONS ===
ida_expr.CPL_DEL_MACROS
"""
delete macros at the end of compilation
"""

ida_expr.CPL_ONLY_SAFE
"""
allow calls of only thread-safe functions
"""

ida_expr.CPL_USE_LABELS
"""
allow program labels in the script
"""

ida_expr.IDC_LANG_EXT
"""
IDC script extension.
"""

ida_expr.VARSLICE_SINGLE
"""
return single index (i2 is ignored)
"""

ida_expr.VREF_COPY
"""
copy the result to the input var (v)
"""

ida_expr.VREF_LOOP
"""
dereference until we get a non 'VT_REF'
"""

ida_expr.VREF_ONCE
"""
dereference only once, do not loop
"""

ida_expr.VT_FLOAT
"""
Floating point (see 'idc_value_t::e' )
"""

ida_expr.VT_FUNC
"""
Function (see 'idc_value_t::funcidx' )
"""

ida_expr.VT_INT64
"""
i64
"""

ida_expr.VT_LONG
"""
Integer (see 'idc_value_t::num' )
"""

ida_expr.VT_OBJ
"""
Object (see idc_value_t::obj)
"""

ida_expr.VT_PVOID
"""
void *
"""

ida_expr.VT_REF
"""
Reference.
"""

ida_expr.VT_STR
"""
String (see qstr() and similar functions)
"""

ida_expr.VT_WILD
"""
Function with arbitrary number of arguments. The actual number of
arguments will be passed in 'idc_value_t::num' . This value should not
be used for 'idc_value_t' .
"""

ida_expr.eExecThrow
"""
See return value of 'idc_func_t' .
"""
=== ida_expr EPYDOC INJECTIONS END ===
ida_fixup.calc_fixup_size():
	
	  calc_fixup_size(type) -> int
	
	
	  Calculate size of fixup in bytes (the number of bytes the fixup
	  patches)
	  
	  @param type (C++: fixup_type_t)
	  

ida_fixup.contains_fixups():
	
	  contains_fixups(ea, size) -> bool
	
	
	  Does the specified address range contain any fixup information?
	  
	  
	  @param ea (C++: ea_t)
	  @param size (C++: asize_t)
	  

ida_fixup.del_fixup():
	
	  del_fixup(source)
	
	
	  Delete fixup information.
	  
	  
	  @param source (C++: ea_t)
	  

ida_fixup.exists_fixup():
	
	  exists_fixup(source) -> bool
	
	
	  Check that a fixup exists at the given address.
	  
	  
	  @param source (C++: ea_t)
	  

ida_fixup.find_custom_fixup():
	
	  find_custom_fixup(name) -> fixup_type_t
	
	
	  Get id of a custom fixup handler.
	  
	  @param name: name of the custom fixup handler (C++: const char *)
	  @return: id with FIXUP_CUSTOM bit set or 0
	  

class ida_fixup.fixup_data_t():
	
	    Proxy of C++ fixup_data_t class
	    

ida_fixup.fixup_data_t.calc_size():
	
	        calc_size(self) -> int
	        

ida_fixup.fixup_data_t.clr_extdef():
	
	        clr_extdef(self)
	        

ida_fixup.fixup_data_t.clr_unused():
	
	        clr_unused(self)
	        

ida_fixup.fixup_data_t.displacement:
	fixup_data_t_displacement_get(self) -> adiff_t

ida_fixup.fixup_data_t.get():
	
	        get(self, source) -> bool
	        

ida_fixup.fixup_data_t.get_base():
	
	        get_base(self) -> ea_t
	        

ida_fixup.fixup_data_t.get_desc():
	
	        get_desc(self, source) -> char const *
	        

ida_fixup.fixup_data_t.get_flags():
	
	        get_flags(self) -> uint32
	        

ida_fixup.fixup_data_t.get_handler():
	
	        get_handler(self) -> fixup_handler_t const *
	        

ida_fixup.fixup_data_t.get_type():
	
	        get_type(self) -> fixup_type_t
	        

ida_fixup.fixup_data_t.get_value():
	
	        get_value(self, ea) -> uval_t
	        

ida_fixup.fixup_data_t.has_base():
	
	        has_base(self) -> bool
	        

ida_fixup.fixup_data_t.is_custom():
	
	        is_custom(self) -> bool
	        

ida_fixup.fixup_data_t.is_extdef():
	
	        is_extdef(self) -> bool
	        

ida_fixup.fixup_data_t.is_unused():
	
	        is_unused(self) -> bool
	        

ida_fixup.fixup_data_t.off:
	fixup_data_t_off_get(self) -> ea_t

ida_fixup.fixup_data_t.patch_value():
	
	        patch_value(self, ea) -> bool
	        

ida_fixup.fixup_data_t.sel:
	fixup_data_t_sel_get(self) -> sel_t

ida_fixup.fixup_data_t.set():
	
	        set(self, source)
	        

ida_fixup.fixup_data_t.set_base():
	
	        set_base(self, new_base)
	        

ida_fixup.fixup_data_t.set_extdef():
	
	        set_extdef(self)
	        

ida_fixup.fixup_data_t.set_sel():
	
	        set_sel(self, seg)
	        

ida_fixup.fixup_data_t.set_target_sel():
	
	        set_target_sel(self)
	        

ida_fixup.fixup_data_t.set_type():
	
	        set_type(self, type_)
	        

ida_fixup.fixup_data_t.set_type_and_flags():
	
	        set_type_and_flags(self, type_, flags_=0)
	        

ida_fixup.fixup_data_t.set_unused():
	
	        set_unused(self)
	        

ida_fixup.fixup_data_t.was_created():
	
	        was_created(self) -> bool
	        

class ida_fixup.fixup_info_t():
	
	    Proxy of C++ fixup_info_t class
	    

ida_fixup.fixup_info_t.ea:
	fixup_info_t_ea_get(self) -> ea_t

ida_fixup.fixup_info_t.fd:
	fixup_info_t_fd_get(self) -> fixup_data_t

ida_fixup.gen_fix_fixups():
	
	  gen_fix_fixups(_from, to, size)
	
	
	  Relocate the bytes with fixup information once more (generic
	  function). This function may be called from 'loader_t::move_segm()' if
	  it suits the goal. If 'loader_t::move_segm' is not defined then this
	  function will be called automatically when moving segments or rebasing
	  the entire program. Special parameter values (from = BADADDR, size =
	  0, to = delta) are used when the function is called from
	  rebase_program(delta).
	  
	  @param _from (C++: ea_t)
	  @param to (C++: ea_t)
	  @param size (C++: asize_t)
	  

ida_fixup.get_first_fixup_ea():
	
	  get_first_fixup_ea() -> ea_t
	
	
	  Get the first address with fixup information
	  
	  @return: the first address with fixup information, or BADADDR
	  

ida_fixup.get_fixup():
	
	  get_fixup(fd, source) -> bool
	
	
	  Get fixup information.
	  
	  
	  @param fd (C++: fixup_data_t  *)
	  @param source (C++: ea_t)
	  

ida_fixup.get_fixup_desc():
	
	  get_fixup_desc(source, fd) -> char const *
	
	
	  Get FIXUP description comment.
	  
	  
	  @param source (C++: ea_t)
	  @param fd (C++: const  fixup_data_t  &)
	  

ida_fixup.get_fixup_handler():
	
	  get_fixup_handler(type) -> fixup_handler_t const *
	
	
	  Get handler of standard or custom fixup.
	  
	  
	  @param type (C++: fixup_type_t)
	  

ida_fixup.get_fixup_value():
	
	  get_fixup_value(ea, type) -> uval_t
	
	
	  Get the operand value. This function get fixup bytes from data or an
	  instruction at `ea' and convert them to the operand value (maybe
	  partially). It is opposite in meaning to the. For example, FIXUP_HI8
	  read a byte at `ea' and shifts it left by 8 bits, or AArch64's custom
	  fixup BRANCH26 get low 26 bits of the insn at `ea' and shifts it left
	  by 2 bits. This function is mainly used to get a relocation addend.
	  'patch_fixup_value()'  'fixup_handler_t::size'
	  
	  @param ea: address to get fixup bytes from, the size of the fixup
	             bytes depends on the fixup type. (C++: ea_t)
	  @param type (C++: fixup_type_t)
	  

ida_fixup.get_fixups():
	
	  get_fixups(out, ea, size) -> bool
	  

ida_fixup.get_next_fixup_ea():
	
	  get_next_fixup_ea(ea) -> ea_t
	
	
	  Find next address with fixup information
	  
	  @param ea: current address (C++: ea_t)
	  @return: the next address with fixup information, or BADADDR
	  

ida_fixup.get_prev_fixup_ea():
	
	  get_prev_fixup_ea(ea) -> ea_t
	
	
	  Find previous address with fixup information
	  
	  @param ea: current address (C++: ea_t)
	  @return: the previous address with fixup information, or BADADDR
	  

ida_fixup.is_fixup_custom():
	
	  is_fixup_custom(type) -> bool
	
	
	  Is fixup processed by processor module?
	  
	  
	  @param type (C++: fixup_type_t)
	  

ida_fixup.patch_fixup_value():
	
	  patch_fixup_value(ea, fd) -> bool
	
	
	  Patch the fixup bytes. This function updates data or an instruction at
	  `ea' to the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea'
	  to the high byte of `fd->off', or AArch64's custom fixup BRANCH26
	  updates low 26 bits of the insn at `ea' to the value of `fd->off'
	  shifted right by 2. 'fixup_handler_t::size'
	  
	  @param ea: address where data are changed, the size of the changed
	             data depends on the fixup type. (C++: ea_t)
	  @param fd (C++: const  fixup_data_t  &)
	  

ida_fixup.set_fixup():
	
	  set_fixup(source, fd)
	
	
	  Set fixup information. You should fill 'fixup_data_t' and call this
	  function and the kernel will remember information in the database.
	  
	  @param source: the fixup source address, i.e. the address modified by
	                 the fixup (C++: ea_t)
	  @param fd: fixup data (C++: const  fixup_data_t  &)
	  


=== ida_fixup EPYDOC INJECTIONS ===
ida_fixup.FIXUPF_CREATED
"""
fixup was not present in the input file
"""

ida_fixup.FIXUPF_EXTDEF
"""
target is a location (otherwise - segment). Use this bit if the target
is a symbol rather than an offset from the beginning of a segment.
"""

ida_fixup.FIXUPF_LOADER_MASK
"""
additional flags. The bits from this mask are not stored in the
database and can be used by the loader at its discretion.
"""

ida_fixup.FIXUPF_REL
"""
fixup is relative to the linear address `base'. Otherwise fixup is
relative to the start of the segment with `sel' selector.
"""

ida_fixup.FIXUPF_UNUSED
"""
fixup is ignored by IDAdisallows the kernel to convert operandsthis
fixup is not used during output
"""
=== ida_fixup EPYDOC INJECTIONS END ===
class ida_fpro.qfile_t():
	
	    Proxy of C++ qfile_t class
	
	
	    A helper class to work with FILE related functions.
	    

ida_fpro.qfile_t.close():
	
	        close(self)
	        

ida_fpro.qfile_t.filename():
	
	        filename(self) -> PyObject *
	        

ida_fpro.qfile_t.flush():
	
	        flush(self) -> int
	
	
	        Reads a single character from the file. Returns None if EOF or the read character
	        

ida_fpro.qfile_t.from_cobject():
	
	        from_cobject(pycobject) -> qfile_t
	        

ida_fpro.qfile_t.from_fp():
	
	        from_fp(fp) -> qfile_t
	        

ida_fpro.qfile_t.get_char():
	
	        get_char(self) -> PyObject *
	        

ida_fpro.qfile_t.get_fp():
	
	        get_fp(self) -> FILE *
	        

ida_fpro.qfile_t.gets():
	
	        gets(self, size) -> PyObject *
	
	
	        Reads a line from the input file. Returns the read line or None
	        

ida_fpro.qfile_t.open():
	
	        open(self, filename, mode) -> bool
	
	
	        Opens a file
	        @param filename: the file name
	        @param mode: The mode string, ala fopen() style
	        @return: Boolean
	        

ida_fpro.qfile_t.opened():
	
	        opened(self) -> bool
	
	
	        Checks if the file is opened or not
	        

ida_fpro.qfile_t.put_char():
	
	        put_char(self, chr) -> int
	
	
	        Writes a single character to the file
	        

ida_fpro.qfile_t.puts():
	
	        puts(self, str) -> int
	        

ida_fpro.qfile_t.read():
	
	        read(self, size) -> PyObject *
	
	
	        Reads from the file. Returns the buffer or None
	        

ida_fpro.qfile_t.readbytes():
	
	        readbytes(self, size, big_endian) -> PyObject *
	
	
	        Similar to read() but it respect the endianness
	        

ida_fpro.qfile_t.seek():
	
	        seek(self, offset, whence=SEEK_SET) -> int
	
	
	        Set input source position
	        @return: the new position (not 0 as fseek!)
	        

ida_fpro.qfile_t.size():
	
	        size(self) -> int64
	        

ida_fpro.qfile_t.tell():
	
	        tell(self) -> int64
	
	
	        Returns the current position
	        

ida_fpro.qfile_t.tmpfile():
	
	        tmpfile() -> qfile_t
	
	
	        A static method to construct an instance using a temporary file
	        

ida_fpro.qfile_t.write():
	
	        write(self, py_buf) -> int
	
	
	        Writes to the file. Returns 0 or the number of bytes written
	        

ida_fpro.qfile_t.writebytes():
	
	        writebytes(self, py_buf, big_endian) -> int
	
	
	        Similar to write() but it respect the endianness
	        

ida_fpro.qfile_t_from_cobject():
	
	  qfile_t_from_cobject(pycobject) -> qfile_t
	  

ida_fpro.qfile_t_from_fp():
	
	  qfile_t_from_fp(fp) -> qfile_t
	  

ida_fpro.qfile_t_tmpfile():
	
	  qfile_t_tmpfile() -> qfile_t
	  

ida_frame.add_auto_stkpnt():
	
	  add_auto_stkpnt(pfn, ea, delta) -> bool
	
	
	  Add automatic SP register change point.
	  
	  @param pfn: pointer to function. may be NULL. (C++: func_t  *)
	  @param ea: linear address where SP changes. usually this is the end of
	             the instruction which modifies the stack pointer
	             ({ea}+{size}) (C++: ea_t)
	  @param delta: difference between old and new values of SP (C++:
	                sval_t)
	  @return: success
	  

ida_frame.add_frame():
	
	  add_frame(pfn, frsize, frregs, argsize) -> bool
	
	
	  Add function frame.
	  
	  @param pfn: pointer to function structure (C++: func_t  *)
	  @param frsize: size of function local variables (C++: sval_t)
	  @param frregs: size of saved registers (C++: ushort)
	  @param argsize: size of function arguments range which will be purged
	                  upon return. this parameter is used for __stdcall and
	                  __pascal calling conventions. for other calling
	                  conventions please pass 0. (C++: asize_t)
	  

ida_frame.add_regvar():
	
	  add_regvar(pfn, ea1, ea2, canon, user, cmt) -> int
	
	
	  Define a register variable.
	  
	  @param pfn: function in which the definition will be created (C++:
	              func_t  *)
	  @param ea1: range of addresses within the function where the
	              definition will be used (C++: ea_t)
	  @param ea2: range of addresses within the function where the
	              definition will be used (C++: ea_t)
	  @param canon: name of a general register (C++: const char *)
	  @param user: user-defined name for the register (C++: const char *)
	  @param cmt: comment for the definition (C++: const char *)
	  @return: Register variable error codes
	  

ida_frame.add_user_stkpnt():
	
	  add_user_stkpnt(ea, delta) -> bool
	
	
	  Add user-defined SP register change point.
	  
	  @param ea: linear address where SP changes (C++: ea_t)
	  @param delta: difference between old and new values of SP (C++:
	                sval_t)
	  @return: success
	  

ida_frame.build_stkvar_name():
	
	  build_stkvar_name(pfn, v) -> ssize_t
	
	
	  Build automatic stack variable name.
	  
	  @param pfn: pointer to function (can't be NULL!) (C++: const  func_t
	              *)
	  @param v: value of variable offset (C++: sval_t)
	  @return: length of stack variable name or -1
	  

ida_frame.build_stkvar_xrefs():
	
	  build_stkvar_xrefs(out, pfn, mptr)
	
	
	  Fill 'out' with a list of all the xrefs made from function 'pfn', to
	  the argument or variable 'mptr' in 'pfn's stack frame.
	  
	  @param out: the list of xrefs to fill. (C++: xreflist_t  *)
	  @param pfn: the function to scan. (C++: func_t  *)
	  @param mptr: the argument/variable in pfn's stack frame. (C++: const
	               member_t  *)
	  

ida_frame.calc_stkvar_struc_offset():
	
	  calc_stkvar_struc_offset(pfn, insn, n) -> ea_t
	
	
	  Calculate offset of stack variable in the frame structure.
	  
	  @param pfn: pointer to function (can't be NULL!) (C++: func_t  *)
	  @param insn: the instruction (C++: const  insn_t  &)
	  @param n: number of operand: (0.. UA_MAXOP -1) -1 if error, return
	            BADADDR (C++: int)
	  @return: BADADDR  if some error (issue a warning if stack frame is
	           bad)
	  

ida_frame.define_stkvar():
	
	  define_stkvar(pfn, name, off, flags, ti, nbytes) -> bool
	
	
	  Define/redefine a stack variable.
	  
	  @param pfn: pointer to function (C++: func_t  *)
	  @param name: variable name, NULL means autogenerate a name (C++: const
	               char *)
	  @param off: offset of the stack variable in the frame. negative values
	              denote local variables, positive - function arguments.
	              (C++: sval_t)
	  @param flags: variable type flags ( byte_flag()  for a byte variable,
	                for example) (C++: flags_t)
	  @param ti: additional type information (like offsets, structs, etc)
	             (C++: const  opinfo_t  *)
	  @param nbytes: number of bytes occupied by the variable (C++: asize_t)
	  @return: success
	  

ida_frame.del_frame():
	
	  del_frame(pfn) -> bool
	
	
	  Delete a function frame.
	  
	  @param pfn: pointer to function structure (C++: func_t  *)
	  @return: success
	  

ida_frame.del_regvar():
	
	  del_regvar(pfn, ea1, ea2, canon) -> int
	
	
	  Delete a register variable definition.
	  
	  @param pfn: function in question (C++: func_t  *)
	  @param ea1: range of addresses within the function where the
	              definition holds (C++: ea_t)
	  @param ea2: range of addresses within the function where the
	              definition holds (C++: ea_t)
	  @param canon: name of a general register (C++: const char *)
	  @return: Register variable error codes
	  

ida_frame.del_stkpnt():
	
	  del_stkpnt(pfn, ea) -> bool
	
	
	  Delete SP register change point.
	  
	  @param pfn: pointer to function. may be NULL. (C++: func_t  *)
	  @param ea: linear address (C++: ea_t)
	  @return: success
	  

ida_frame.delete_unreferenced_stkvars():
	
	  delete_unreferenced_stkvars(pfn) -> int
	  

ida_frame.delete_wrong_stkvar_ops():
	
	  delete_wrong_stkvar_ops(pfn) -> int
	  

ida_frame.find_regvar():
	
	    find_regvar(pfn, ea1, ea2, canon, user) -> regvar_t
	    find_regvar(pfn, ea, canon) -> regvar_t
	
	
	  Find a register variable definition (powerful version). One of 'canon'
	  and 'user' should be NULL.
	  
	  @param pfn: function in question (C++: func_t  *)
	  @param ea1: range of addresses to search. ea1==BADADDR means the
	              entire function (C++: ea_t)
	  @param ea2: range of addresses to search. ea1==BADADDR means the
	              entire function (C++: ea_t)
	  @param canon: name of a general register (C++: const char *)
	  @param user: user-defined name for the register (C++: const char *)
	  @return: NULL-not found, otherwise ptr to  regvar_t
	    

ida_frame.frame_off_args():
	
	  frame_off_args(pfn) -> ea_t
	
	
	  Get starting address of arguments section.
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_frame.frame_off_lvars():
	
	  frame_off_lvars(pfn) -> ea_t
	
	
	  Get start address of local variables section.
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_frame.frame_off_retaddr():
	
	  frame_off_retaddr(pfn) -> ea_t
	
	
	  Get starting address of return address section.
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_frame.frame_off_savregs():
	
	  frame_off_savregs(pfn) -> ea_t
	
	
	  Get starting address of saved registers section.
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_frame.get_effective_spd():
	
	  get_effective_spd(pfn, ea) -> sval_t
	
	
	  Get effective difference between the initial and current values of
	  ESP. This function returns the sp-diff used by the instruction. The
	  difference between 'get_spd()' and 'get_effective_spd()' is present
	  only for instructions like "pop [esp+N]": they modify sp and use the
	  modified value.
	  
	  @param pfn: pointer to function. may be NULL. (C++: func_t  *)
	  @param ea: linear address (C++: ea_t)
	  @return: 0 or the difference, usually a negative number
	  

ida_frame.get_frame():
	
	    get_frame(pfn) -> struc_t
	    get_frame(ea) -> struc_t *
	
	
	  Get pointer to function frame.
	  
	  @param pfn: pointer to function structure (C++: const  func_t  *)
	    

ida_frame.get_frame_part():
	
	  get_frame_part(range, pfn, part)
	
	
	  Get offsets of the frame part in the frame.
	  
	  @param range: pointer to the output buffer with the frame part
	                start/end(exclusive) offsets, can't be NULL (C++:
	                range_t  *)
	  @param pfn: pointer to function structure, can't be NULL (C++: const
	              func_t  *)
	  @param part: frame part (C++: frame_part_t)
	  

ida_frame.get_frame_retsize():
	
	  get_frame_retsize(pfn) -> int
	
	
	  Get size of function return address.
	  
	  @param pfn: pointer to function structure, can't be NULL (C++: const
	              func_t  *)
	  

ida_frame.get_frame_size():
	
	  get_frame_size(pfn) -> asize_t
	
	
	  Get full size of a function frame. This function takes into account
	  size of local variables + size of saved registers + size of return
	  address + number of purged bytes. The purged bytes correspond to the
	  arguments of the functions with __stdcall and __fastcall calling
	  conventions.
	  
	  @param pfn: pointer to function structure, may be NULL (C++: const
	              func_t  *)
	  @return: size of frame in bytes or zero
	  

ida_frame.get_func_by_frame():
	
	  get_func_by_frame(frame_id) -> ea_t
	
	
	  Get function by its frame id.this function works only with databases
	  created by IDA > 5.6
	  
	  @param frame_id: id of the function frame (C++: tid_t)
	  @return: start address of the function or  BADADDR
	  

ida_frame.get_min_spd_ea():
	
	  get_min_spd_ea(pfn) -> ea_t
	  

ida_frame.get_sp_delta():
	
	  get_sp_delta(pfn, ea) -> sval_t
	
	
	  Get modification of SP made at the specified location
	  
	  @param pfn: pointer to function. may be NULL. (C++: func_t  *)
	  @param ea: linear address (C++: ea_t)
	  @return: 0 if the specified location doesn't contain a SP change
	           point. otherwise return delta of SP modification.
	  

ida_frame.get_spd():
	
	  get_spd(pfn, ea) -> sval_t
	
	
	  Get difference between the initial and current values of ESP.
	  
	  @param pfn: pointer to function. may be NULL. (C++: func_t  *)
	  @param ea: linear address of an instruction (C++: ea_t)
	  @return: 0 or the difference, usually a negative number. returns the
	           sp-diff before executing the instruction.
	  

ida_frame.get_stkvar():
	
	  get_stkvar(insn, op, v) -> PyObject *
	
	
	  Get pointer to stack variable
	  @param op: reference to instruction operand
	  @param v: immediate value in the operand (usually op.addr)
	  @return:
	      - None on failure
	      - tuple(member_t, actval)
	        where actval: actual value used to fetch stack variable
	  

ida_frame.is_funcarg_off():
	
	  is_funcarg_off(pfn, frameoff) -> bool
	
	
	  Does the given offset lie within the arguments section?
	  
	  
	  @param pfn (C++: const  func_t  *)
	  @param frameoff (C++: uval_t)
	  

class ida_frame.llabel_t():
	
	    Proxy of C++ llabel_t class
	    

ida_frame.llabel_t.ea:
	llabel_t_ea_get(self) -> ea_t

ida_frame.llabel_t.name:
	llabel_t_name_get(self) -> char *

ida_frame.lvar_off():
	
	  lvar_off(pfn, frameoff) -> sval_t
	
	
	  Does the given offset lie within the local variables section?
	  
	  
	  @param pfn (C++: const  func_t  *)
	  @param frameoff (C++: uval_t)
	  

ida_frame.recalc_spd():
	
	  recalc_spd(cur_ea) -> bool
	
	
	  Recalculate SP delta for an instruction that stops execution. The next
	  instruction is not reached from the current instruction. We need to
	  recalculate SP for the next instruction.This function will create a
	  new automatic SP register change point if necessary. It should be
	  called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
	  current instruction doesn't pass the execution flow to the next
	  instruction.
	  
	  @param cur_ea: linear address of the current instruction (C++: ea_t)
	  

class ida_frame.regvar_t():
	
	    Proxy of C++ regvar_t class
	    

ida_frame.regvar_t._print():
	
	        _print(self) -> size_t
	        

ida_frame.regvar_t.canon:
	regvar_t_canon_get(self) -> char *

ida_frame.regvar_t.clear():
	
	        clear(self)
	        

ida_frame.regvar_t.cmt:
	regvar_t_cmt_get(self) -> char *

ida_frame.regvar_t.compare():
	
	        compare(self, r) -> int
	        

ida_frame.regvar_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_frame.regvar_t.empty():
	
	        empty(self) -> bool
	        

ida_frame.regvar_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_frame.regvar_t.extend():
	
	        extend(self, ea)
	        

ida_frame.regvar_t.intersect():
	
	        intersect(self, r)
	        

ida_frame.regvar_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_frame.regvar_t.size():
	
	        size(self) -> asize_t
	        

ida_frame.regvar_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

ida_frame.regvar_t.user:
	regvar_t_user_get(self) -> char *

ida_frame.rename_regvar():
	
	  rename_regvar(pfn, v, user) -> int
	
	
	  Rename a register variable.
	  
	  @param pfn: function in question (C++: func_t  *)
	  @param v: variable to rename (C++: regvar_t  *)
	  @param user: new user-defined name for the register (C++: const char
	               *)
	  @return: Register variable error codes
	  

ida_frame.set_frame_size():
	
	  set_frame_size(pfn, frsize, frregs, argsize) -> bool
	
	
	  Set size of function frame. Note: The returned size may not include
	  all stack arguments. It does so only for __stdcall and __fastcall
	  calling conventions. To get the entire frame size for all cases use
	  get_struc_size(get_frame(pfn)).
	  
	  @param pfn: pointer to function structure (C++: func_t  *)
	  @param frsize: size of function local variables (C++: asize_t)
	  @param frregs: size of saved registers (C++: ushort)
	  @param argsize: size of function arguments that will be purged from
	                  the stack upon return (C++: asize_t)
	  @return: success
	  

ida_frame.set_purged():
	
	  set_purged(ea, nbytes, override_old_value) -> bool
	
	
	  Set the number of purged bytes for a function or data item (funcptr).
	  This function will update the database and plan to reanalyze items
	  referencing the specified address. It works only for processors with
	  'PR_PURGING' bit in 16 and 32 bit modes.
	  
	  @param ea: address of the function of item (C++: ea_t)
	  @param nbytes: number of purged bytes (C++: int)
	  @param override_old_value: may overwrite old information about purged
	                             bytes (C++: bool)
	  @return: success
	  

ida_frame.set_regvar_cmt():
	
	  set_regvar_cmt(pfn, v, cmt) -> int
	
	
	  Set comment for a register variable.
	  
	  @param pfn: function in question (C++: func_t  *)
	  @param v: variable to rename (C++: regvar_t  *)
	  @param cmt: new comment (C++: const char *)
	  @return: Register variable error codes
	  

class ida_frame.stkpnt_t():
	
	    Proxy of C++ stkpnt_t class
	    

ida_frame.stkpnt_t.ea:
	stkpnt_t_ea_get(self) -> ea_t

ida_frame.stkpnt_t.spd:
	stkpnt_t_spd_get(self) -> sval_t

class ida_frame.stkpnts_t():
	
	    Proxy of C++ stkpnts_t class
	    

ida_frame.update_fpd():
	
	  update_fpd(pfn, fpd) -> bool
	
	
	  Update frame pointer delta.
	  
	  @param pfn: pointer to function structure (C++: func_t  *)
	  @param fpd: new fpd value. can not be bigger than the local variable
	              range size. (C++: asize_t)
	  @return: success
	  

class ida_frame.xreflist_entry_t():
	
	    Proxy of C++ xreflist_entry_t class
	    

ida_frame.xreflist_entry_t.ea:
	xreflist_entry_t_ea_get(self) -> ea_t

ida_frame.xreflist_entry_t.opnum:
	xreflist_entry_t_opnum_get(self) -> uchar

ida_frame.xreflist_entry_t.type:
	xreflist_entry_t_type_get(self) -> uchar

class ida_frame.xreflist_t():
	
	    Proxy of C++ qvector<(xreflist_entry_t)> class
	    

ida_frame.xreflist_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_frame.xreflist_t.at():
	
	        at(self, _idx) -> xreflist_entry_t
	        

ida_frame.xreflist_t.begin():
	
	        begin(self) -> xreflist_entry_t
	        begin(self) -> xreflist_entry_t
	        

ida_frame.xreflist_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_frame.xreflist_t.clear():
	
	        clear(self)
	        

ida_frame.xreflist_t.empty():
	
	        empty(self) -> bool
	        

ida_frame.xreflist_t.end():
	
	        end(self) -> xreflist_entry_t
	        end(self) -> xreflist_entry_t
	        

ida_frame.xreflist_t.erase():
	
	        erase(self, it) -> xreflist_entry_t
	        erase(self, first, last) -> xreflist_entry_t
	        

ida_frame.xreflist_t.extract():
	
	        extract(self) -> xreflist_entry_t
	        

ida_frame.xreflist_t.find():
	
	        find(self, x) -> xreflist_entry_t
	        find(self, x) -> xreflist_entry_t
	        

ida_frame.xreflist_t.grow():
	
	        grow(self, x=xreflist_entry_t())
	        

ida_frame.xreflist_t.has():
	
	        has(self, x) -> bool
	        

ida_frame.xreflist_t.inject():
	
	        inject(self, s, len)
	        

ida_frame.xreflist_t.insert():
	
	        insert(self, it, x) -> xreflist_entry_t
	        

ida_frame.xreflist_t.pop_back():
	
	        pop_back(self)
	        

ida_frame.xreflist_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> xreflist_entry_t
	        

ida_frame.xreflist_t.qclear():
	
	        qclear(self)
	        

ida_frame.xreflist_t.reserve():
	
	        reserve(self, cnt)
	        

ida_frame.xreflist_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_frame.xreflist_t.size():
	
	        size(self) -> size_t
	        

ida_frame.xreflist_t.swap():
	
	        swap(self, r)
	        

ida_frame.xreflist_t.truncate():
	
	        truncate(self)
	        


=== ida_frame EPYDOC INJECTIONS ===
ida_frame.REGVAR_ERROR_ARG
"""
function arguments are bad
"""

ida_frame.REGVAR_ERROR_NAME
"""
the provided name(s) can't be accepted
"""

ida_frame.REGVAR_ERROR_OK
"""
all ok
"""

ida_frame.REGVAR_ERROR_RANGE
"""
the definition range is bad
"""

ida_frame.STKVAR_VALID_SIZE
"""
x.dtyp contains correct variable type (for insns like 'lea' this bit
must be off) in general, dr_O references do not allow to determine the
variable size
"""
=== ida_frame EPYDOC INJECTIONS END ===
ida_funcs.add_func():
	
	  add_func(ea1, ea2=BADADDR) -> bool
	
	
	  Add a new function. If the function end address is 'BADADDR' , then
	  IDA will try to determine the function bounds by calling
	  find_func_bounds(..., 'FIND_FUNC_DEFINE' ).
	  
	  @param ea1: start address (C++: ea_t)
	  @param ea2: end address (C++: ea_t)
	  @return: success
	  

ida_funcs.add_func_ex():
	
	  add_func_ex(pfn) -> bool
	
	
	  Add a new function. If the fn->end_ea is 'BADADDR' , then IDA will try
	  to determine the function bounds by calling find_func_bounds(...,
	  'FIND_FUNC_DEFINE' ).
	  
	  @param pfn: ptr to filled function structure (C++: func_t  *)
	  @return: success
	  

ida_funcs.add_regarg():
	
	  add_regarg(pfn, reg, tif, name)
	  

ida_funcs.append_func_tail():
	
	  append_func_tail(pfn, ea1, ea2) -> bool
	
	
	  Append a new tail chunk to the function definition. If the tail
	  already exists, then it will simply be added to the function tail list
	  Otherwise a new tail will be created and its owner will be set to be
	  our function If a new tail can not be created, then this function will
	  fail.
	  
	  @param pfn (C++: func_t  *)
	  @param ea1: start of the tail. If a tail already exists at the
	              specified address it must start at 'ea1' (C++: ea_t)
	  @param ea2: end of the tail. If a tail already exists at the specified
	              address it must end at 'ea2'. If specified as BADADDR, IDA
	              will determine the end address itself. (C++: ea_t)
	  

ida_funcs.apply_idasgn_to():
	
	  apply_idasgn_to(signame, ea, is_startup) -> int
	
	
	  Apply a signature file to the specified address.
	  
	  @param signame: short name of signature file (the file name without
	                  path) (C++: const char *)
	  @param ea: address to apply the signature (C++: ea_t)
	  @param is_startup: if set, then the signature is treated as a startup
	                     one for startup signature ida doesn't rename the
	                     first function of the applied module. (C++: bool)
	  @return: Library function codes
	  

ida_funcs.apply_startup_sig():
	
	  apply_startup_sig(ea, startup) -> bool
	
	
	  Apply a startup signature file to the specified address.
	  
	  @param ea: address to apply the signature to; usually {start_ea} (C++:
	             ea_t)
	  @param startup: the name of the signature file without path and
	                  extension (C++: const char *)
	  @return: true if successfully applied the signature
	  

ida_funcs.calc_func_size():
	
	  calc_func_size(pfn) -> asize_t
	
	
	  Calculate function size. This function takes into account all
	  fragments of the function.
	  
	  @param pfn: ptr to function structure (C++: func_t  *)
	  

ida_funcs.calc_idasgn_state():
	
	  calc_idasgn_state(n) -> int
	
	
	  Get state of a signature in the list of planned signatures
	  
	  @param n: number of signature in the list (0.. get_idasgn_qty() -1)
	            (C++: int)
	  @return: state of signature or  IDASGN_BADARG
	  

ida_funcs.calc_thunk_func_target():
	
	  calc_thunk_func_target(pfn) -> ea_t
	
	
	  Calculate target of a thunk function.
	  
	  @param pfn: pointer to function (may not be NULL) (C++: func_t  *)
	  @return: the target function or  BADADDR
	  

ida_funcs.del_func():
	
	  del_func(ea) -> bool
	
	
	  Delete a function.
	  
	  @param ea: any address in the function entry chunk (C++: ea_t)
	  @return: success
	  

ida_funcs.del_idasgn():
	
	  del_idasgn(n) -> int
	
	
	  Remove signature from the list of planned signatures.
	  
	  @param n: number of signature in the list (0.. get_idasgn_qty() -1)
	            (C++: int)
	  @return: IDASGN_OK ,  IDASGN_BADARG ,  IDASGN_APPLIED
	  

ida_funcs.f_any():
	
	  f_any(arg1, arg2) -> bool
	
	
	  Helper function to accept any address.
	  

ida_funcs.find_func_bounds():
	
	  find_func_bounds(nfn, flags) -> int
	
	
	  Determine the boundaries of a new function. This function tries to
	  find the start and end addresses of a new function. It calls the
	  module with {func_bounds} in order to fine tune the function
	  boundaries.
	  
	  @param nfn: structure to fill with information \ nfn->start_ea points
	              to the start address of the new function. (C++: func_t  *)
	  @param flags: Find function bounds flags (C++: int)
	  @return: Find function bounds result codes
	  

ida_funcs.func_contains():
	
	  func_contains(pfn, ea) -> bool
	
	
	  Does the given function contain the given address?
	  
	  
	  @param pfn (C++: func_t  *)
	  @param ea (C++: ea_t)
	  

ida_funcs.func_does_return():
	
	  func_does_return(callee) -> bool
	
	
	  Does the function return?. To calculate the answer, 'FUNC_NORET' flag
	  and is_noret() are consulted The latter is required for imported
	  functions in the .idata section. Since in .idata we have only function
	  pointers but not functions, we have to introduce a special flag for
	  them.
	  
	  @param callee (C++: ea_t)
	  

ida_funcs.func_item_iterator_decode_preceding_insn():
	
	  func_item_iterator_decode_preceding_insn(fii, visited, p_farref, out) -> bool
	  

ida_funcs.func_item_iterator_decode_prev_insn():
	
	  func_item_iterator_decode_prev_insn(fii, out) -> bool
	  

ida_funcs.func_item_iterator_next():
	
	  func_item_iterator_next(fii, testf, ud) -> bool
	  

ida_funcs.func_item_iterator_prev():
	
	  func_item_iterator_prev(fii, testf, ud) -> bool
	  

class ida_funcs.func_item_iterator_t():
	
	    Proxy of C++ func_item_iterator_t class
	    

ida_funcs.func_item_iterator_t.chunk():
	
	        chunk(self) -> range_t
	        

ida_funcs.func_item_iterator_t.current():
	
	        current(self) -> ea_t
	        

ida_funcs.func_item_iterator_t.decode_preceding_insn():
	
	        decode_preceding_insn(self, visited, p_farref, out) -> bool
	        

ida_funcs.func_item_iterator_t.decode_prev_insn():
	
	        decode_prev_insn(self, out) -> bool
	        

ida_funcs.func_item_iterator_t.first():
	
	        first(self) -> bool
	        

ida_funcs.func_item_iterator_t.last():
	
	        last(self) -> bool
	        

ida_funcs.func_item_iterator_t.next():
	
	        next(self, func, ud) -> bool
	        

ida_funcs.func_item_iterator_t.next_addr():
	
	        next_addr(self) -> bool
	        

ida_funcs.func_item_iterator_t.next_code():
	
	        next_code(self) -> bool
	        

ida_funcs.func_item_iterator_t.next_data():
	
	        next_data(self) -> bool
	        

ida_funcs.func_item_iterator_t.next_head():
	
	        next_head(self) -> bool
	        

ida_funcs.func_item_iterator_t.next_not_tail():
	
	        next_not_tail(self) -> bool
	        

ida_funcs.func_item_iterator_t.prev():
	
	        prev(self, func, ud) -> bool
	        

ida_funcs.func_item_iterator_t.prev_addr():
	
	        prev_addr(self) -> bool
	        

ida_funcs.func_item_iterator_t.prev_code():
	
	        prev_code(self) -> bool
	        

ida_funcs.func_item_iterator_t.prev_data():
	
	        prev_data(self) -> bool
	        

ida_funcs.func_item_iterator_t.prev_head():
	
	        prev_head(self) -> bool
	        

ida_funcs.func_item_iterator_t.prev_not_tail():
	
	        prev_not_tail(self) -> bool
	        

ida_funcs.func_item_iterator_t.set():
	
	        set(self, pfn, _ea=BADADDR) -> bool
	        

ida_funcs.func_item_iterator_t.set_range():
	
	        set_range(self, ea1, ea2) -> bool
	        

ida_funcs.func_parent_iterator_set():
	
	  func_parent_iterator_set(fpi, pfn) -> bool
	  

class ida_funcs.func_parent_iterator_t():
	
	    Proxy of C++ func_parent_iterator_t class
	    

ida_funcs.func_parent_iterator_t.first():
	
	        first(self) -> bool
	        

ida_funcs.func_parent_iterator_t.last():
	
	        last(self) -> bool
	        

ida_funcs.func_parent_iterator_t.next():
	
	        next(self) -> bool
	        

ida_funcs.func_parent_iterator_t.parent():
	
	        parent(self) -> ea_t
	        

ida_funcs.func_parent_iterator_t.prev():
	
	        prev(self) -> bool
	        

ida_funcs.func_parent_iterator_t.reset_fnt():
	
	        reset_fnt(self, _fnt)
	        

ida_funcs.func_parent_iterator_t.set():
	
	        set(self, _fnt) -> bool
	        

class ida_funcs.func_t():
	
	    Proxy of C++ func_t class
	    

ida_funcs.func_t._print():
	
	        _print(self) -> size_t
	        

ida_funcs.func_t.analyzed_sp():
	
	        analyzed_sp(self) -> bool
	        

ida_funcs.func_t.argsize:
	func_t_argsize_get(self) -> asize_t

ida_funcs.func_t.clear():
	
	        clear(self)
	        

ida_funcs.func_t.color:
	func_t_color_get(self) -> bgcolor_t

ida_funcs.func_t.compare():
	
	        compare(self, r) -> int
	        

ida_funcs.func_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_funcs.func_t.does_return():
	
	        does_return(self) -> bool
	        

ida_funcs.func_t.empty():
	
	        empty(self) -> bool
	        

ida_funcs.func_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_funcs.func_t.extend():
	
	        extend(self, ea)
	        

ida_funcs.func_t.flags:
	func_t_flags_get(self) -> uint64

ida_funcs.func_t.fpd:
	func_t_fpd_get(self) -> asize_t

ida_funcs.func_t.frame:
	func_t_frame_get(self) -> uval_t

ida_funcs.func_t.frregs:
	func_t_frregs_get(self) -> ushort

ida_funcs.func_t.frsize:
	func_t_frsize_get(self) -> asize_t

ida_funcs.func_t.intersect():
	
	        intersect(self, r)
	        

ida_funcs.func_t.is_far():
	
	        is_far(self) -> bool
	        

ida_funcs.func_t.llabelqty:
	func_t_llabelqty_get(self) -> int

ida_funcs.func_t.llabels:
	func_t_llabels_get(self) -> llabel_t *

ida_funcs.func_t.need_prolog_analysis():
	
	        need_prolog_analysis(self) -> bool
	        

ida_funcs.func_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_funcs.func_t.owner:
	func_t_owner_get(self) -> ea_t

ida_funcs.func_t.pntqty:
	func_t_pntqty_get(self) -> uint32

ida_funcs.func_t.points:
	
	        __get_points__(self) -> stkpnt_array
	        

ida_funcs.func_t.referers:
	func_t_referers_get(self) -> ea_t *

ida_funcs.func_t.refqty:
	func_t_refqty_get(self) -> int

ida_funcs.func_t.regargqty:
	func_t_regargqty_get(self) -> int

ida_funcs.func_t.regargs:
	func_t_regargs_get(self) -> regarg_t

ida_funcs.func_t.regvarqty:
	func_t_regvarqty_get(self) -> int

ida_funcs.func_t.regvars:
	
	        __get_regvars__(self) -> regvar_array
	        

ida_funcs.func_t.size():
	
	        size(self) -> asize_t
	        

ida_funcs.func_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

ida_funcs.func_t.tailqty:
	func_t_tailqty_get(self) -> int

ida_funcs.func_t.tails:
	
	        __get_tails__(self) -> range_array
	        

ida_funcs.func_t__from_ptrval__():
	
	  func_t__from_ptrval__(ptrval) -> func_t
	  

ida_funcs.func_tail_iterator_set():
	
	  func_tail_iterator_set(fti, pfn, ea) -> bool
	  

ida_funcs.func_tail_iterator_set_ea():
	
	  func_tail_iterator_set_ea(fti, ea) -> bool
	  

class ida_funcs.func_tail_iterator_t():
	
	    Proxy of C++ func_tail_iterator_t class
	    

ida_funcs.func_tail_iterator_t.chunk():
	
	        chunk(self) -> range_t
	        

ida_funcs.func_tail_iterator_t.first():
	
	        first(self) -> bool
	        

ida_funcs.func_tail_iterator_t.last():
	
	        last(self) -> bool
	        

ida_funcs.func_tail_iterator_t.main():
	
	        main(self) -> bool
	        

ida_funcs.func_tail_iterator_t.next():
	
	        next(self) -> bool
	        

ida_funcs.func_tail_iterator_t.prev():
	
	        prev(self) -> bool
	        

ida_funcs.func_tail_iterator_t.set():
	
	        set(self, _pfn, ea=BADADDR) -> bool
	        

ida_funcs.func_tail_iterator_t.set_ea():
	
	        set_ea(self, ea) -> bool
	        

ida_funcs.func_tail_iterator_t.set_range():
	
	        set_range(self, ea1, ea2) -> bool
	        

ida_funcs.get_current_idasgn():
	
	  get_current_idasgn() -> int
	
	
	  Get number of the the current signature.
	  
	  @return: 0..n-1
	  

ida_funcs.get_fchunk():
	
	  get_fchunk(ea) -> func_t
	
	
	  Get pointer to function chunk structure by address.
	  
	  @param ea: any address in a function chunk (C++: ea_t)
	  @return: ptr to a function chunk or NULL. This function may return a
	           function entry as well as a function tail.
	  

ida_funcs.get_fchunk_num():
	
	  get_fchunk_num(ea) -> int
	
	
	  Get ordinal number of a function chunk in the global list of function
	  chunks.
	  
	  @param ea: any address in the function chunk (C++: ea_t)
	  @return: number of function chunk (0.. get_fchunk_qty() -1). -1 means
	           'no function chunk at the specified address'.
	  

ida_funcs.get_fchunk_qty():
	
	  get_fchunk_qty() -> size_t
	
	
	  Get total number of function chunks in the program.
	  

ida_funcs.get_fchunk_referer():
	
	  get_fchunk_referer(ea, idx) -> ea_t
	  

ida_funcs.get_func():
	
	  get_func(ea) -> func_t
	
	
	  Get pointer to function structure by address.
	  
	  @param ea: any address in a function (C++: ea_t)
	  @return: ptr to a function or NULL. This function returns a function
	           entry chunk.
	  

ida_funcs.get_func_bitness():
	
	  get_func_bitness(pfn) -> int
	
	
	  Get function bitness (which is equal to the function segment bitness).
	  pfn==NULL => returns 0
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_funcs.get_func_bits():
	
	  get_func_bits(pfn) -> int
	
	
	  Get number of bits in the function addressing.
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_funcs.get_func_bytes():
	
	  get_func_bytes(pfn) -> int
	
	
	  Get number of bytes in the function addressing.
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_funcs.get_func_chunknum():
	
	  get_func_chunknum(pfn, ea) -> int
	
	
	  Get the containing tail chunk of 'ea'.
	  
	  @param pfn (C++: func_t  *)
	  @param ea (C++: ea_t)
	  

ida_funcs.get_func_cmt():
	
	  get_func_cmt(pfn, repeatable) -> ssize_t
	
	
	  Get function comment.
	  
	  @param pfn: ptr to function structure (C++: const  func_t  *)
	  @param repeatable: get repeatable comment? (C++: bool)
	  @return: size of comment or -1 In fact this function works with
	           function chunks too.
	  

ida_funcs.get_func_name():
	
	  get_func_name(ea) -> ssize_t
	
	
	  Get function name.
	  
	  @param ea: any address in the function (C++: ea_t)
	  @return: length of the function name
	  

ida_funcs.get_func_num():
	
	  get_func_num(ea) -> int
	
	
	  Get ordinal number of a function.
	  
	  @param ea: any address in the function (C++: ea_t)
	  @return: number of function (0.. get_func_qty() -1). -1 means 'no
	           function at the specified address'.
	  

ida_funcs.get_func_qty():
	
	  get_func_qty() -> size_t
	
	
	  Get total number of functions in the program.
	  

ida_funcs.get_func_ranges():
	
	  get_func_ranges(ranges, pfn) -> ea_t
	
	
	  Get function ranges.
	  
	  @param ranges: buffer to receive the range info (C++: rangeset_t  *)
	  @param pfn: ptr to function structure (C++: func_t  *)
	  @return: end address of the last function range (BADADDR-error)
	  

ida_funcs.get_idasgn_desc():
	
	  get_idasgn_desc(n) -> PyObject *
	
	
	  Get information about a signature in the list.
	  It returns: (name of signature, names of optional libraries)
	  
	  See also: get_idasgn_desc_with_matches
	  
	  @param n: number of signature in the list (0..get_idasgn_qty()-1)
	  @return: None on failure or tuple(signame, optlibs)
	  

ida_funcs.get_idasgn_desc_with_matches():
	
	  get_idasgn_desc_with_matches(n) -> PyObject *
	
	
	  Get information about a signature in the list.
	  It returns: (name of signature, names of optional libraries, number of matches)
	  
	  @param n: number of signature in the list (0..get_idasgn_qty()-1)
	  @return: None on failure or tuple(signame, optlibs, nmatches)
	  

ida_funcs.get_idasgn_qty():
	
	  get_idasgn_qty() -> int
	
	
	  Get number of signatures in the list of planned and applied
	  signatures.
	  
	  @return: 0..n
	  

ida_funcs.get_idasgn_title():
	
	  get_idasgn_title(name) -> ssize_t
	
	
	  Get full description of the signature by its short name.
	  
	  @param name: short name of a signature (C++: const char *)
	  @return: size of signature description or -1
	  

ida_funcs.get_next_fchunk():
	
	  get_next_fchunk(ea) -> func_t
	
	
	  Get pointer to the next function chunk in the global list.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: ptr to function chunk or NULL if next function chunk doesn't
	           exist
	  

ida_funcs.get_next_func():
	
	  get_next_func(ea) -> func_t
	
	
	  Get pointer to the next function.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: ptr to function or NULL if next function doesn't exist
	  

ida_funcs.get_next_func_addr():
	
	  get_next_func_addr(pfn, ea) -> ea_t
	  

ida_funcs.get_prev_fchunk():
	
	  get_prev_fchunk(ea) -> func_t
	
	
	  Get pointer to the previous function chunk in the global list.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: ptr to function chunk or NULL if previous function chunk
	           doesn't exist
	  

ida_funcs.get_prev_func():
	
	  get_prev_func(ea) -> func_t
	
	
	  Get pointer to the previous function.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: ptr to function or NULL if previous function doesn't exist
	  

ida_funcs.get_prev_func_addr():
	
	  get_prev_func_addr(pfn, ea) -> ea_t
	  

ida_funcs.getn_fchunk():
	
	  getn_fchunk(n) -> func_t
	
	
	  Get pointer to function chunk structure by number.
	  
	  @param n: number of function chunk, is in range 0.. get_fchunk_qty()
	            -1 (C++: int)
	  @return: ptr to a function chunk or NULL. This function may return a
	           function entry as well as a function tail.
	  

ida_funcs.getn_func():
	
	  getn_func(n) -> func_t
	
	
	  Get pointer to function structure by number.
	  
	  @param n: number of function, is in range 0.. get_func_qty() -1 (C++:
	            size_t)
	  @return: ptr to a function or NULL. This function returns a function
	           entry chunk.
	  

ida_funcs.is_finally_visible_func():
	
	  is_finally_visible_func(pfn) -> bool
	
	
	  Is the function visible (event after considering 'SW_SHHID_FUNC' )?
	  
	  
	  @param pfn (C++: func_t  *)
	  

ida_funcs.is_func_entry():
	
	  is_func_entry(pfn) -> bool
	
	
	  Does function describe a function entry chunk?
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_funcs.is_func_locked():
	
	  is_func_locked(pfn) -> bool
	
	
	  Is the function pointer locked?
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_funcs.is_func_tail():
	
	  is_func_tail(pfn) -> bool
	
	
	  Does function describe a function tail chunk?
	  
	  
	  @param pfn (C++: const  func_t  *)
	  

ida_funcs.is_same_func():
	
	  is_same_func(ea1, ea2) -> bool
	
	
	  Do two addresses belong to the same function?
	  
	  
	  @param ea1 (C++: ea_t)
	  @param ea2 (C++: ea_t)
	  

ida_funcs.is_visible_func():
	
	  is_visible_func(pfn) -> bool
	
	
	  Is the function visible (not hidden)?
	  
	  
	  @param pfn (C++: func_t  *)
	  

class ida_funcs.lock_func():
	
	    Proxy of C++ lock_func class
	    

ida_funcs.lock_func_range():
	
	  lock_func_range(pfn, lock)
	
	
	  Lock function pointer Locked pointers are guaranteed to remain valid
	  until they are unlocked. Ranges with locked pointers can not be
	  deleted or moved.
	  
	  @param pfn (C++: const  func_t  *)
	  @param lock (C++: bool)
	  

ida_funcs.plan_to_apply_idasgn():
	
	  plan_to_apply_idasgn(fname) -> int
	
	
	  Add a signature file to the list of planned signature files.
	  
	  @param fname: file name. should not contain directory part. (C++:
	                const char *)
	  @return: 0 if failed, otherwise number of planned (and applied)
	           signatures
	  

class ida_funcs.range_array():
	
	    Proxy of C++ dynamic_wrapped_array_t<(range_t)> class
	    

ida_funcs.range_array.count:
	range_array_count_get(self) -> size_t

ida_funcs.range_array.data:
	range_array_data_get(self) -> range_t

ida_funcs.read_regargs():
	
	  read_regargs(pfn)
	  

ida_funcs.reanalyze_function():
	
	  reanalyze_function(pfn, ea1=0, ea2=BADADDR, analyze_parents=False)
	
	
	  Reanalyze a function. This function analyzes all chunks of the given
	  function. Optional parameters (ea1, ea2) may be used to narrow the
	  analyzed range.
	  
	  @param pfn: pointer to a function (C++: func_t  *)
	  @param ea1: start of the range to analyze (C++: ea_t)
	  @param ea2: end of range to analyze (C++: ea_t)
	  @param analyze_parents: meaningful only if pfn points to a function
	                          tail. if true, all tail parents will be
	                          reanalyzed. if false, only the given tail will
	                          be reanalyzed. (C++: bool)
	  

ida_funcs.reanalyze_noret_flag():
	
	  reanalyze_noret_flag(ea) -> bool
	
	
	  Plan to reanalyze noret flag. This function does not remove FUNC_NORET
	  if it is already present. It just plans to reanalysis.
	  
	  @param ea (C++: ea_t)
	  

class ida_funcs.regarg_t():
	
	    Proxy of C++ regarg_t class
	    

ida_funcs.regarg_t.name:
	regarg_t_name_get(self) -> char *

ida_funcs.regarg_t.reg:
	regarg_t_reg_get(self) -> int

ida_funcs.regarg_t.type:
	regarg_t_type_get(self) -> type_t *

class ida_funcs.regvar_array():
	
	    Proxy of C++ dynamic_wrapped_array_t<(regvar_t)> class
	    

ida_funcs.regvar_array.count:
	regvar_array_count_get(self) -> size_t

ida_funcs.regvar_array.data:
	regvar_array_data_get(self) -> regvar_t *

ida_funcs.remove_func_tail():
	
	  remove_func_tail(pfn, tail_ea) -> bool
	
	
	  Remove a function tail. If the tail belongs only to one function, it
	  will be completely removed. Otherwise if the function was the tail
	  owner, the first function using this tail becomes the owner of the
	  tail.
	  
	  @param pfn (C++: func_t  *)
	  @param tail_ea (C++: ea_t)
	  

ida_funcs.set_func_cmt():
	
	  set_func_cmt(pfn, cmt, repeatable) -> bool
	
	
	  Set function comment. This function works with function chunks too.
	  
	  @param pfn: ptr to function structure (C++: const  func_t  *)
	  @param cmt: comment string, may be multiline (with '  '). Use empty
	              str ("") to delete comment (C++: const char *)
	  @param repeatable: set repeatable comment? (C++: bool)
	  

ida_funcs.set_func_end():
	
	  set_func_end(ea, newend) -> bool
	
	
	  Move function chunk end address.
	  
	  @param ea: any address in the function (C++: ea_t)
	  @param newend: new end address of the function (C++: ea_t)
	  @return: success
	  

ida_funcs.set_func_name_if_jumpfunc():
	
	  set_func_name_if_jumpfunc(pfn, oldname) -> int
	
	
	  Give a meaningful name to function if it consists of only 'jump'
	  instruction.
	  
	  @param pfn: pointer to function (may be NULL) (C++: func_t  *)
	  @param oldname: old name of function. if old name was in "j_..." form,
	                  then we may discard it and set a new name. if oldname
	                  is not known, you may pass NULL. (C++: const char *)
	  @return: success
	  

ida_funcs.set_func_start():
	
	  set_func_start(ea, newstart) -> int
	
	
	  Move function chunk start address.
	  
	  @param ea: any address in the function (C++: ea_t)
	  @param newstart: new end address of the function (C++: ea_t)
	  @return: Function move result codes
	  

ida_funcs.set_noret_insn():
	
	  set_noret_insn(insn_ea, noret) -> bool
	
	
	  Signal a non-returning instruction. This function can be used by the
	  processor module to tell the kernel about non-returning instructions
	  (like call exit). The kernel will perform the global function analysis
	  and find out if the function returns at all. This analysis will be
	  done at the first call to 'func_does_return()'
	  
	  @param insn_ea (C++: ea_t)
	  @param noret (C++: bool)
	  @return: true if the instruction 'noret' flag has been changed
	  

ida_funcs.set_tail_owner():
	
	  set_tail_owner(fnt, func_start) -> bool
	
	
	  Set a function as the possessing function of a function tail. The
	  function should already refer to the tail (after append_func_tail).
	  
	  @param fnt (C++: func_t  *)
	  @param func_start (C++: ea_t)
	  

ida_funcs.set_visible_func():
	
	  set_visible_func(pfn, visible)
	
	
	  Set visibility of function.
	  
	  
	  @param pfn (C++: func_t  *)
	  @param visible (C++: bool)
	  

class ida_funcs.stkpnt_array():
	
	    Proxy of C++ dynamic_wrapped_array_t<(stkpnt_t)> class
	    

ida_funcs.stkpnt_array.count:
	stkpnt_array_count_get(self) -> size_t

ida_funcs.stkpnt_array.data:
	stkpnt_array_data_get(self) -> stkpnt_t *

ida_funcs.try_to_add_libfunc():
	
	  try_to_add_libfunc(ea) -> int
	
	
	  Apply the currently loaded signature file to the specified address. If
	  a library function is found, then create a function and name it
	  accordingly.
	  
	  @param ea: any address in the program (C++: ea_t)
	  @return: Library function codes
	  

ida_funcs.update_func():
	
	  update_func(pfn) -> bool
	
	
	  Update information about a function in the database ( 'func_t' ). You
	  must not change the function start and end addresses using this
	  function. Use 'set_func_start()' and 'set_func_end()' for it.
	  
	  @param pfn: ptr to function structure (C++: func_t  *)
	  @return: success
	  


=== ida_funcs EPYDOC INJECTIONS ===
ida_funcs.FIND_FUNC_DEFINE
"""
create instruction if undefined byte is encountered
"""

ida_funcs.FIND_FUNC_EXIST
"""
its bounds are returned in 'nfn'.

function exists already.
"""

ida_funcs.FIND_FUNC_IGNOREFN
"""
ignore existing function boundaries. by default the function returns
function boundaries if ea belongs to a function.
"""

ida_funcs.FIND_FUNC_KEEPBD
"""
just create instructions inside the boundaries.

do not modify incoming function boundaries,
"""

ida_funcs.FIND_FUNC_NORMAL
"""
stop processing if undefined byte is encountered
"""

ida_funcs.FIND_FUNC_OK
"""
ok, 'nfn' is ready for 'add_func()'
"""

ida_funcs.FIND_FUNC_UNDEF
"""
nfn->end_ea will have the address of the unexplored byte.

function has instructions that pass execution flow to unexplored
bytes.
"""

ida_funcs.FUNC_BOTTOMBP
"""
BP points to the bottom of the stack frame.
"""

ida_funcs.FUNC_FAR
"""
Far function.
"""

ida_funcs.FUNC_FRAME
"""
Function uses frame pointer (BP)
"""

ida_funcs.FUNC_FUZZY_SP
"""
for example: and esp, 0FFFFFFF0h

Function changes SP in untraceable way,
"""

ida_funcs.FUNC_HIDDEN
"""
A hidden function chunk.
"""

ida_funcs.FUNC_LIB
"""
Library function.
"""

ida_funcs.FUNC_LUMINA
"""
Function info is provided by Lumina.
"""

ida_funcs.FUNC_NORET
"""
Function doesn't return.
"""

ida_funcs.FUNC_NORET_PENDING
"""
This flag is verified upon 'func_does_return()'

Function 'non-return' analysis must be performed.
"""

ida_funcs.FUNC_PROLOG_OK
"""
by last SP-analysis

Prolog analysis has be performed
"""

ida_funcs.FUNC_PURGED_OK
"""
'argsize' field has been validated. If this bit is clear and 'argsize'
is 0, then we do not known the real number of bytes removed from the
stack. This bit is handled by the processor module.
"""

ida_funcs.FUNC_SP_READY
"""
SP-analysis has been performed. If this flag is on, the stack change
points should not be not modified anymore. Currently this analysis is
performed only for PC
"""

ida_funcs.FUNC_STATICDEF
"""
Static function.
"""

ida_funcs.FUNC_TAIL
"""
This is a function tail. Other bits must be clear (except
'FUNC_HIDDEN' ).
"""

ida_funcs.FUNC_THUNK
"""
Thunk (jump) function.
"""

ida_funcs.FUNC_USERFAR
"""
of the function

User has specified far-ness
"""

ida_funcs.IDASGN_APPLIED
"""
signature is already applied
"""

ida_funcs.IDASGN_BADARG
"""
bad number of signature
"""

ida_funcs.IDASGN_CURRENT
"""
signature is currently being applied
"""

ida_funcs.IDASGN_OK
"""
ok
"""

ida_funcs.IDASGN_PLANNED
"""
signature is planned to be applied
"""

ida_funcs.LIBFUNC_DELAY
"""
no decision because of lack of information
"""

ida_funcs.LIBFUNC_FOUND
"""
ok, library function is found
"""

ida_funcs.LIBFUNC_NONE
"""
no, this is not a library function
"""

ida_funcs.MOVE_FUNC_BADSTART
"""
bad new start address
"""

ida_funcs.MOVE_FUNC_NOCODE
"""
no instruction at 'newstart'
"""

ida_funcs.MOVE_FUNC_NOFUNC
"""
no function at 'ea'
"""

ida_funcs.MOVE_FUNC_OK
"""
ok
"""

ida_funcs.MOVE_FUNC_REFUSED
"""
a plugin refused the action
"""
=== ida_funcs EPYDOC INJECTIONS END ===
class ida_gdl.BasicBlock():
	
	    Basic block class. It is returned by the Flowchart class
	    

ida_gdl.BasicBlock.preds():
	
	        Iterates the predecessors list
	        

ida_gdl.BasicBlock.succs():
	
	        Iterates the successors list
	        

class ida_gdl.FlowChart():
	
	    Flowchart class used to determine basic blocks.
	    Check ex_gdl_qflow_chart.py for sample usage.
	    

ida_gdl.FlowChart.refresh():
	
	        Refreshes the flow chart
	        

ida_gdl.display_gdl():
	
	  display_gdl(fname) -> int
	
	
	  Display GDL file by calling wingraph32. The exact name of the grapher
	  is taken from the configuration file and set up by
	  'setup_graph_subsystem()' .
	  
	  @param fname (C++: const char *)
	  @return: error code from os, 0 if ok
	  

ida_gdl.gen_complex_call_chart():
	
	  gen_complex_call_chart(filename, wait, title, ea1, ea2, flags, recursion_depth=-1) -> bool
	
	
	  Build and display a complex xref graph.
	  
	  @param filename: output file name. the file extension is not used.
	                   maybe NULL. (C++: const char *)
	  @param wait: message to display during graph building (C++: const char
	               *)
	  @param title: graph title (C++: const char *)
	  @param ea1: address range (C++: ea_t)
	  @param ea2: address range (C++: ea_t)
	  @param flags: combination of  Call chart building flags  and  Flow
	                graph building flags . if none of  CHART_GEN_DOT ,
	                CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
	                function will return false. (C++: int)
	  @param recursion_depth: optional limit of recursion (C++: int32)
	  @return: success. if fails, a warning message is displayed on the
	           screen
	  

ida_gdl.gen_flow_graph():
	
	  gen_flow_graph(filename, title, pfn, ea1, ea2, gflags) -> bool
	
	
	  Build and display a flow graph.
	  
	  @param filename: output file name. the file extension is not used.
	                   maybe NULL. (C++: const char *)
	  @param title: graph title (C++: const char *)
	  @param pfn: function to graph (C++: func_t  *)
	  @param ea1: if pfn == NULL, then the address range (C++: ea_t)
	  @param ea2: if pfn == NULL, then the address range (C++: ea_t)
	  @param gflags: combination of  Flow graph building flags . if none of
	                 CHART_GEN_DOT ,  CHART_GEN_GDL ,  CHART_WINGRAPH  is
	                 specified, the function will return false (C++: int)
	  @return: success. if fails, a warning message is displayed on the
	           screen
	  

ida_gdl.gen_gdl():
	
	  gen_gdl(g, fname)
	
	
	  Create GDL file for graph.
	  
	  
	  @param g (C++: const  gdl_graph_t  *)
	  @param fname (C++: const char *)
	  

ida_gdl.gen_simple_call_chart():
	
	  gen_simple_call_chart(filename, wait, title, gflags) -> bool
	
	
	  Build and display a simple function call graph.
	  
	  @param filename: output file name. the file extension is not used.
	                   maybe NULL. (C++: const char *)
	  @param wait: message to display during graph building (C++: const char
	               *)
	  @param title: graph title (C++: const char *)
	  @param gflags: combination of  CHART_NOLIBFUNCS  and  Flow graph
	                 building flags . if none of  CHART_GEN_DOT ,
	                 CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
	                 function will return false. (C++: int)
	  @return: success. if fails, a warning message is displayed on the
	           screen
	  

ida_gdl.is_noret_block():
	
	  is_noret_block(btype) -> bool
	
	
	  Does this block never return?
	  
	  
	  @param btype (C++: fc_block_type_t)
	  

ida_gdl.is_ret_block():
	
	  is_ret_block(btype) -> bool
	
	
	  Does this block return?
	  
	  
	  @param btype (C++: fc_block_type_t)
	  

class ida_gdl.node_iterator():
	
	    Proxy of C++ node_iterator class
	    

class ida_gdl.qbasic_block_t():
	
	    Proxy of C++ qbasic_block_t class
	    

ida_gdl.qbasic_block_t._print():
	
	        _print(self) -> size_t
	        

ida_gdl.qbasic_block_t.clear():
	
	        clear(self)
	        

ida_gdl.qbasic_block_t.compare():
	
	        compare(self, r) -> int
	        

ida_gdl.qbasic_block_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_gdl.qbasic_block_t.empty():
	
	        empty(self) -> bool
	        

ida_gdl.qbasic_block_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_gdl.qbasic_block_t.extend():
	
	        extend(self, ea)
	        

ida_gdl.qbasic_block_t.intersect():
	
	        intersect(self, r)
	        

ida_gdl.qbasic_block_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_gdl.qbasic_block_t.size():
	
	        size(self) -> asize_t
	        

ida_gdl.qbasic_block_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

class ida_gdl.qflow_chart_t():
	
	    Proxy of C++ qflow_chart_t class
	    

ida_gdl.qflow_chart_t.append_to_flowchart():
	
	        append_to_flowchart(self, ea1, ea2)
	        

ida_gdl.qflow_chart_t.bounds:
	qflow_chart_t_bounds_get(self) -> range_t

ida_gdl.qflow_chart_t.calc_block_type():
	
	        calc_block_type(self, blknum) -> fc_block_type_t
	        

ida_gdl.qflow_chart_t.create():
	
	        create(self, _title, _pfn, _ea1, _ea2, _flags)
	        create(self, _title, ranges, _flags)
	        

ida_gdl.qflow_chart_t.flags:
	qflow_chart_t_flags_get(self) -> int

ida_gdl.qflow_chart_t.get_node_label():
	
	        get_node_label(self, arg2, arg3, arg4) -> char *
	        

ida_gdl.qflow_chart_t.is_noret_block():
	
	        is_noret_block(self, blknum) -> bool
	        

ida_gdl.qflow_chart_t.is_ret_block():
	
	        is_ret_block(self, blknum) -> bool
	        

ida_gdl.qflow_chart_t.npred():
	
	        npred(self, node) -> int
	        

ida_gdl.qflow_chart_t.nproper:
	qflow_chart_t_nproper_get(self) -> int

ida_gdl.qflow_chart_t.nsucc():
	
	        nsucc(self, node) -> int
	        

ida_gdl.qflow_chart_t.pfn:
	qflow_chart_t_pfn_get(self) -> func_t *

ida_gdl.qflow_chart_t.pred():
	
	        pred(self, node, i) -> int
	        

ida_gdl.qflow_chart_t.print_names():
	
	        print_names(self) -> bool
	        

ida_gdl.qflow_chart_t.print_node_attributes():
	
	        print_node_attributes(self, arg2, arg3)
	        

ida_gdl.qflow_chart_t.refresh():
	
	        refresh(self)
	        

ida_gdl.qflow_chart_t.size():
	
	        size(self) -> int
	        

ida_gdl.qflow_chart_t.succ():
	
	        succ(self, node, i) -> int
	        

ida_gdl.qflow_chart_t.title:
	qflow_chart_t_title_get(self) -> qstring *


=== ida_gdl EPYDOC INJECTIONS ===
ida_gdl.CHART_FOLLOW_DIRECTION
"""
analyze references to added blocks only in the direction of the
reference who discovered the current block
"""

ida_gdl.CHART_GEN_DOT
"""
generate .dot file (file extension is forced to .dot)
"""

ida_gdl.CHART_GEN_GDL
"""
generate .gdl file (file extension is forced to .gdl)
"""

ida_gdl.CHART_IGNORE_LIB_FROM
"""
ignore references from library functions
"""

ida_gdl.CHART_IGNORE_LIB_TO
"""
ignore references to library functions
"""

ida_gdl.CHART_NOLIBFUNCS
"""
don't include library functions in the graph
"""

ida_gdl.CHART_PRINT_DOTS
"""
print dots if xrefs exist outside of the range recursion depth
"""

ida_gdl.CHART_PRINT_NAMES
"""
print labels for each block?
"""

ida_gdl.CHART_RECURSIVE
"""
analyze added blocks
"""

ida_gdl.CHART_REFERENCED
"""
references from the addresses in the list
"""

ida_gdl.CHART_REFERENCING
"""
references to the addresses in the list
"""

ida_gdl.CHART_WINGRAPH
"""
call grapher to display the graph
"""

ida_gdl.FC_APPND
"""
multirange flowchart (set by append_to_flowchart)
"""

ida_gdl.FC_CHKBREAK
"""
build_qflow_chart() may be aborted by user
"""

ida_gdl.FC_NOEXT
"""
do not compute external blocks. Use this to prevent jumps leaving the
function from appearing in the flow chart. Unless specified, the
targets of those outgoing jumps will be present in the flow chart
under the form of one-instruction blocks
"""

ida_gdl.FC_PREDS
"""
compute predecessor lists
"""

ida_gdl.FC_PRINT
"""
print names (used only by display_flow_chart())
"""
=== ida_gdl EPYDOC INJECTIONS END ===
ida_graph.GraphViewer.AddEdge():
	
	        Creates an edge between two given node ids
	        

ida_graph.GraphViewer.AddNode():
	
	        Creates a node associated with the given object and returns the node id
	        

ida_graph.GraphViewer.Clear():
	
	        Clears all the nodes and edges
	        

ida_graph.GraphViewer.Close():
	
	        Closes the graph.
	        It is possible to call Show() again (which will recreate the graph)
	        

ida_graph.GraphViewer.Count():
	
	        Returns the node count
	        

ida_graph.GraphViewer.CreateGroups():
	
	        Send a request to modify the graph by creating a
	        (set of) group(s), and perform an animation.
	
	        Each object in the 'groups_infos' list must be of the format:
	        {
	          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
	          "text" : <string>                    # The synthetic text for that group
	        }
	
	        @param groups_infos: A list of objects that describe those groups.
	        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
	        

ida_graph.GraphViewer.DelNodesInfos():
	
	        Delete the properties for the given node(s).
	
	        @param nodes: A list of node IDs
	        

ida_graph.GraphViewer.DeleteGroups():
	
	        Send a request to delete the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param new_current: A node to focus on after the groups have been deleted
	        @return: True on success, False otherwise.
	        

ida_graph.GraphViewer.GetNodeInfo():
	
	        Get the properties for the given node.
	
	        @param node: The index of the node.
	        @return: A tuple (bg_color, frame_color, ea, text), or None.
	        

ida_graph.GraphViewer.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_graph.GraphViewer.OnRefresh():
	
	        Event called when the graph is refreshed or first created.
	        From this event you are supposed to create nodes and edges.
	        This callback is mandatory.
	
	        @note: ***It is important to clear previous nodes before adding nodes.***
	        @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
	        

ida_graph.GraphViewer.Refresh():
	
	        Refreshes the view. This causes the OnRefresh() to be called
	        

ida_graph.GraphViewer.Select():
	
	        Selects a node on the graph
	        

ida_graph.GraphViewer.SetCurrentRendererType():
	
	        Set the current view's renderer.
	
	        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
	        

ida_graph.GraphViewer.SetGroupsVisibility():
	
	        Send a request to expand/collapse the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param expand: True to expand the group, False otherwise.
	        @param new_current: A node to focus on after the groups have been expanded/collapsed.
	        @return: True on success, False otherwise.
	        

ida_graph.GraphViewer.SetNodeInfo():
	
	        Set the properties for the given node.
	
	        Example usage (set second nodes's bg color to red):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff0000
	          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
	
	        @param node_index: The node index.
	        @param node_info: An idaapi.node_info_t instance.
	        @param flags: An OR'ed value of NIF_* values.
	        

ida_graph.GraphViewer.SetNodesInfos():
	
	        Set the properties for the given nodes.
	
	        Example usage (set first three nodes's bg color to purple):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff00ff
	          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
	
	        @param values: A dictionary of 'int -> node_info_t' objects.
	        

ida_graph.GraphViewer.Show():
	
	        Shows an existing graph or creates a new one
	
	        @return: Boolean
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.create_desktop_widget():
	
	        create_desktop_widget(self, title, cfg) -> PyObject *
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.current_widget_changed():
	
	        current_widget_changed(self, widget, prev_widget)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.database_inited():
	
	        database_inited(self, is_new_database, idc_script)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.debugger_menu_change():
	
	        debugger_menu_change(self, enable) -> int
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.finish_populating_widget_popup():
	
	        finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
	
	
	        The UI is about to be done populating the TWidget's popup menu.
	        Now is a good time to call idaapi.attach_action_to_popup()
	        
	        @param widget: The widget
	        @param popup: The popup menu.
	        @return: Ignored
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.get_chooser_item_attrs():
	
	        get_chooser_item_attrs(self, chooser, n, attrs)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.get_custom_viewer_hint():
	
	        get_custom_viewer_hint(self, viewer, place) -> PyObject *
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.get_ea_hint():
	
	        get_ea_hint(self, ea) -> PyObject *
	
	
	        The UI wants to display a simple hint for an address in the navigation band
	        
	        @param ea: The address
	        @return: String with the hint or None
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.get_item_hint():
	
	        get_item_hint(self, ea, max_lines) -> PyObject *
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.hook():
	
	        hook(self) -> bool
	
	
	        Creates an UI hook
	        
	        @return: Boolean true on success
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.idcstart():
	
	        idcstart(self)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.idcstop():
	
	        idcstop(self)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.plugin_loaded():
	
	        plugin_loaded(self, plugin_info)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.plugin_unloading():
	
	        plugin_unloading(self, plugin_info)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.postprocess_action():
	
	        postprocess_action(self)
	
	
	        An ida ui action has been handled
	        
	        @return: Ignored
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.preprocess_action():
	
	        preprocess_action(self, name)
	
	
	        IDA ui is about to handle a user action
	        
	        @param name: ui action name
	                     (these names can be looked up in ida[tg]ui.cfg)
	        @return: 0-ok, nonzero - a plugin has handled the action
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.range():
	
	        range(self)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.ready_to_run():
	
	        ready_to_run(self)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.resume():
	
	        resume(self)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.saved():
	
	        saved(self)
	
	
	        The kernel has saved the database.
	        
	        @return: Ignored
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.saving():
	
	        saving(self)
	
	
	        The kernel is saving the database.
	        
	        @return: Ignored
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.screen_ea_changed():
	
	        screen_ea_changed(self, ea, prev_ea)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.suspend():
	
	        suspend(self)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.term():
	
	        term(self)
	
	
	        IDA is terminated and the database is already closed.
	        The UI may close its windows in this callback.
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.unhook():
	
	        unhook(self) -> bool
	
	
	        Removes the UI hook
	        @return: Boolean true on success
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.updated_actions():
	
	        updated_actions(self)
	
	
	        The UI is done updating actions.
	        
	        @return: Ignored
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.updating_actions():
	
	        updating_actions(self, ctx)
	
	
	        The UI is about to batch-update some actions.
	        
	        @param ctx: The action_update_ctx_t instance
	        @return: Ignored
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.widget_closing():
	
	        widget_closing(self, widget)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.widget_invisible():
	
	        widget_invisible(self, widget)
	        

ida_graph.GraphViewer.UI_Hooks_Trampoline.widget_visible():
	
	        widget_visible(self, widget)
	        

ida_graph.GraphViewer.hook():
	
	        hook(self) -> bool
	        

ida_graph.GraphViewer.unhook():
	
	        unhook(self) -> bool
	        

ida_graph.GraphViewer.view_created():
	
	        view_created(self, view)
	        

class ida_graph.TPointDouble():
	
	    Proxy of C++ TPointDouble class
	    

ida_graph.TPointDouble.add():
	
	        add(self, r)
	        

ida_graph.TPointDouble.negate():
	
	        negate(self)
	        

ida_graph.TPointDouble.sub():
	
	        sub(self, r)
	        

ida_graph.TPointDouble.x:
	TPointDouble_x_get(self) -> double

ida_graph.TPointDouble.y:
	TPointDouble_y_get(self) -> double

ida_graph.calc_dist():
	
	  calc_dist(p, q) -> double
	
	
	  Calculate distance between p and q.
	  
	  
	  @param p (C++: point_t)
	  @param q (C++: point_t)
	  

ida_graph.clr_node_info():
	
	  clr_node_info(gid, node, flags)
	
	
	  Clear node info for the given node.
	  
	  @param gid: id of desired graph (C++: graph_id_t)
	  @param node: node number (C++: int)
	  @param flags: combination of  Node info flags , identifying which
	                fields of  node_info_t  will be cleared (C++: uint32)
	  

ida_graph.create_disasm_graph():
	
	    create_disasm_graph(ea) -> mutable_graph_t
	    create_disasm_graph(ranges) -> mutable_graph_t
	
	
	  Create a graph for the function that contains 'ea'.
	  
	  
	  @param ea (C++: ea_t)
	    

ida_graph.create_graph_viewer():
	
	  create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *
	
	
	  Create a custom graph viewer.
	  
	  @param title: the widget title (C++: const char *)
	  @param id: graph id (C++: uval_t)
	  @param callback: callback to handle graph notifications (
	                   graph_notification_t ) (C++: hook_cb_t  *)
	  @param ud: user data passed to callback (C++: void *)
	  @param title_height: node title height (C++: int)
	  @param parent (C++: TWidget *)
	  @return: new viewer
	  

ida_graph.create_mutable_graph():
	
	  create_mutable_graph(id) -> mutable_graph_t
	
	
	  Create a new empty graph with given id.
	  
	  
	  @param id (C++: uval_t)
	  

ida_graph.create_user_graph_place():
	
	  create_user_graph_place(node, lnnum) -> user_graph_place_t
	
	
	  Get a copy of a 'user_graph_place_t' (returns a pointer to static
	  storage)
	  
	  
	  @param node (C++: int)
	  @param lnnum (C++: int)
	  

ida_graph.del_node_info():
	
	  del_node_info(gid, node)
	
	
	  Delete the 'node_info_t' for the given node.
	  
	  
	  @param gid (C++: graph_id_t)
	  @param node (C++: int)
	  

ida_graph.delete_mutable_graph():
	
	  delete_mutable_graph(g)
	
	
	  Delete graph object.use this only if you are dealing with
	  'mutable_graph_t' instances that have not been used together with a
	  'graph_viewer_t' . If you have called 'set_viewer_graph()' with your
	  graph, the graph's lifecycle will be managed by the viewer, and you
	  shouldn't interfere with it
	  
	  @param g (C++: mutable_graph_t  *)
	  

class ida_graph.edge_info_t():
	
	    Proxy of C++ edge_info_t class
	    

ida_graph.edge_info_t.color:
	edge_info_t_color_get(self) -> int

ida_graph.edge_info_t.dstoff:
	edge_info_t_dstoff_get(self) -> int

ida_graph.edge_info_t.layout:
	edge_info_t_layout_get(self) -> pointseq_t

ida_graph.edge_info_t.reverse_layout():
	
	        reverse_layout(self)
	        

ida_graph.edge_info_t.srcoff:
	edge_info_t_srcoff_get(self) -> int

ida_graph.edge_info_t.width:
	edge_info_t_width_get(self) -> int

class ida_graph.edge_infos_wrapper_t():
	
	    Proxy of C++ edge_infos_wrapper_t class
	    

ida_graph.edge_infos_wrapper_t.clear():
	
	        clear(self)
	        

ida_graph.edge_infos_wrapper_t.ptr:
	edge_infos_wrapper_t_ptr_get(self) -> edge_infos_t *

class ida_graph.edge_layout_point_t():
	
	    Proxy of C++ edge_layout_point_t class
	    

ida_graph.edge_layout_point_t.compare():
	
	        compare(self, r) -> int
	        

ida_graph.edge_layout_point_t.e:
	edge_layout_point_t_e_get(self) -> edge_t

ida_graph.edge_layout_point_t.pidx:
	edge_layout_point_t_pidx_get(self) -> int

class ida_graph.edge_segment_t():
	
	    Proxy of C++ edge_segment_t class
	    

ida_graph.edge_segment_t.e:
	edge_segment_t_e_get(self) -> edge_t

ida_graph.edge_segment_t.length():
	
	        length(self) -> size_t
	        

ida_graph.edge_segment_t.nseg:
	edge_segment_t_nseg_get(self) -> int

ida_graph.edge_segment_t.toright():
	
	        toright(self) -> bool
	        

ida_graph.edge_segment_t.x0:
	edge_segment_t_x0_get(self) -> int

ida_graph.edge_segment_t.x1:
	edge_segment_t_x1_get(self) -> int

class ida_graph.edge_t():
	
	    Proxy of C++ edge_t class
	    

ida_graph.edge_t.dst:
	edge_t_dst_get(self) -> int

ida_graph.edge_t.src:
	edge_t_src_get(self) -> int

ida_graph.get_graph_viewer():
	
	  get_graph_viewer(parent) -> graph_viewer_t *
	
	
	  Get custom graph viewer for given form.
	  
	  
	  @param parent (C++: TWidget *)
	  

ida_graph.get_node_info():
	
	  get_node_info(out, gid, node) -> bool
	
	
	  Get node info.
	  
	  @param out: result (C++: node_info_t  *)
	  @param gid: id of desired graph (C++: graph_id_t)
	  @param node: node number (C++: int)
	  @return: success
	  

ida_graph.get_viewer_graph():
	
	  get_viewer_graph(gv) -> mutable_graph_t
	
	
	  Get graph object for given custom graph viewer.
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  

class ida_graph.graph_item_t():
	
	    Proxy of C++ graph_item_t class
	    

ida_graph.graph_item_t.b:
	graph_item_t_b_get(self) -> int

ida_graph.graph_item_t.e:
	graph_item_t_e_get(self) -> edge_t

ida_graph.graph_item_t.elp:
	graph_item_t_elp_get(self) -> edge_layout_point_t

ida_graph.graph_item_t.is_edge():
	
	        is_edge(self) -> bool
	        

ida_graph.graph_item_t.is_node():
	
	        is_node(self) -> bool
	        

ida_graph.graph_item_t.n:
	graph_item_t_n_get(self) -> int

ida_graph.graph_item_t.p:
	graph_item_t_p_get(self) -> point_t

ida_graph.graph_item_t.type:
	graph_item_t_type_get(self) -> graph_item_type_t

class ida_graph.graph_node_visitor_t():
	
	    Proxy of C++ graph_node_visitor_t class
	    

ida_graph.graph_node_visitor_t.is_forbidden_edge():
	
	        is_forbidden_edge(self, arg0, arg1) -> bool
	        

ida_graph.graph_node_visitor_t.is_visited():
	
	        is_visited(self, n) -> bool
	        

ida_graph.graph_node_visitor_t.reinit():
	
	        reinit(self)
	        

ida_graph.graph_node_visitor_t.set_visited():
	
	        set_visited(self, n)
	        

ida_graph.graph_node_visitor_t.visit_node():
	
	        visit_node(self, arg0) -> int
	        

class ida_graph.graph_path_visitor_t():
	
	    Proxy of C++ graph_path_visitor_t class
	    

ida_graph.graph_path_visitor_t.path:
	graph_path_visitor_t_path_get(self) -> intvec_t *

ida_graph.graph_path_visitor_t.prune:
	graph_path_visitor_t_prune_get(self) -> bool

ida_graph.graph_path_visitor_t.walk_backward():
	
	        walk_backward(self, arg0) -> int
	        

ida_graph.graph_path_visitor_t.walk_forward():
	
	        walk_forward(self, arg0) -> int
	        

class ida_graph.graph_visitor_t():
	
	    Proxy of C++ graph_visitor_t class
	    

ida_graph.graph_visitor_t.visit_edge():
	
	        visit_edge(self, arg2, arg3) -> int
	        

ida_graph.graph_visitor_t.visit_node():
	
	        visit_node(self, arg2, arg3) -> int
	        

class ida_graph.group_crinfo_t():
	
	    Proxy of C++ group_crinfo_t class
	    

ida_graph.group_crinfo_t.nodes:
	group_crinfo_t_nodes_get(self) -> intvec_t *

ida_graph.group_crinfo_t.text:
	group_crinfo_t_text_get(self) -> qstring *

class ida_graph.interval_t():
	
	    Proxy of C++ interval_t class
	    

ida_graph.interval_t.contains():
	
	        contains(self, x) -> bool
	        

ida_graph.interval_t.empty():
	
	        empty(self) -> bool
	        

ida_graph.interval_t.intersect():
	
	        intersect(self, r)
	        

ida_graph.interval_t.length():
	
	        length(self) -> int
	        

ida_graph.interval_t.make_union():
	
	        make_union(self, r)
	        

ida_graph.interval_t.move_by():
	
	        move_by(self, shift)
	        

ida_graph.interval_t.x0:
	interval_t_x0_get(self) -> int

ida_graph.interval_t.x1:
	interval_t_x1_get(self) -> int

class ida_graph.mutable_graph_t():
	
	    Proxy of C++ mutable_graph_t class
	    

ida_graph.mutable_graph_t.belongs:
	mutable_graph_t_belongs_get(self) -> intvec_t *

ida_graph.mutable_graph_t.calc_group_ea():
	
	        calc_group_ea(self, arg0) -> ea_t
	        

ida_graph.mutable_graph_t.change_group_visibility():
	
	        change_group_visibility(self, group, expand) -> bool
	        

ida_graph.mutable_graph_t.clear():
	
	        clear(self)
	        

ida_graph.mutable_graph_t.create_digraph_layout():
	
	        create_digraph_layout(self) -> bool
	        

ida_graph.mutable_graph_t.create_group():
	
	        create_group(self, nodes) -> int
	        

ida_graph.mutable_graph_t.del_custom_layout():
	
	        del_custom_layout(self)
	        

ida_graph.mutable_graph_t.delete_group():
	
	        delete_group(self, group) -> bool
	        

ida_graph.mutable_graph_t.edges:
	mutable_graph_t_edges_get(self) -> edge_infos_wrapper_t

ida_graph.mutable_graph_t.empty():
	
	        empty(self) -> bool
	        

ida_graph.mutable_graph_t.exists():
	
	        exists(self, node) -> bool
	        

ida_graph.mutable_graph_t.get_custom_layout():
	
	        get_custom_layout(self) -> bool
	        

ida_graph.mutable_graph_t.get_edge():
	
	        get_edge(self, e) -> edge_info_t
	        

ida_graph.mutable_graph_t.get_first_subgraph_node():
	
	        get_first_subgraph_node(self, group) -> int
	        

ida_graph.mutable_graph_t.get_graph_groups():
	
	        get_graph_groups(self) -> bool
	        

ida_graph.mutable_graph_t.get_next_subgraph_node():
	
	        get_next_subgraph_node(self, group, current) -> int
	        

ida_graph.mutable_graph_t.get_node_group():
	
	        get_node_group(self, node) -> int
	        

ida_graph.mutable_graph_t.get_node_representative():
	
	        get_node_representative(self, node) -> int
	        

ida_graph.mutable_graph_t.gid:
	mutable_graph_t_gid_get(self) -> uval_t

ida_graph.mutable_graph_t.is_collapsed_node():
	
	        is_collapsed_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_deleted_node():
	
	        is_deleted_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_displayable_node():
	
	        is_displayable_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_dot_node():
	
	        is_dot_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_group_node():
	
	        is_group_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_simple_node():
	
	        is_simple_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_subgraph_node():
	
	        is_subgraph_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_uncollapsed_node():
	
	        is_uncollapsed_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.is_user_graph():
	
	        is_user_graph(self) -> bool
	        

ida_graph.mutable_graph_t.is_visible_node():
	
	        is_visible_node(self, node) -> bool
	        

ida_graph.mutable_graph_t.node_flags:
	mutable_graph_t_node_flags_get(self) -> bytevec_t *

ida_graph.mutable_graph_t.node_qty():
	
	        node_qty(self) -> int
	        

ida_graph.mutable_graph_t.nodes:
	mutable_graph_t_nodes_get(self) -> node_layout_t

ida_graph.mutable_graph_t.npred():
	
	        npred(self, b) -> int
	        

ida_graph.mutable_graph_t.nrect():
	
	        nrect(self, n) -> rect_t
	        nrect(self, n) -> rect_t
	        

ida_graph.mutable_graph_t.nsucc():
	
	        nsucc(self, b) -> int
	        

ida_graph.mutable_graph_t.org_preds:
	mutable_graph_t_org_preds_get(self) -> array_of_intvec_t

ida_graph.mutable_graph_t.org_succs:
	mutable_graph_t_org_succs_get(self) -> array_of_intvec_t

ida_graph.mutable_graph_t.pred():
	
	        pred(self, b, i) -> int
	        

ida_graph.mutable_graph_t.preds:
	mutable_graph_t_preds_get(self) -> array_of_intvec_t

ida_graph.mutable_graph_t.predset():
	
	        predset(self, b) -> intvec_t const &
	        

ida_graph.mutable_graph_t.reset():
	
	        reset(self)
	        

ida_graph.mutable_graph_t.set_custom_layout():
	
	        set_custom_layout(self)
	        

ida_graph.mutable_graph_t.set_deleted_node():
	
	        set_deleted_node(self, node)
	        

ida_graph.mutable_graph_t.set_edge():
	
	        set_edge(self, e, ei) -> bool
	        

ida_graph.mutable_graph_t.set_graph_groups():
	
	        set_graph_groups(self)
	        

ida_graph.mutable_graph_t.set_node_group():
	
	        set_node_group(self, node, group)
	        

ida_graph.mutable_graph_t.size():
	
	        size(self) -> int
	        

ida_graph.mutable_graph_t.succ():
	
	        succ(self, b, i) -> int
	        

ida_graph.mutable_graph_t.succs:
	mutable_graph_t_succs_get(self) -> array_of_intvec_t

ida_graph.mutable_graph_t.succset():
	
	        succset(self, b) -> intvec_t const &
	        

class ida_graph.node_info_t():
	
	    Proxy of C++ node_info_t class
	    

ida_graph.node_info_t.bg_color:
	node_info_t_bg_color_get(self) -> bgcolor_t

ida_graph.node_info_t.ea:
	node_info_t_ea_get(self) -> ea_t

ida_graph.node_info_t.flags:
	node_info_t_flags_get(self) -> uint32

ida_graph.node_info_t.frame_color:
	node_info_t_frame_color_get(self) -> bgcolor_t

ida_graph.node_info_t.get_flags_for_valid():
	
	        get_flags_for_valid(self) -> uint32
	        

ida_graph.node_info_t.text:
	node_info_t_text_get(self) -> qstring *

ida_graph.node_info_t.valid_bg_color():
	
	        valid_bg_color(self) -> bool
	        

ida_graph.node_info_t.valid_ea():
	
	        valid_ea(self) -> bool
	        

ida_graph.node_info_t.valid_flags():
	
	        valid_flags(self) -> bool
	        

ida_graph.node_info_t.valid_frame_color():
	
	        valid_frame_color(self) -> bool
	        

ida_graph.node_info_t.valid_text():
	
	        valid_text(self) -> bool
	        

class ida_graph.node_layout_t():
	
	    Proxy of C++ qvector<(rect_t)> class
	    

ida_graph.node_layout_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_graph.node_layout_t.at():
	
	        at(self, _idx) -> rect_t
	        

ida_graph.node_layout_t.begin():
	
	        begin(self) -> rect_t
	        begin(self) -> rect_t
	        

ida_graph.node_layout_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_graph.node_layout_t.clear():
	
	        clear(self)
	        

ida_graph.node_layout_t.empty():
	
	        empty(self) -> bool
	        

ida_graph.node_layout_t.end():
	
	        end(self) -> rect_t
	        end(self) -> rect_t
	        

ida_graph.node_layout_t.erase():
	
	        erase(self, it) -> rect_t
	        erase(self, first, last) -> rect_t
	        

ida_graph.node_layout_t.extract():
	
	        extract(self) -> rect_t
	        

ida_graph.node_layout_t.find():
	
	        find(self, x) -> rect_t
	        find(self, x) -> rect_t
	        

ida_graph.node_layout_t.grow():
	
	        grow(self, x=rect_t())
	        

ida_graph.node_layout_t.has():
	
	        has(self, x) -> bool
	        

ida_graph.node_layout_t.inject():
	
	        inject(self, s, len)
	        

ida_graph.node_layout_t.insert():
	
	        insert(self, it, x) -> rect_t
	        

ida_graph.node_layout_t.pop_back():
	
	        pop_back(self)
	        

ida_graph.node_layout_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> rect_t
	        

ida_graph.node_layout_t.qclear():
	
	        qclear(self)
	        

ida_graph.node_layout_t.reserve():
	
	        reserve(self, cnt)
	        

ida_graph.node_layout_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_graph.node_layout_t.size():
	
	        size(self) -> size_t
	        

ida_graph.node_layout_t.swap():
	
	        swap(self, r)
	        

ida_graph.node_layout_t.truncate():
	
	        truncate(self)
	        

class ida_graph.node_ordering_t():
	
	    Proxy of C++ node_ordering_t class
	    

ida_graph.node_ordering_t.clear():
	
	        clear(self)
	        

ida_graph.node_ordering_t.node():
	
	        node(self, _order) -> int
	        

ida_graph.node_ordering_t.resize():
	
	        resize(self, n)
	        

ida_graph.node_ordering_t.set():
	
	        set(self, _node, num)
	        

ida_graph.node_ordering_t.size():
	
	        size(self) -> size_t
	        

class ida_graph.point_t():
	
	    Proxy of C++ point_t class
	    

ida_graph.point_t.add():
	
	        add(self, r) -> point_t
	        

ida_graph.point_t.negate():
	
	        negate(self)
	        

ida_graph.point_t.sub():
	
	        sub(self, r) -> point_t
	        

ida_graph.point_t.x:
	point_t_x_get(self) -> int

ida_graph.point_t.y:
	point_t_y_get(self) -> int

class ida_graph.pointseq_t():
	
	    Proxy of C++ pointseq_t class
	    

ida_graph.pointseq_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_graph.pointseq_t.at():
	
	        at(self, _idx) -> point_t
	        

ida_graph.pointseq_t.begin():
	
	        begin(self) -> point_t
	        begin(self) -> point_t
	        

ida_graph.pointseq_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_graph.pointseq_t.clear():
	
	        clear(self)
	        

ida_graph.pointseq_t.empty():
	
	        empty(self) -> bool
	        

ida_graph.pointseq_t.end():
	
	        end(self) -> point_t
	        end(self) -> point_t
	        

ida_graph.pointseq_t.erase():
	
	        erase(self, it) -> point_t
	        erase(self, first, last) -> point_t
	        

ida_graph.pointseq_t.extract():
	
	        extract(self) -> point_t
	        

ida_graph.pointseq_t.find():
	
	        find(self, x) -> point_t
	        find(self, x) -> point_t
	        

ida_graph.pointseq_t.grow():
	
	        grow(self, x=point_t())
	        

ida_graph.pointseq_t.has():
	
	        has(self, x) -> bool
	        

ida_graph.pointseq_t.inject():
	
	        inject(self, s, len)
	        

ida_graph.pointseq_t.insert():
	
	        insert(self, it, x) -> point_t
	        

ida_graph.pointseq_t.pop_back():
	
	        pop_back(self)
	        

ida_graph.pointseq_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> point_t
	        

ida_graph.pointseq_t.qclear():
	
	        qclear(self)
	        

ida_graph.pointseq_t.reserve():
	
	        reserve(self, cnt)
	        

ida_graph.pointseq_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_graph.pointseq_t.size():
	
	        size(self) -> size_t
	        

ida_graph.pointseq_t.swap():
	
	        swap(self, r)
	        

ida_graph.pointseq_t.truncate():
	
	        truncate(self)
	        

class ida_graph.pointvec_t():
	
	    Proxy of C++ qvector<(point_t)> class
	    

ida_graph.pointvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_graph.pointvec_t.at():
	
	        at(self, _idx) -> point_t
	        

ida_graph.pointvec_t.begin():
	
	        begin(self) -> point_t
	        begin(self) -> point_t
	        

ida_graph.pointvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_graph.pointvec_t.clear():
	
	        clear(self)
	        

ida_graph.pointvec_t.empty():
	
	        empty(self) -> bool
	        

ida_graph.pointvec_t.end():
	
	        end(self) -> point_t
	        end(self) -> point_t
	        

ida_graph.pointvec_t.erase():
	
	        erase(self, it) -> point_t
	        erase(self, first, last) -> point_t
	        

ida_graph.pointvec_t.extract():
	
	        extract(self) -> point_t
	        

ida_graph.pointvec_t.find():
	
	        find(self, x) -> point_t
	        find(self, x) -> point_t
	        

ida_graph.pointvec_t.grow():
	
	        grow(self, x=point_t())
	        

ida_graph.pointvec_t.has():
	
	        has(self, x) -> bool
	        

ida_graph.pointvec_t.inject():
	
	        inject(self, s, len)
	        

ida_graph.pointvec_t.insert():
	
	        insert(self, it, x) -> point_t
	        

ida_graph.pointvec_t.pop_back():
	
	        pop_back(self)
	        

ida_graph.pointvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> point_t
	        

ida_graph.pointvec_t.qclear():
	
	        qclear(self)
	        

ida_graph.pointvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_graph.pointvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_graph.pointvec_t.size():
	
	        size(self) -> size_t
	        

ida_graph.pointvec_t.swap():
	
	        swap(self, r)
	        

ida_graph.pointvec_t.truncate():
	
	        truncate(self)
	        

ida_graph.pyg_close():
	
	  pyg_close(self)
	  

ida_graph.pyg_select_node():
	
	  pyg_select_node(self, nid)
	  

ida_graph.pyg_show():
	
	  pyg_show(self) -> bool
	  

class ida_graph.rect_t():
	
	    Proxy of C++ rect_t class
	    

ida_graph.rect_t.area():
	
	        area(self) -> int
	        

ida_graph.rect_t.bottom:
	rect_t_bottom_get(self) -> int

ida_graph.rect_t.bottomright():
	
	        bottomright(self) -> point_t
	        

ida_graph.rect_t.center():
	
	        center(self) -> point_t
	        

ida_graph.rect_t.contains():
	
	        contains(self, p) -> bool
	        

ida_graph.rect_t.empty():
	
	        empty(self) -> bool
	        

ida_graph.rect_t.grow():
	
	        grow(self, delta)
	        

ida_graph.rect_t.height():
	
	        height(self) -> int
	        

ida_graph.rect_t.intersect():
	
	        intersect(self, r)
	        

ida_graph.rect_t.is_intersection_empty():
	
	        is_intersection_empty(self, r) -> bool
	        

ida_graph.rect_t.left:
	rect_t_left_get(self) -> int

ida_graph.rect_t.make_union():
	
	        make_union(self, r)
	        

ida_graph.rect_t.move_by():
	
	        move_by(self, p)
	        

ida_graph.rect_t.move_to():
	
	        move_to(self, p)
	        

ida_graph.rect_t.right:
	rect_t_right_get(self) -> int

ida_graph.rect_t.top:
	rect_t_top_get(self) -> int

ida_graph.rect_t.topleft():
	
	        topleft(self) -> point_t
	        

ida_graph.rect_t.width():
	
	        width(self) -> int
	        

ida_graph.refresh_viewer():
	
	  refresh_viewer(gv)
	
	
	  Redraw the graph in the given view.
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  

class ida_graph.row_info_t():
	
	    Proxy of C++ row_info_t class
	    

ida_graph.row_info_t.bottom:
	row_info_t_bottom_get(self) -> int

ida_graph.row_info_t.height():
	
	        height(self) -> int
	        

ida_graph.row_info_t.nodes:
	row_info_t_nodes_get(self) -> intvec_t *

ida_graph.row_info_t.top:
	row_info_t_top_get(self) -> int

class ida_graph.screen_graph_selection_t():
	
	    Proxy of C++ screen_graph_selection_t class
	    

ida_graph.screen_graph_selection_t.add():
	
	        add(self, s)
	        

ida_graph.screen_graph_selection_t.add_node():
	
	        add_node(self, node)
	        

ida_graph.screen_graph_selection_t.add_point():
	
	        add_point(self, e, idx)
	        

ida_graph.screen_graph_selection_t.del_node():
	
	        del_node(self, node)
	        

ida_graph.screen_graph_selection_t.del_point():
	
	        del_point(self, e, idx)
	        

ida_graph.screen_graph_selection_t.has():
	
	        has(self, item) -> bool
	        

ida_graph.screen_graph_selection_t.items_count():
	
	        items_count(self, look_for_nodes) -> size_t
	        

ida_graph.screen_graph_selection_t.nodes_count():
	
	        nodes_count(self) -> size_t
	        

ida_graph.screen_graph_selection_t.points_count():
	
	        points_count(self) -> size_t
	        

ida_graph.screen_graph_selection_t.sub():
	
	        sub(self, s)
	        

class ida_graph.selection_item_t():
	
	    Proxy of C++ selection_item_t class
	    

ida_graph.selection_item_t.compare():
	
	        compare(self, r) -> int
	        

ida_graph.selection_item_t.elp:
	selection_item_t_elp_get(self) -> edge_layout_point_t

ida_graph.selection_item_t.is_node:
	selection_item_t_is_node_get(self) -> bool

ida_graph.selection_item_t.node:
	selection_item_t_node_get(self) -> int

ida_graph.set_node_info():
	
	  set_node_info(gid, node, ni, flags)
	
	
	  Set node info.
	  
	  @param gid: id of desired graph (C++: graph_id_t)
	  @param node: node number (C++: int)
	  @param ni: node info to use (C++: const  node_info_t  &)
	  @param flags: combination of  Node info flags , identifying which
	                fields of 'ni' will be used (C++: uint32)
	  

ida_graph.set_viewer_graph():
	
	  set_viewer_graph(gv, g)
	
	
	  Set the underlying graph object for the given viewer.
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param g (C++: mutable_graph_t  *)
	  

class ida_graph.user_graph_place_t():
	
	    Proxy of C++ user_graph_place_t class
	    

ida_graph.user_graph_place_t.node:
	user_graph_place_t_node_get(self) -> int

ida_graph.viewer_attach_menu_item():
	
	  viewer_attach_menu_item(g, name) -> bool
	
	
	  Attach a previously-registered action to the view's context menu. See
	  'kernwin.hpp' for how to register actions.
	  
	  @param g (C++: graph_viewer_t  *)
	  @param name: action name (C++: const char *)
	  @return: success
	  

ida_graph.viewer_center_on():
	
	  viewer_center_on(gv, node)
	
	
	  Center the graph view on the given node.
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param node (C++: int)
	  

ida_graph.viewer_create_groups():
	
	  viewer_create_groups(gv, out_group_nodes, gi) -> bool
	
	
	  This will perform an operation similar to what happens when a user
	  manually selects a set of nodes, right-clicks and selects "Create
	  group". This is a wrapper around mutable_graph_t::create_group that
	  will, in essence:clone the current graphfor each 'group_crinfo_t' ,
	  attempt creating group in that new graphif all were successful,
	  animate to that new graph.this accepts parameters that allow creating
	  of multiple groups at once; which means only one graph animation will
	  be triggered.
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param out_group_nodes (C++: intvec_t  *)
	  @param gi (C++: const  groups_crinfos_t  &)
	  

ida_graph.viewer_del_node_info():
	
	  viewer_del_node_info(gv, n)
	
	
	  Delete node info for node in given viewer (see 'del_node_info()' )
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param n (C++: int)
	  

ida_graph.viewer_delete_groups():
	
	  viewer_delete_groups(gv, groups, new_current=-1) -> bool
	
	
	  Wrapper around mutable_graph_t::delete_group. This function will:clone
	  the current graphattempt deleting the groups in that new graphif
	  successful, animate to that new graph.
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param groups (C++: const  intvec_t  &)
	  @param new_current (C++: int)
	  

ida_graph.viewer_fit_window():
	
	  viewer_fit_window(gv)
	
	
	  Fit graph viewer to its parent form.
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  

ida_graph.viewer_get_curnode():
	
	  viewer_get_curnode(gv) -> int
	
	
	  Get number of currently selected node (-1 if none)
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  

ida_graph.viewer_get_gli():
	
	  viewer_get_gli(out, gv, flags=0) -> bool
	
	
	  Get location info for given graph view If flags contains
	  GLICTL_CENTER, then the gli that will be retrieved, will be the one at
	  the center of the view. Otherwise it will be the top-left.
	  
	  @param out (C++: graph_location_info_t  *)
	  @param gv (C++: graph_viewer_t  *)
	  @param flags (C++: uint32)
	  

ida_graph.viewer_get_node_info():
	
	  viewer_get_node_info(gv, out, n) -> bool
	
	
	  Get node info for node in given viewer (see 'get_node_info()' )
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param out (C++: node_info_t  *)
	  @param n (C++: int)
	  

ida_graph.viewer_get_selection():
	
	  viewer_get_selection(gv, sgs) -> bool
	
	
	  Get currently selected items for graph viewer.
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param sgs (C++: screen_graph_selection_t  *)
	  

ida_graph.viewer_set_gli():
	
	  viewer_set_gli(gv, gli, flags=0)
	
	
	  Set location info for given graph view If flags contains
	  GLICTL_CENTER, then the gli will be set to be the center of the view.
	  Otherwise it will be the top-left.
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param gli (C++: const  graph_location_info_t  *)
	  @param flags (C++: uint32)
	  

ida_graph.viewer_set_groups_visibility():
	
	  viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool
	
	
	  Wrapper around mutable_graph_t::change_visibility. This function
	  will:clone the current graphattempt changing visibility of the groups
	  in that new graphif successful, animate to that new graph.
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param groups (C++: const  intvec_t  &)
	  @param expand (C++: bool)
	  @param new_current (C++: int)
	  

ida_graph.viewer_set_node_info():
	
	  viewer_set_node_info(gv, n, ni, flags)
	
	
	  Set node info for node in given viewer (see 'set_node_info()' )
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param n (C++: int)
	  @param ni (C++: const  node_info_t  &)
	  @param flags (C++: uint32)
	  

ida_graph.viewer_set_titlebar_height():
	
	  viewer_set_titlebar_height(gv, height) -> int
	
	
	  Set height of node title bars ( 'grcode_set_titlebar_height' )
	  
	  
	  @param gv (C++: graph_viewer_t  *)
	  @param height (C++: int)
	  


=== ida_graph EPYDOC INJECTIONS ===
ida_graph.GLICTL_CENTER
"""
the gli should be set/get as center
"""

ida_graph.MTG_DOT_NODE
"""
is dot node?
"""

ida_graph.MTG_GROUP_NODE
"""
is group node?
"""

ida_graph.MTG_NON_DISPLAYABLE_NODE
"""
for disassembly graphs - non-displayable nodes have a visible area
that is too large to generate disassembly lines for without IDA
slowing down significantly (see MAX_VISIBLE_NODE_AREA)
"""

ida_graph.NIF_BG_COLOR
"""
 'node_info_t::bg_color'
"""

ida_graph.NIF_EA
"""
 'node_info_t::ea'
"""

ida_graph.NIF_FLAGS
"""
 'node_info_t::flags'
"""

ida_graph.NIF_FRAME_COLOR
"""
 'node_info_t::frame_color'
"""

ida_graph.NIF_TEXT
"""
 'node_info_t::text'
"""
=== ida_graph EPYDOC INJECTIONS END ===
class ida_hexrays.DecompilationFailure():
	
	     Raised on a decompilation error.
	
	    The associated hexrays_failure_t object is stored in the
	    'info' member of this exception. 
	

class ida_hexrays.Hexrays_Hooks():
	
	    Proxy of C++ Hexrays_Hooks class
	    

ida_hexrays.Hexrays_Hooks.close_pseudocode():
	
	        close_pseudocode(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.cmt_changed():
	
	        cmt_changed(self, cfunc, loc, cmt) -> int
	        

ida_hexrays.Hexrays_Hooks.combine():
	
	        combine(self, blk, insn) -> int
	        

ida_hexrays.Hexrays_Hooks.create_hint():
	
	        create_hint(self, vu) -> PyObject *
	        

ida_hexrays.Hexrays_Hooks.curpos():
	
	        curpos(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.double_click():
	
	        double_click(self, vu, shift_state) -> int
	        

ida_hexrays.Hexrays_Hooks.flowchart():
	
	        flowchart(self, fc) -> int
	        

ida_hexrays.Hexrays_Hooks.func_printed():
	
	        func_printed(self, cfunc) -> int
	        

ida_hexrays.Hexrays_Hooks.glbopt():
	
	        glbopt(self, mba) -> int
	        

ida_hexrays.Hexrays_Hooks.hook():
	
	        hook(self) -> bool
	        

ida_hexrays.Hexrays_Hooks.interr():
	
	        interr(self, errcode) -> int
	        

ida_hexrays.Hexrays_Hooks.keyboard():
	
	        keyboard(self, vu, key_code, shift_state) -> int
	        

ida_hexrays.Hexrays_Hooks.locopt():
	
	        locopt(self, mba) -> int
	        

ida_hexrays.Hexrays_Hooks.lvar_cmt_changed():
	
	        lvar_cmt_changed(self, vu, v, cmt) -> int
	        

ida_hexrays.Hexrays_Hooks.lvar_mapping_changed():
	
	        lvar_mapping_changed(self, vu, _from, to) -> int
	        

ida_hexrays.Hexrays_Hooks.lvar_name_changed():
	
	        lvar_name_changed(self, vu, v, name, is_user_name) -> int
	        

ida_hexrays.Hexrays_Hooks.lvar_type_changed():
	
	        lvar_type_changed(self, vu, v, tinfo) -> int
	        

ida_hexrays.Hexrays_Hooks.maturity():
	
	        maturity(self, cfunc, new_maturity) -> int
	        

ida_hexrays.Hexrays_Hooks.microcode():
	
	        microcode(self, mba) -> int
	        

ida_hexrays.Hexrays_Hooks.open_pseudocode():
	
	        open_pseudocode(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.populating_popup():
	
	        populating_popup(self, widget, popup_handle, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.prealloc():
	
	        prealloc(self, mba) -> int
	        

ida_hexrays.Hexrays_Hooks.preoptimized():
	
	        preoptimized(self, mba) -> int
	        

ida_hexrays.Hexrays_Hooks.print_func():
	
	        print_func(self, cfunc, vp) -> int
	        

ida_hexrays.Hexrays_Hooks.prolog():
	
	        prolog(self, mba, fc, reachable_blocks) -> int
	        

ida_hexrays.Hexrays_Hooks.refresh_pseudocode():
	
	        refresh_pseudocode(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.resolve_stkaddrs():
	
	        resolve_stkaddrs(self, mba) -> int
	        

ida_hexrays.Hexrays_Hooks.right_click():
	
	        right_click(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.stkpnts():
	
	        stkpnts(self, mba, stkpnts) -> int
	        

ida_hexrays.Hexrays_Hooks.structural():
	
	        structural(self, ct) -> int
	        

ida_hexrays.Hexrays_Hooks.switch_pseudocode():
	
	        switch_pseudocode(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.text_ready():
	
	        text_ready(self, vu) -> int
	        

ida_hexrays.Hexrays_Hooks.unhook():
	
	        unhook(self) -> bool
	        

ida_hexrays.accepts_udts():
	
	  accepts_udts(op) -> bool
	  

ida_hexrays.arglocs_overlap():
	
	  arglocs_overlap(loc1, w1, loc2, w2) -> bool
	
	
	  Do two arglocs overlap?
	  
	  
	  @param loc1 (C++: const  vdloc_t  &)
	  @param w1 (C++: size_t)
	  @param loc2 (C++: const  vdloc_t  &)
	  @param w2 (C++: size_t)
	  

ida_hexrays.asgop():
	
	  asgop(cop) -> ctype_t
	
	
	  Convert plain operator into assignment operator. For example, cot_add
	  returns cot_asgadd.
	  
	  
	  @param cop (C++: ctype_t)
	  

ida_hexrays.asgop_revert():
	
	  asgop_revert(cop) -> ctype_t
	
	
	  Convert assignment operator into plain operator. For example,
	  cot_asgadd returns cot_add
	  
	  @param cop (C++: ctype_t)
	  @return: cot_empty is the input operator is not an assignment
	           operator.
	  

class ida_hexrays.bit_bound_t():
	
	    Proxy of C++ bit_bound_t class
	    

ida_hexrays.bit_bound_t.nbits:
	bit_bound_t_nbits_get(self) -> int16

ida_hexrays.bit_bound_t.sbits:
	bit_bound_t_sbits_get(self) -> int16

ida_hexrays.boundaries_begin():
	
	  boundaries_begin(map) -> boundaries_iterator_t
	
	
	  Get iterator pointing to the beginning of boundaries_t.
	  
	  
	  @param map (C++: const boundaries_t *)
	  

ida_hexrays.boundaries_clear():
	
	  boundaries_clear(map)
	
	
	  Clear boundaries_t.
	  
	  
	  @param map (C++: boundaries_t *)
	  

ida_hexrays.boundaries_end():
	
	  boundaries_end(map) -> boundaries_iterator_t
	
	
	  Get iterator pointing to the end of boundaries_t.
	  
	  
	  @param map (C++: const boundaries_t *)
	  

ida_hexrays.boundaries_erase():
	
	  boundaries_erase(map, p)
	
	
	  Erase current element from boundaries_t.
	  
	  
	  @param map (C++: boundaries_t *)
	  @param p (C++: boundaries_iterator_t)
	  

ida_hexrays.boundaries_find():
	
	  boundaries_find(map, key) -> boundaries_iterator_t
	
	
	  Find the specified key in boundaries_t.
	  
	  
	  @param map (C++: const boundaries_t *)
	  @param key (C++: const  cinsn_t  *&)
	  

ida_hexrays.boundaries_first():
	
	  boundaries_first(p) -> cinsn_t
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: boundaries_iterator_t)
	  

ida_hexrays.boundaries_free():
	
	  boundaries_free(map)
	
	
	  Delete boundaries_t instance.
	  
	  
	  @param map (C++: boundaries_t *)
	  

ida_hexrays.boundaries_insert():
	
	  boundaries_insert(map, key, val) -> boundaries_iterator_t
	
	
	  Insert new ( 'cinsn_t' *, 'rangeset_t' ) pair into boundaries_t.
	  
	  
	  @param map (C++: boundaries_t *)
	  @param key (C++: const  cinsn_t  *&)
	  @param val (C++: const  rangeset_t  &)
	  

class ida_hexrays.boundaries_iterator_t():
	
	    Proxy of C++ boundaries_iterator_t class
	    

ida_hexrays.boundaries_iterator_t.x:
	boundaries_iterator_t_x_get(self) -> iterator_word

ida_hexrays.boundaries_new():
	
	  boundaries_new() -> boundaries_t
	
	
	  Create a new boundaries_t instance.
	  

ida_hexrays.boundaries_next():
	
	  boundaries_next(p) -> boundaries_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: boundaries_iterator_t)
	  

ida_hexrays.boundaries_prev():
	
	  boundaries_prev(p) -> boundaries_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: boundaries_iterator_t)
	  

ida_hexrays.boundaries_second():
	
	  boundaries_second(p) -> rangeset_t
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: boundaries_iterator_t)
	  

ida_hexrays.boundaries_size():
	
	  boundaries_size(map) -> size_t
	
	
	  Get size of boundaries_t.
	  
	  
	  @param map (C++: boundaries_t *)
	  

class ida_hexrays.boundaries_t():
	
	    Proxy of C++ std::map<(p.cinsn_t,rangeset_t)> class
	    

ida_hexrays.boundaries_t.at():
	
	        at(self, _Keyval) -> rangeset_t
	        

class ida_hexrays.boundaries_t.keytype():
	
	    Proxy of C++ cinsn_t class
	    

ida_hexrays.boundaries_t.keytype._print():
	
	        _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
	        

ida_hexrays.boundaries_t.keytype.assign():
	
	        assign(self, r) -> cinsn_t
	        

ida_hexrays.boundaries_t.keytype.cinsn:
	citem_t_cinsn_get(self) -> cinsn_t

ida_hexrays.boundaries_t.keytype.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.boundaries_t.keytype.collect_free_breaks():
	
	        collect_free_breaks(self, breaks) -> bool
	        

ida_hexrays.boundaries_t.keytype.collect_free_continues():
	
	        collect_free_continues(self, continues) -> bool
	        

ida_hexrays.boundaries_t.keytype.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.boundaries_t.keytype.contains_expr():
	
	        contains_expr(self, e) -> bool
	        

ida_hexrays.boundaries_t.keytype.contains_free_break():
	
	        contains_free_break(self) -> bool
	        

ida_hexrays.boundaries_t.keytype.contains_free_continue():
	
	        contains_free_continue(self) -> bool
	        

ida_hexrays.boundaries_t.keytype.contains_insn():
	
	        contains_insn(self, type, times=1) -> bool
	        

ida_hexrays.boundaries_t.keytype.contains_label():
	
	        contains_label(self) -> bool
	        

ida_hexrays.boundaries_t.keytype.create_if():
	
	        create_if(self, cnd) -> cif_t
	        

ida_hexrays.boundaries_t.keytype.details:
	
	     return the details pointer for the cinsn_t object depending on the value of its op member.         this is one of the cblock_t, cif_t, etc. objects. 
	

ida_hexrays.boundaries_t.keytype.ea:
	citem_t_ea_get(self) -> ea_t

ida_hexrays.boundaries_t.keytype.find_closest_addr():
	
	        find_closest_addr(self, _ea) -> citem_t
	        

ida_hexrays.boundaries_t.keytype.find_parent_of():
	
	        find_parent_of(self, sitem) -> citem_t
	        find_parent_of(self, item) -> citem_t
	        

ida_hexrays.boundaries_t.keytype.index:
	citem_t_index_get(self) -> int

ida_hexrays.boundaries_t.keytype.insn_is_epilog():
	
	        insn_is_epilog(insn) -> bool
	        

ida_hexrays.boundaries_t.keytype.is_expr():
	
	        is_expr(self) -> bool
	        

ida_hexrays.boundaries_t.keytype.is_ordinary_flow():
	
	        is_ordinary_flow(self) -> bool
	        

ida_hexrays.boundaries_t.keytype.label_num:
	citem_t_label_num_get(self) -> int

ida_hexrays.boundaries_t.keytype.new_insn():
	
	        new_insn(self, insn_ea) -> cinsn_t
	        

ida_hexrays.boundaries_t.keytype.obj_id:
	
	        _obj_id(self) -> PyObject *
	        

ida_hexrays.boundaries_t.keytype.op:
	
	        _get_op(self) -> ctype_t
	        

ida_hexrays.boundaries_t.keytype.print1():
	
	        print1(self, func)
	        

ida_hexrays.boundaries_t.keytype.swap():
	
	        swap(self, r)
	        

ida_hexrays.boundaries_t.keytype.to_specific_type:
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.boundaries_t.keytype.zero():
	
	        zero(self)
	        

ida_hexrays.boundaries_t.pop():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.boundaries_t.popitem():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.boundaries_t.setdefault():
	
	         Sets the value associated with the provided key. 
	        

class ida_hexrays.boundaries_t.valuetype():
	
	    Proxy of C++ rangeset_t class
	    

ida_hexrays.boundaries_t.valuetype._print():
	
	        _print(self) -> size_t
	        

ida_hexrays.boundaries_t.valuetype.add():
	
	        add(self, range) -> bool
	        add(self, start, _end) -> bool
	        add(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_hexrays.boundaries_t.valuetype.cached_range():
	
	        cached_range(self) -> range_t
	        

ida_hexrays.boundaries_t.valuetype.clear():
	
	        clear(self)
	        

ida_hexrays.boundaries_t.valuetype.contains():
	
	        contains(self, ea) -> bool
	        contains(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.boundaries_t.valuetype.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_hexrays.boundaries_t.valuetype.find_range():
	
	        find_range(self, ea) -> range_t
	        

ida_hexrays.boundaries_t.valuetype.getrange():
	
	        getrange(self, idx) -> range_t
	        

ida_hexrays.boundaries_t.valuetype.has_common():
	
	        has_common(self, range) -> bool
	        has_common(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.includes():
	
	        includes(self, range) -> bool
	        

ida_hexrays.boundaries_t.valuetype.intersect():
	
	        intersect(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.is_equal():
	
	        is_equal(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.is_subset_of():
	
	        is_subset_of(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.lastrange():
	
	        lastrange(self) -> range_t
	        

ida_hexrays.boundaries_t.valuetype.next_addr():
	
	        next_addr(self, ea) -> ea_t
	        

ida_hexrays.boundaries_t.valuetype.next_range():
	
	        next_range(self, ea) -> ea_t
	        

ida_hexrays.boundaries_t.valuetype.nranges():
	
	        nranges(self) -> size_t
	        

ida_hexrays.boundaries_t.valuetype.prev_addr():
	
	        prev_addr(self, ea) -> ea_t
	        

ida_hexrays.boundaries_t.valuetype.prev_range():
	
	        prev_range(self, ea) -> ea_t
	        

ida_hexrays.boundaries_t.valuetype.sub():
	
	        sub(self, range) -> bool
	        sub(self, ea) -> bool
	        sub(self, aset) -> bool
	        

ida_hexrays.boundaries_t.valuetype.swap():
	
	        swap(self, r)
	        

class ida_hexrays.carg_t():
	
	    Proxy of C++ carg_t class
	    

ida_hexrays.carg_t.assign():
	
	        assign(self, r) -> cexpr_t
	        

ida_hexrays.carg_t.calc_type():
	
	        calc_type(self, recursive)
	        

ida_hexrays.carg_t.cexpr:
	citem_t_cexpr_get(self) -> cexpr_t

ida_hexrays.carg_t.cinsn:
	citem_t_cinsn_get(self) -> cinsn_t

ida_hexrays.carg_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.carg_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.carg_t.consume_cexpr():
	
	        consume_cexpr(self, e)
	        

ida_hexrays.carg_t.contains_comma():
	
	        contains_comma(self, times=1) -> bool
	        

ida_hexrays.carg_t.contains_comma_or_insn_or_label():
	
	        contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
	        

ida_hexrays.carg_t.contains_expr():
	
	        contains_expr(self, e) -> bool
	        

ida_hexrays.carg_t.contains_insn():
	
	        contains_insn(self, times=1) -> bool
	        

ida_hexrays.carg_t.contains_insn_or_label():
	
	        contains_insn_or_label(self) -> bool
	        

ida_hexrays.carg_t.contains_label():
	
	        contains_label(self) -> bool
	        

ida_hexrays.carg_t.contains_operator():
	
	        contains_operator(self, needed_op, times=1) -> bool
	        

ida_hexrays.carg_t.cpadone():
	
	        cpadone(self) -> bool
	        

ida_hexrays.carg_t.ea:
	citem_t_ea_get(self) -> ea_t

ida_hexrays.carg_t.equal_effect():
	
	        equal_effect(self, r) -> bool
	        

ida_hexrays.carg_t.exflags:
	cexpr_t_exflags_get(self) -> uint32

ida_hexrays.carg_t.find_closest_addr():
	
	        find_closest_addr(self, _ea) -> citem_t
	        

ida_hexrays.carg_t.find_num_op():
	
	        find_num_op(self) -> cexpr_t
	        find_num_op(self) -> cexpr_t
	        

ida_hexrays.carg_t.find_op():
	
	        find_op(self, _op) -> cexpr_t
	        find_op(self, _op) -> cexpr_t
	        

ida_hexrays.carg_t.find_parent_of():
	
	        find_parent_of(self, sitem) -> citem_t
	        find_parent_of(self, item) -> citem_t
	        

ida_hexrays.carg_t.formal_type:
	carg_t_formal_type_get(self) -> tinfo_t

ida_hexrays.carg_t.get_1num_op():
	
	        get_1num_op(self, o1, o2) -> bool
	        

ida_hexrays.carg_t.get_const_value():
	
	        get_const_value(self) -> bool
	        

ida_hexrays.carg_t.get_high_nbit_bound():
	
	        get_high_nbit_bound(self) -> bit_bound_t
	        

ida_hexrays.carg_t.get_low_nbit_bound():
	
	        get_low_nbit_bound(self) -> int
	        

ida_hexrays.carg_t.get_ptr_or_array():
	
	        get_ptr_or_array(self) -> cexpr_t
	        

ida_hexrays.carg_t.get_type_sign():
	
	        get_type_sign(self) -> type_sign_t
	        

ida_hexrays.carg_t.get_v():
	
	        get_v(self) -> var_ref_t
	        

ida_hexrays.carg_t.has_side_effects():
	
	        has_side_effects(self) -> bool
	        

ida_hexrays.carg_t.index:
	citem_t_index_get(self) -> int

ida_hexrays.carg_t.is_call_arg_of():
	
	        is_call_arg_of(self, parent) -> bool
	        

ida_hexrays.carg_t.is_call_object_of():
	
	        is_call_object_of(self, parent) -> bool
	        

ida_hexrays.carg_t.is_child_of():
	
	        is_child_of(self, parent) -> bool
	        

ida_hexrays.carg_t.is_const_value():
	
	        is_const_value(self, _v) -> bool
	        

ida_hexrays.carg_t.is_cstr():
	
	        is_cstr(self) -> bool
	        

ida_hexrays.carg_t.is_expr():
	
	        is_expr(self) -> bool
	        

ida_hexrays.carg_t.is_fpop():
	
	        is_fpop(self) -> bool
	        

ida_hexrays.carg_t.is_jumpout():
	
	        is_jumpout(self) -> bool
	        

ida_hexrays.carg_t.is_negative_const():
	
	        is_negative_const(self) -> bool
	        

ida_hexrays.carg_t.is_nice_cond():
	
	        is_nice_cond(self) -> bool
	        

ida_hexrays.carg_t.is_nice_expr():
	
	        is_nice_expr(self) -> bool
	        

ida_hexrays.carg_t.is_non_negative_const():
	
	        is_non_negative_const(self) -> bool
	        

ida_hexrays.carg_t.is_non_zero_const():
	
	        is_non_zero_const(self) -> bool
	        

ida_hexrays.carg_t.is_odd_lvalue():
	
	        is_odd_lvalue(self) -> bool
	        

ida_hexrays.carg_t.is_type_signed():
	
	        is_type_signed(self) -> bool
	        

ida_hexrays.carg_t.is_type_unsigned():
	
	        is_type_unsigned(self) -> bool
	        

ida_hexrays.carg_t.is_undef_val():
	
	        is_undef_val(self) -> bool
	        

ida_hexrays.carg_t.is_vararg:
	carg_t_is_vararg_get(self) -> bool

ida_hexrays.carg_t.is_vftable():
	
	        is_vftable(self) -> bool
	        

ida_hexrays.carg_t.is_zero_const():
	
	        is_zero_const(self) -> bool
	        

ida_hexrays.carg_t.label_num:
	citem_t_label_num_get(self) -> int

ida_hexrays.carg_t.maybe_ptr():
	
	        maybe_ptr(self) -> bool
	        

ida_hexrays.carg_t.numval():
	
	        numval(self) -> uint64
	        

ida_hexrays.carg_t.obj_id:
	
	        _obj_id(self) -> PyObject *
	        

ida_hexrays.carg_t.op:
	
	        _get_op(self) -> ctype_t
	        

ida_hexrays.carg_t.operands:
	
	     return a dictionary with the operands of a cexpr_t. 
	    

ida_hexrays.carg_t.print1():
	
	        print1(self, func)
	        

ida_hexrays.carg_t.put_number():
	
	        put_number(self, func, value, nbytes, sign=no_sign)
	        

ida_hexrays.carg_t.requires_lvalue():
	
	        requires_lvalue(self, child) -> bool
	        

ida_hexrays.carg_t.set_cpadone():
	
	        set_cpadone(self)
	        

ida_hexrays.carg_t.set_v():
	
	        set_v(self, v)
	        

ida_hexrays.carg_t.set_vftable():
	
	        set_vftable(self)
	        

ida_hexrays.carg_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.carg_t.theother():
	
	        theother(self, what) -> cexpr_t
	        theother(self, what) -> cexpr_t
	        

ida_hexrays.carg_t.to_specific_type:
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.carg_t.type:
	cexpr_t_type_get(self) -> tinfo_t

class ida_hexrays.carglist_t():
	
	    Proxy of C++ carglist_t class
	    

ida_hexrays.carglist_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.carglist_t.at():
	
	        __getitem__(self, i) -> carg_t
	        

ida_hexrays.carglist_t.begin():
	
	        begin(self) -> carg_t
	        begin(self) -> carg_t
	        

ida_hexrays.carglist_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.carglist_t.clear():
	
	        clear(self)
	        

ida_hexrays.carglist_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.carglist_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.carglist_t.end():
	
	        end(self) -> carg_t
	        end(self) -> carg_t
	        

ida_hexrays.carglist_t.erase():
	
	        erase(self, it) -> carg_t
	        erase(self, first, last) -> carg_t
	        

ida_hexrays.carglist_t.extract():
	
	        extract(self) -> carg_t
	        

ida_hexrays.carglist_t.find():
	
	        find(self, x) -> carg_t
	        find(self, x) -> carg_t
	        

ida_hexrays.carglist_t.flags:
	carglist_t_flags_get(self) -> int

ida_hexrays.carglist_t.functype:
	carglist_t_functype_get(self) -> tinfo_t

ida_hexrays.carglist_t.grow():
	
	        grow(self, x=carg_t())
	        

ida_hexrays.carglist_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.carglist_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.carglist_t.insert():
	
	        insert(self, it, x) -> carg_t
	        

ida_hexrays.carglist_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.carglist_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> carg_t
	        

ida_hexrays.carglist_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.carglist_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.carglist_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.carglist_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.carglist_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.carglist_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.casm_t():
	
	    Proxy of C++ casm_t class
	    

ida_hexrays.casm_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.casm_t.one_insn():
	
	        one_insn(self) -> bool
	        

class ida_hexrays.cblock_t():
	
	    Proxy of C++ cblock_t class
	    

ida_hexrays.cblock_t.back():
	
	        back(self) -> cinsn_t
	        back(self) -> cinsn_t
	        

ida_hexrays.cblock_t.begin():
	
	        begin(self) -> qlist_cinsn_t_iterator
	        

ida_hexrays.cblock_t.clear():
	
	        clear(self)
	        

ida_hexrays.cblock_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cblock_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.cblock_t.end():
	
	        end(self) -> qlist_cinsn_t_iterator
	        

ida_hexrays.cblock_t.erase():
	
	        erase(self, p) -> qlist< cinsn_t >::iterator
	        erase(self, p1, p2)
	        erase(self, p)
	        

ida_hexrays.cblock_t.front():
	
	        front(self) -> cinsn_t
	        front(self) -> cinsn_t
	        

ida_hexrays.cblock_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.cblock_t.pop_front():
	
	        pop_front(self)
	        

ida_hexrays.cblock_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> cinsn_t
	        

ida_hexrays.cblock_t.push_front():
	
	        push_front(self, x)
	        

ida_hexrays.cblock_t.rbegin():
	
	        rbegin(self) -> qlist< cinsn_t >::reverse_iterator
	        rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
	        

ida_hexrays.cblock_t.rend():
	
	        rend(self) -> qlist< cinsn_t >::reverse_iterator
	        rend(self) -> qlist< cinsn_t >::const_reverse_iterator
	        

ida_hexrays.cblock_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.cblock_t.swap():
	
	        swap(self, x)
	        

class ida_hexrays.ccase_t():
	
	    Proxy of C++ ccase_t class
	    

ida_hexrays.ccase_t._print():
	
	        _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
	        

ida_hexrays.ccase_t.assign():
	
	        assign(self, r) -> cinsn_t
	        

ida_hexrays.ccase_t.cinsn:
	citem_t_cinsn_get(self) -> cinsn_t

ida_hexrays.ccase_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.ccase_t.collect_free_breaks():
	
	        collect_free_breaks(self, breaks) -> bool
	        

ida_hexrays.ccase_t.collect_free_continues():
	
	        collect_free_continues(self, continues) -> bool
	        

ida_hexrays.ccase_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.ccase_t.contains_expr():
	
	        contains_expr(self, e) -> bool
	        

ida_hexrays.ccase_t.contains_free_break():
	
	        contains_free_break(self) -> bool
	        

ida_hexrays.ccase_t.contains_free_continue():
	
	        contains_free_continue(self) -> bool
	        

ida_hexrays.ccase_t.contains_insn():
	
	        contains_insn(self, type, times=1) -> bool
	        

ida_hexrays.ccase_t.contains_label():
	
	        contains_label(self) -> bool
	        

ida_hexrays.ccase_t.create_if():
	
	        create_if(self, cnd) -> cif_t
	        

ida_hexrays.ccase_t.details:
	
	     return the details pointer for the cinsn_t object depending on the value of its op member.         this is one of the cblock_t, cif_t, etc. objects. 
	

ida_hexrays.ccase_t.ea:
	citem_t_ea_get(self) -> ea_t

ida_hexrays.ccase_t.find_closest_addr():
	
	        find_closest_addr(self, _ea) -> citem_t
	        

ida_hexrays.ccase_t.find_parent_of():
	
	        find_parent_of(self, sitem) -> citem_t
	        find_parent_of(self, item) -> citem_t
	        

ida_hexrays.ccase_t.index:
	citem_t_index_get(self) -> int

ida_hexrays.ccase_t.insn_is_epilog():
	
	        insn_is_epilog(insn) -> bool
	        

ida_hexrays.ccase_t.is_expr():
	
	        is_expr(self) -> bool
	        

ida_hexrays.ccase_t.is_ordinary_flow():
	
	        is_ordinary_flow(self) -> bool
	        

ida_hexrays.ccase_t.label_num:
	citem_t_label_num_get(self) -> int

ida_hexrays.ccase_t.new_insn():
	
	        new_insn(self, insn_ea) -> cinsn_t
	        

ida_hexrays.ccase_t.obj_id:
	
	        _obj_id(self) -> PyObject *
	        

ida_hexrays.ccase_t.op:
	
	        _get_op(self) -> ctype_t
	        

ida_hexrays.ccase_t.print1():
	
	        print1(self, func)
	        

ida_hexrays.ccase_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.ccase_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.ccase_t.to_specific_type:
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.ccase_t.value():
	
	        value(self, i) -> uint64 const &
	        

ida_hexrays.ccase_t.values:
	ccase_t_values_get(self) -> uint64vec_t *

ida_hexrays.ccase_t.zero():
	
	        zero(self)
	        

class ida_hexrays.ccases_t():
	
	    Proxy of C++ ccases_t class
	    

ida_hexrays.ccases_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.ccases_t.at():
	
	        __getitem__(self, i) -> ccase_t
	        

ida_hexrays.ccases_t.begin():
	
	        begin(self) -> ccase_t
	        begin(self) -> ccase_t
	        

ida_hexrays.ccases_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.ccases_t.clear():
	
	        clear(self)
	        

ida_hexrays.ccases_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.ccases_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.ccases_t.end():
	
	        end(self) -> ccase_t
	        end(self) -> ccase_t
	        

ida_hexrays.ccases_t.erase():
	
	        erase(self, it) -> ccase_t
	        erase(self, first, last) -> ccase_t
	        

ida_hexrays.ccases_t.extract():
	
	        extract(self) -> ccase_t
	        

ida_hexrays.ccases_t.find():
	
	        find(self, x) -> ccase_t
	        find(self, x) -> ccase_t
	        

ida_hexrays.ccases_t.grow():
	
	        grow(self, x=ccase_t())
	        

ida_hexrays.ccases_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.ccases_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.ccases_t.insert():
	
	        insert(self, it, x) -> ccase_t
	        

ida_hexrays.ccases_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.ccases_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> ccase_t
	        

ida_hexrays.ccases_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.ccases_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.ccases_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.ccases_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.ccases_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.ccases_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.cdo_t():
	
	    Proxy of C++ cdo_t class
	    

ida_hexrays.cdo_t.assign():
	
	        assign(self, r) -> cloop_t
	        

ida_hexrays.cdo_t.body:
	cloop_t_body_get(self) -> cinsn_t

ida_hexrays.cdo_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cdo_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cdo_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

class ida_hexrays.ceinsn_t():
	
	    Proxy of C++ ceinsn_t class
	    

ida_hexrays.ceinsn_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

ida_hexrays.cexpr_operands():
	
	     return a dictionary with the operands of a cexpr_t. 
	    

class ida_hexrays.cexpr_t():
	
	    Proxy of C++ cexpr_t class
	    

ida_hexrays.cexpr_t.assign():
	
	        assign(self, r) -> cexpr_t
	        

ida_hexrays.cexpr_t.calc_type():
	
	        calc_type(self, recursive)
	        

ida_hexrays.cexpr_t.cexpr:
	citem_t_cexpr_get(self) -> cexpr_t

ida_hexrays.cexpr_t.cinsn:
	citem_t_cinsn_get(self) -> cinsn_t

ida_hexrays.cexpr_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cexpr_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cexpr_t.contains_comma():
	
	        contains_comma(self, times=1) -> bool
	        

ida_hexrays.cexpr_t.contains_comma_or_insn_or_label():
	
	        contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
	        

ida_hexrays.cexpr_t.contains_expr():
	
	        contains_expr(self, e) -> bool
	        

ida_hexrays.cexpr_t.contains_insn():
	
	        contains_insn(self, times=1) -> bool
	        

ida_hexrays.cexpr_t.contains_insn_or_label():
	
	        contains_insn_or_label(self) -> bool
	        

ida_hexrays.cexpr_t.contains_label():
	
	        contains_label(self) -> bool
	        

ida_hexrays.cexpr_t.contains_operator():
	
	        contains_operator(self, needed_op, times=1) -> bool
	        

ida_hexrays.cexpr_t.cpadone():
	
	        cpadone(self) -> bool
	        

ida_hexrays.cexpr_t.ea:
	citem_t_ea_get(self) -> ea_t

ida_hexrays.cexpr_t.equal_effect():
	
	        equal_effect(self, r) -> bool
	        

ida_hexrays.cexpr_t.exflags:
	cexpr_t_exflags_get(self) -> uint32

ida_hexrays.cexpr_t.find_closest_addr():
	
	        find_closest_addr(self, _ea) -> citem_t
	        

ida_hexrays.cexpr_t.find_num_op():
	
	        find_num_op(self) -> cexpr_t
	        find_num_op(self) -> cexpr_t
	        

ida_hexrays.cexpr_t.find_op():
	
	        find_op(self, _op) -> cexpr_t
	        find_op(self, _op) -> cexpr_t
	        

ida_hexrays.cexpr_t.find_parent_of():
	
	        find_parent_of(self, sitem) -> citem_t
	        find_parent_of(self, item) -> citem_t
	        

ida_hexrays.cexpr_t.get_1num_op():
	
	        get_1num_op(self, o1, o2) -> bool
	        

ida_hexrays.cexpr_t.get_const_value():
	
	        get_const_value(self) -> bool
	        

ida_hexrays.cexpr_t.get_high_nbit_bound():
	
	        get_high_nbit_bound(self) -> bit_bound_t
	        

ida_hexrays.cexpr_t.get_low_nbit_bound():
	
	        get_low_nbit_bound(self) -> int
	        

ida_hexrays.cexpr_t.get_ptr_or_array():
	
	        get_ptr_or_array(self) -> cexpr_t
	        

ida_hexrays.cexpr_t.get_type_sign():
	
	        get_type_sign(self) -> type_sign_t
	        

ida_hexrays.cexpr_t.get_v():
	
	        get_v(self) -> var_ref_t
	        

ida_hexrays.cexpr_t.has_side_effects():
	
	        has_side_effects(self) -> bool
	        

ida_hexrays.cexpr_t.index:
	citem_t_index_get(self) -> int

ida_hexrays.cexpr_t.is_call_arg_of():
	
	        is_call_arg_of(self, parent) -> bool
	        

ida_hexrays.cexpr_t.is_call_object_of():
	
	        is_call_object_of(self, parent) -> bool
	        

ida_hexrays.cexpr_t.is_child_of():
	
	        is_child_of(self, parent) -> bool
	        

ida_hexrays.cexpr_t.is_const_value():
	
	        is_const_value(self, _v) -> bool
	        

ida_hexrays.cexpr_t.is_cstr():
	
	        is_cstr(self) -> bool
	        

ida_hexrays.cexpr_t.is_expr():
	
	        is_expr(self) -> bool
	        

ida_hexrays.cexpr_t.is_fpop():
	
	        is_fpop(self) -> bool
	        

ida_hexrays.cexpr_t.is_jumpout():
	
	        is_jumpout(self) -> bool
	        

ida_hexrays.cexpr_t.is_negative_const():
	
	        is_negative_const(self) -> bool
	        

ida_hexrays.cexpr_t.is_nice_cond():
	
	        is_nice_cond(self) -> bool
	        

ida_hexrays.cexpr_t.is_nice_expr():
	
	        is_nice_expr(self) -> bool
	        

ida_hexrays.cexpr_t.is_non_negative_const():
	
	        is_non_negative_const(self) -> bool
	        

ida_hexrays.cexpr_t.is_non_zero_const():
	
	        is_non_zero_const(self) -> bool
	        

ida_hexrays.cexpr_t.is_odd_lvalue():
	
	        is_odd_lvalue(self) -> bool
	        

ida_hexrays.cexpr_t.is_type_signed():
	
	        is_type_signed(self) -> bool
	        

ida_hexrays.cexpr_t.is_type_unsigned():
	
	        is_type_unsigned(self) -> bool
	        

ida_hexrays.cexpr_t.is_undef_val():
	
	        is_undef_val(self) -> bool
	        

ida_hexrays.cexpr_t.is_vftable():
	
	        is_vftable(self) -> bool
	        

ida_hexrays.cexpr_t.is_zero_const():
	
	        is_zero_const(self) -> bool
	        

ida_hexrays.cexpr_t.label_num:
	citem_t_label_num_get(self) -> int

ida_hexrays.cexpr_t.maybe_ptr():
	
	        maybe_ptr(self) -> bool
	        

ida_hexrays.cexpr_t.numval():
	
	        numval(self) -> uint64
	        

ida_hexrays.cexpr_t.obj_id:
	
	        _obj_id(self) -> PyObject *
	        

ida_hexrays.cexpr_t.op:
	
	        _get_op(self) -> ctype_t
	        

ida_hexrays.cexpr_t.operands:
	
	     return a dictionary with the operands of a cexpr_t. 
	    

ida_hexrays.cexpr_t.print1():
	
	        print1(self, func)
	        

ida_hexrays.cexpr_t.put_number():
	
	        put_number(self, func, value, nbytes, sign=no_sign)
	        

ida_hexrays.cexpr_t.requires_lvalue():
	
	        requires_lvalue(self, child) -> bool
	        

ida_hexrays.cexpr_t.set_cpadone():
	
	        set_cpadone(self)
	        

ida_hexrays.cexpr_t.set_v():
	
	        set_v(self, v)
	        

ida_hexrays.cexpr_t.set_vftable():
	
	        set_vftable(self)
	        

ida_hexrays.cexpr_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.cexpr_t.theother():
	
	        theother(self, what) -> cexpr_t
	        theother(self, what) -> cexpr_t
	        

ida_hexrays.cexpr_t.to_specific_type:
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.cexpr_t.type:
	cexpr_t_type_get(self) -> tinfo_t

class ida_hexrays.cfor_t():
	
	    Proxy of C++ cfor_t class
	    

ida_hexrays.cfor_t.assign():
	
	        assign(self, r) -> cloop_t
	        

ida_hexrays.cfor_t.body:
	cloop_t_body_get(self) -> cinsn_t

ida_hexrays.cfor_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cfor_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cfor_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

ida_hexrays.cfor_t.init:
	cfor_t_init_get(self) -> cexpr_t

ida_hexrays.cfor_t.step:
	cfor_t_step_get(self) -> cexpr_t

class ida_hexrays.cfunc_parentee_t():
	
	    Proxy of C++ cfunc_parentee_t class
	    

ida_hexrays.cfunc_parentee_t.apply_to():
	
	        apply_to(self, item, parent) -> int
	        

ida_hexrays.cfunc_parentee_t.apply_to_exprs():
	
	        apply_to_exprs(self, item, parent) -> int
	        

ida_hexrays.cfunc_parentee_t.calc_rvalue_type():
	
	        calc_rvalue_type(self, target, e) -> bool
	        

ida_hexrays.cfunc_parentee_t.clr_prune():
	
	        clr_prune(self)
	        

ida_hexrays.cfunc_parentee_t.clr_restart():
	
	        clr_restart(self)
	        

ida_hexrays.cfunc_parentee_t.cv_flags:
	ctree_visitor_t_cv_flags_get(self) -> int

ida_hexrays.cfunc_parentee_t.func:
	cfunc_parentee_t_func_get(self) -> cfunc_t

ida_hexrays.cfunc_parentee_t.is_postorder():
	
	        is_postorder(self) -> bool
	        

ida_hexrays.cfunc_parentee_t.leave_expr():
	
	        leave_expr(self, arg0) -> int
	        

ida_hexrays.cfunc_parentee_t.leave_insn():
	
	        leave_insn(self, arg0) -> int
	        

ida_hexrays.cfunc_parentee_t.maintain_parents():
	
	        maintain_parents(self) -> bool
	        

ida_hexrays.cfunc_parentee_t.must_prune():
	
	        must_prune(self) -> bool
	        

ida_hexrays.cfunc_parentee_t.must_restart():
	
	        must_restart(self) -> bool
	        

ida_hexrays.cfunc_parentee_t.only_insns():
	
	        only_insns(self) -> bool
	        

ida_hexrays.cfunc_parentee_t.parent_expr():
	
	        parent_expr(self) -> cexpr_t
	        

ida_hexrays.cfunc_parentee_t.parent_insn():
	
	        parent_insn(self) -> cinsn_t
	        

ida_hexrays.cfunc_parentee_t.parents:
	ctree_visitor_t_parents_get(self) -> ctree_items_t

ida_hexrays.cfunc_parentee_t.prune_now():
	
	        prune_now(self)
	        

ida_hexrays.cfunc_parentee_t.recalc_parent_types():
	
	        recalc_parent_types(self) -> bool
	        

ida_hexrays.cfunc_parentee_t.set_restart():
	
	        set_restart(self)
	        

ida_hexrays.cfunc_parentee_t.visit_expr():
	
	        visit_expr(self, arg0) -> int
	        

ida_hexrays.cfunc_parentee_t.visit_insn():
	
	        visit_insn(self, arg0) -> int
	        

class ida_hexrays.cfunc_t():
	
	    Proxy of C++ cfunc_t class
	    

ida_hexrays.cfunc_t.argidx:
	cfunc_t_argidx_get(self) -> intvec_t &

ida_hexrays.cfunc_t.body:
	cfunc_t_body_get(self) -> cinsn_t

ida_hexrays.cfunc_t.boundaries:
	
	        get_boundaries(self) -> boundaries_t
	        

ida_hexrays.cfunc_t.build_c_tree():
	
	        build_c_tree(self)
	        

ida_hexrays.cfunc_t.del_orphan_cmts():
	
	        del_orphan_cmts(self) -> int
	        

ida_hexrays.cfunc_t.eamap:
	
	        get_eamap(self) -> eamap_t
	        

ida_hexrays.cfunc_t.entry_ea:
	cfunc_t_entry_ea_get(self) -> ea_t

ida_hexrays.cfunc_t.find_item_coords():
	
	        find_item_coords(self, item, px, py) -> bool
	        find_item_coords(self, item) -> PyObject *
	        

ida_hexrays.cfunc_t.find_label():
	
	        find_label(self, label) -> citem_t
	        

ida_hexrays.cfunc_t.gather_derefs():
	
	        gather_derefs(self, ci, udm=None) -> bool
	        

ida_hexrays.cfunc_t.get_boundaries():
	
	        get_boundaries(self) -> boundaries_t
	        

ida_hexrays.cfunc_t.get_eamap():
	
	        get_eamap(self) -> eamap_t
	        

ida_hexrays.cfunc_t.get_func_type():
	
	        get_func_type(self, type) -> bool
	        

ida_hexrays.cfunc_t.get_line_item():
	
	        get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
	        

ida_hexrays.cfunc_t.get_lvars():
	
	        get_lvars(self) -> lvars_t
	        

ida_hexrays.cfunc_t.get_pseudocode():
	
	        get_pseudocode(self) -> strvec_t const &
	        

ida_hexrays.cfunc_t.get_stkoff_delta():
	
	        get_stkoff_delta(self) -> sval_t
	        

ida_hexrays.cfunc_t.get_user_cmt():
	
	        get_user_cmt(self, loc, rt) -> char const *
	        

ida_hexrays.cfunc_t.get_user_iflags():
	
	        get_user_iflags(self, loc) -> int32
	        

ida_hexrays.cfunc_t.get_user_union_selection():
	
	        get_user_union_selection(self, ea, path) -> bool
	        

ida_hexrays.cfunc_t.get_warnings():
	
	        get_warnings(self) -> hexwarns_t
	        

ida_hexrays.cfunc_t.has_orphan_cmts():
	
	        has_orphan_cmts(self) -> bool
	        

ida_hexrays.cfunc_t.hdrlines:
	cfunc_t_hdrlines_get(self) -> int

ida_hexrays.cfunc_t.lvars:
	
	        get_lvars(self) -> lvars_t
	        

ida_hexrays.cfunc_t.maturity:
	cfunc_t_maturity_get(self) -> ctree_maturity_t

ida_hexrays.cfunc_t.mba:
	cfunc_t_mba_get(self) -> mbl_array_t *

ida_hexrays.cfunc_t.numforms:
	cfunc_t_numforms_get(self) -> user_numforms_t

ida_hexrays.cfunc_t.print_dcl():
	
	        print_dcl(self)
	        

ida_hexrays.cfunc_t.print_func():
	
	        print_func(self, vp)
	        

ida_hexrays.cfunc_t.pseudocode:
	
	        get_pseudocode(self) -> strvec_t const &
	        

ida_hexrays.cfunc_t.refcnt:
	cfunc_t_refcnt_get(self) -> int

ida_hexrays.cfunc_t.release():
	
	        release(self)
	        

ida_hexrays.cfunc_t.remove_unused_labels():
	
	        remove_unused_labels(self)
	        

ida_hexrays.cfunc_t.save_user_cmts():
	
	        save_user_cmts(self)
	        

ida_hexrays.cfunc_t.save_user_iflags():
	
	        save_user_iflags(self)
	        

ida_hexrays.cfunc_t.save_user_labels():
	
	        save_user_labels(self)
	        

ida_hexrays.cfunc_t.save_user_numforms():
	
	        save_user_numforms(self)
	        

ida_hexrays.cfunc_t.save_user_unions():
	
	        save_user_unions(self)
	        

ida_hexrays.cfunc_t.set_user_cmt():
	
	        set_user_cmt(self, loc, cmt)
	        

ida_hexrays.cfunc_t.set_user_iflags():
	
	        set_user_iflags(self, loc, iflags)
	        

ida_hexrays.cfunc_t.set_user_union_selection():
	
	        set_user_union_selection(self, ea, path)
	        

ida_hexrays.cfunc_t.statebits:
	cfunc_t_statebits_get(self) -> int

ida_hexrays.cfunc_t.treeitems:
	cfunc_t_treeitems_get(self) -> ctree_items_t

ida_hexrays.cfunc_t.type:
	
	     Get the function's return type tinfo_t object. 
	    

ida_hexrays.cfunc_t.user_cmts:
	cfunc_t_user_cmts_get(self) -> user_cmts_t

ida_hexrays.cfunc_t.user_iflags:
	cfunc_t_user_iflags_get(self) -> user_iflags_t

ida_hexrays.cfunc_t.user_labels:
	cfunc_t_user_labels_get(self) -> user_labels_t

ida_hexrays.cfunc_t.user_unions:
	cfunc_t_user_unions_get(self) -> user_unions_t

ida_hexrays.cfunc_t.verify():
	
	        verify(self, aul, even_without_debugger)
	        

ida_hexrays.cfunc_t.warnings:
	
	        get_warnings(self) -> hexwarns_t
	        

ida_hexrays.cfunc_type():
	
	     Get the function's return type tinfo_t object. 
	    

class ida_hexrays.cfuncptr_t():
	
	    Proxy of C++ qrefcnt_t<(cfunc_t)> class
	    

ida_hexrays.cfuncptr_t.argidx:
	cfuncptr_t_argidx_get(self) -> intvec_t &

ida_hexrays.cfuncptr_t.body:
	cfuncptr_t_body_get(self) -> cinsn_t

ida_hexrays.cfuncptr_t.build_c_tree():
	
	        build_c_tree(self)
	        

ida_hexrays.cfuncptr_t.del_orphan_cmts():
	
	        del_orphan_cmts(self) -> int
	        

ida_hexrays.cfuncptr_t.entry_ea:
	cfuncptr_t_entry_ea_get(self) -> ea_t

ida_hexrays.cfuncptr_t.find_item_coords():
	
	        find_item_coords(self, item, px, py) -> bool
	        find_item_coords(self, item) -> PyObject *
	        

ida_hexrays.cfuncptr_t.find_label():
	
	        find_label(self, label) -> citem_t
	        

ida_hexrays.cfuncptr_t.gather_derefs():
	
	        gather_derefs(self, ci, udm=None) -> bool
	        

ida_hexrays.cfuncptr_t.get_boundaries():
	
	        get_boundaries(self) -> boundaries_t
	        

ida_hexrays.cfuncptr_t.get_eamap():
	
	        get_eamap(self) -> eamap_t
	        

ida_hexrays.cfuncptr_t.get_func_type():
	
	        get_func_type(self, type) -> bool
	        

ida_hexrays.cfuncptr_t.get_line_item():
	
	        get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
	        

ida_hexrays.cfuncptr_t.get_lvars():
	
	        get_lvars(self) -> lvars_t
	        

ida_hexrays.cfuncptr_t.get_pseudocode():
	
	        get_pseudocode(self) -> strvec_t const &
	        

ida_hexrays.cfuncptr_t.get_stkoff_delta():
	
	        get_stkoff_delta(self) -> sval_t
	        

ida_hexrays.cfuncptr_t.get_user_cmt():
	
	        get_user_cmt(self, loc, rt) -> char const *
	        

ida_hexrays.cfuncptr_t.get_user_iflags():
	
	        get_user_iflags(self, loc) -> int32
	        

ida_hexrays.cfuncptr_t.get_user_union_selection():
	
	        get_user_union_selection(self, ea, path) -> bool
	        

ida_hexrays.cfuncptr_t.get_warnings():
	
	        get_warnings(self) -> hexwarns_t
	        

ida_hexrays.cfuncptr_t.has_orphan_cmts():
	
	        has_orphan_cmts(self) -> bool
	        

ida_hexrays.cfuncptr_t.hdrlines:
	cfuncptr_t_hdrlines_get(self) -> int

ida_hexrays.cfuncptr_t.maturity:
	cfuncptr_t_maturity_get(self) -> ctree_maturity_t

ida_hexrays.cfuncptr_t.mba:
	cfuncptr_t_mba_get(self) -> mbl_array_t *

ida_hexrays.cfuncptr_t.numforms:
	cfuncptr_t_numforms_get(self) -> user_numforms_t

ida_hexrays.cfuncptr_t.print_dcl():
	
	        print_dcl(self)
	        

ida_hexrays.cfuncptr_t.print_func():
	
	        print_func(self, vp)
	        

ida_hexrays.cfuncptr_t.refcnt:
	cfuncptr_t_refcnt_get(self) -> int

ida_hexrays.cfuncptr_t.release():
	
	        release(self)
	        

ida_hexrays.cfuncptr_t.remove_unused_labels():
	
	        remove_unused_labels(self)
	        

ida_hexrays.cfuncptr_t.reset():
	
	        reset(self)
	        

ida_hexrays.cfuncptr_t.save_user_cmts():
	
	        save_user_cmts(self)
	        

ida_hexrays.cfuncptr_t.save_user_iflags():
	
	        save_user_iflags(self)
	        

ida_hexrays.cfuncptr_t.save_user_labels():
	
	        save_user_labels(self)
	        

ida_hexrays.cfuncptr_t.save_user_numforms():
	
	        save_user_numforms(self)
	        

ida_hexrays.cfuncptr_t.save_user_unions():
	
	        save_user_unions(self)
	        

ida_hexrays.cfuncptr_t.set_user_cmt():
	
	        set_user_cmt(self, loc, cmt)
	        

ida_hexrays.cfuncptr_t.set_user_iflags():
	
	        set_user_iflags(self, loc, iflags)
	        

ida_hexrays.cfuncptr_t.set_user_union_selection():
	
	        set_user_union_selection(self, ea, path)
	        

ida_hexrays.cfuncptr_t.statebits:
	cfuncptr_t_statebits_get(self) -> int

ida_hexrays.cfuncptr_t.treeitems:
	cfuncptr_t_treeitems_get(self) -> ctree_items_t

ida_hexrays.cfuncptr_t.user_cmts:
	cfuncptr_t_user_cmts_get(self) -> user_cmts_t

ida_hexrays.cfuncptr_t.user_iflags:
	cfuncptr_t_user_iflags_get(self) -> user_iflags_t

ida_hexrays.cfuncptr_t.user_labels:
	cfuncptr_t_user_labels_get(self) -> user_labels_t

ida_hexrays.cfuncptr_t.user_unions:
	cfuncptr_t_user_unions_get(self) -> user_unions_t

ida_hexrays.cfuncptr_t.verify():
	
	        verify(self, aul, even_without_debugger)
	        

class ida_hexrays.cgoto_t():
	
	    Proxy of C++ cgoto_t class
	    

ida_hexrays.cgoto_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cgoto_t.label_num:
	cgoto_t_label_num_get(self) -> int

class ida_hexrays.cif_t():
	
	    Proxy of C++ cif_t class
	    

ida_hexrays.cif_t.assign():
	
	        assign(self, r) -> cif_t
	        

ida_hexrays.cif_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cif_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cif_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

ida_hexrays.cif_t.ielse:
	cif_t_ielse_get(self) -> cinsn_t

ida_hexrays.cif_t.ithen:
	cif_t_ithen_get(self) -> cinsn_t

ida_hexrays.cinsn_details():
	
	     return the details pointer for the cinsn_t object depending on the value of its op member.         this is one of the cblock_t, cif_t, etc. objects. 
	

class ida_hexrays.cinsn_t():
	
	    Proxy of C++ cinsn_t class
	    

ida_hexrays.cinsn_t._print():
	
	        _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
	        

ida_hexrays.cinsn_t.assign():
	
	        assign(self, r) -> cinsn_t
	        

ida_hexrays.cinsn_t.cinsn:
	citem_t_cinsn_get(self) -> cinsn_t

ida_hexrays.cinsn_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cinsn_t.collect_free_breaks():
	
	        collect_free_breaks(self, breaks) -> bool
	        

ida_hexrays.cinsn_t.collect_free_continues():
	
	        collect_free_continues(self, continues) -> bool
	        

ida_hexrays.cinsn_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cinsn_t.contains_expr():
	
	        contains_expr(self, e) -> bool
	        

ida_hexrays.cinsn_t.contains_free_break():
	
	        contains_free_break(self) -> bool
	        

ida_hexrays.cinsn_t.contains_free_continue():
	
	        contains_free_continue(self) -> bool
	        

ida_hexrays.cinsn_t.contains_insn():
	
	        contains_insn(self, type, times=1) -> bool
	        

ida_hexrays.cinsn_t.contains_label():
	
	        contains_label(self) -> bool
	        

ida_hexrays.cinsn_t.create_if():
	
	        create_if(self, cnd) -> cif_t
	        

ida_hexrays.cinsn_t.details:
	
	     return the details pointer for the cinsn_t object depending on the value of its op member.         this is one of the cblock_t, cif_t, etc. objects. 
	

ida_hexrays.cinsn_t.ea:
	citem_t_ea_get(self) -> ea_t

ida_hexrays.cinsn_t.find_closest_addr():
	
	        find_closest_addr(self, _ea) -> citem_t
	        

ida_hexrays.cinsn_t.find_parent_of():
	
	        find_parent_of(self, sitem) -> citem_t
	        find_parent_of(self, item) -> citem_t
	        

ida_hexrays.cinsn_t.index:
	citem_t_index_get(self) -> int

ida_hexrays.cinsn_t.insn_is_epilog():
	
	        insn_is_epilog(insn) -> bool
	        

ida_hexrays.cinsn_t.is_expr():
	
	        is_expr(self) -> bool
	        

ida_hexrays.cinsn_t.is_ordinary_flow():
	
	        is_ordinary_flow(self) -> bool
	        

ida_hexrays.cinsn_t.label_num:
	citem_t_label_num_get(self) -> int

ida_hexrays.cinsn_t.new_insn():
	
	        new_insn(self, insn_ea) -> cinsn_t
	        

ida_hexrays.cinsn_t.obj_id:
	
	        _obj_id(self) -> PyObject *
	        

ida_hexrays.cinsn_t.op:
	
	        _get_op(self) -> ctype_t
	        

ida_hexrays.cinsn_t.print1():
	
	        print1(self, func)
	        

ida_hexrays.cinsn_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.cinsn_t.to_specific_type:
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.cinsn_t.zero():
	
	        zero(self)
	        

ida_hexrays.cinsn_t_insn_is_epilog():
	
	  cinsn_t_insn_is_epilog(insn) -> bool
	  

class ida_hexrays.cinsnptrvec_t():
	
	    Proxy of C++ qvector<(p.cinsn_t)> class
	    

ida_hexrays.cinsnptrvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.cinsnptrvec_t.at():
	
	        __getitem__(self, i) -> cinsn_t
	        

ida_hexrays.cinsnptrvec_t.begin():
	
	        begin(self) -> qvector< cinsn_t * >::iterator
	        begin(self) -> qvector< cinsn_t * >::const_iterator
	        

ida_hexrays.cinsnptrvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.cinsnptrvec_t.clear():
	
	        clear(self)
	        

ida_hexrays.cinsnptrvec_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.cinsnptrvec_t.end():
	
	        end(self) -> qvector< cinsn_t * >::iterator
	        end(self) -> qvector< cinsn_t * >::const_iterator
	        

ida_hexrays.cinsnptrvec_t.erase():
	
	        erase(self, it) -> qvector< cinsn_t * >::iterator
	        erase(self, first, last) -> qvector< cinsn_t * >::iterator
	        

ida_hexrays.cinsnptrvec_t.extract():
	
	        extract(self) -> cinsn_t **
	        

ida_hexrays.cinsnptrvec_t.find():
	
	        find(self, x) -> qvector< cinsn_t * >::iterator
	        find(self, x) -> qvector< cinsn_t * >::const_iterator
	        

ida_hexrays.cinsnptrvec_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.cinsnptrvec_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.cinsnptrvec_t.insert():
	
	        insert(self, it, x) -> qvector< cinsn_t * >::iterator
	        

ida_hexrays.cinsnptrvec_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.cinsnptrvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> cinsn_t *&
	        

ida_hexrays.cinsnptrvec_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.cinsnptrvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.cinsnptrvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.cinsnptrvec_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.cinsnptrvec_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.cinsnptrvec_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.citem_cmt_t():
	
	    Proxy of C++ citem_cmt_t class
	    

ida_hexrays.citem_cmt_t.c_str():
	
	        c_str(self) -> char const *
	        

ida_hexrays.citem_cmt_t.used:
	citem_cmt_t_used_get(self) -> bool

class ida_hexrays.citem_locator_t():
	
	    Proxy of C++ citem_locator_t class
	    

ida_hexrays.citem_locator_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.citem_locator_t.ea:
	citem_locator_t_ea_get(self) -> ea_t

ida_hexrays.citem_locator_t.op:
	citem_locator_t_op_get(self) -> ctype_t

class ida_hexrays.citem_t():
	
	    Proxy of C++ citem_t class
	    

ida_hexrays.citem_t.cexpr:
	citem_t_cexpr_get(self) -> cexpr_t

ida_hexrays.citem_t.cinsn:
	citem_t_cinsn_get(self) -> cinsn_t

ida_hexrays.citem_t.contains_expr():
	
	        contains_expr(self, e) -> bool
	        

ida_hexrays.citem_t.contains_label():
	
	        contains_label(self) -> bool
	        

ida_hexrays.citem_t.ea:
	citem_t_ea_get(self) -> ea_t

ida_hexrays.citem_t.find_closest_addr():
	
	        find_closest_addr(self, _ea) -> citem_t
	        

ida_hexrays.citem_t.find_parent_of():
	
	        find_parent_of(self, sitem) -> citem_t
	        find_parent_of(self, item) -> citem_t
	        

ida_hexrays.citem_t.index:
	citem_t_index_get(self) -> int

ida_hexrays.citem_t.is_expr():
	
	        is_expr(self) -> bool
	        

ida_hexrays.citem_t.label_num:
	citem_t_label_num_get(self) -> int

ida_hexrays.citem_t.obj_id:
	
	        _obj_id(self) -> PyObject *
	        

ida_hexrays.citem_t.op:
	
	        _get_op(self) -> ctype_t
	        

ida_hexrays.citem_t.print1():
	
	        print1(self, func)
	        

ida_hexrays.citem_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.citem_t.to_specific_type:
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.citem_to_specific_type():
	
	     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
	    

ida_hexrays.clear_cached_cfuncs():
	
	  clear_cached_cfuncs()
	
	
	  Flush all cached decompilation results.
	  

class ida_hexrays.cloop_t():
	
	    Proxy of C++ cloop_t class
	    

ida_hexrays.cloop_t.assign():
	
	        assign(self, r) -> cloop_t
	        

ida_hexrays.cloop_t.body:
	cloop_t_body_get(self) -> cinsn_t

ida_hexrays.cloop_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cloop_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

ida_hexrays.close_pseudocode():
	
	  close_pseudocode(f) -> bool
	
	
	  Close pseudocode window.
	  
	  @param f: pointer to window (C++: TWidget *)
	  @return: false if failed
	  

class ida_hexrays.cnumber_t():
	
	    Proxy of C++ cnumber_t class
	    

ida_hexrays.cnumber_t._print():
	
	        _print(self, type, parent=None, nice_stroff=None)
	        

ida_hexrays.cnumber_t.assign():
	
	        assign(self, v, nbytes, sign)
	        

ida_hexrays.cnumber_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cnumber_t.nf:
	cnumber_t_nf_get(self) -> number_format_t

ida_hexrays.cnumber_t.value():
	
	        value(self, type) -> uint64
	        

class ida_hexrays.codegen_t():
	
	    Proxy of C++ codegen_t class
	    

ida_hexrays.codegen_t.analyze_prolog():
	
	        analyze_prolog(self, fc, reachable) -> merror_t
	        

ida_hexrays.codegen_t.emit():
	
	        emit(self, code, width, l, r, d, offsize) -> minsn_t
	        emit(self, code, l, r, d) -> minsn_t *
	        

ida_hexrays.codegen_t.emit_micro_mvm():
	
	        emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t *
	        

ida_hexrays.codegen_t.gen_micro():
	
	        gen_micro(self) -> merror_t
	        

ida_hexrays.codegen_t.ignore_micro:
	codegen_t_ignore_micro_get(self) -> char

ida_hexrays.codegen_t.insn:
	codegen_t_insn_get(self) -> insn_t *

ida_hexrays.codegen_t.load_operand():
	
	        load_operand(self, opnum) -> mreg_t
	        

ida_hexrays.codegen_t.mb:
	codegen_t_mb_get(self) -> mblock_t *

ida_hexrays.codegen_t.mba:
	codegen_t_mba_get(self) -> mbl_array_t *

ida_hexrays.compare():
	
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    

ida_hexrays.convert_to_user_call():
	
	  convert_to_user_call(udc, cdg) -> merror_t
	
	
	  try to generate user-defined call for an instruction
	  
	  @param udc (C++: const  udcall_t  &)
	  @param cdg (C++: codegen_t  &)
	  @return: Microcode error codes  code: MERR_OK - user-defined call
	           generated else - error (MERR_INSN == inacceptable udc.tif)
	  

ida_hexrays.create_field_name():
	
	  create_field_name(type, offset=BADADDR) -> qstring
	  

ida_hexrays.create_typedef():
	
	    create_typedef(name) -> tinfo_t
	    create_typedef(n) -> tinfo_t
	
	
	  Create a reference to a named type.
	  
	  @param name: type name (C++: const char *)
	  @return: type which refers to the specified name. For example, if name
	           is "DWORD", the type info which refers to "DWORD" is created.
	    

class ida_hexrays.creturn_t():
	
	    Proxy of C++ creturn_t class
	    

ida_hexrays.creturn_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.creturn_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

class ida_hexrays.cswitch_t():
	
	    Proxy of C++ cswitch_t class
	    

ida_hexrays.cswitch_t.cases:
	cswitch_t_cases_get(self) -> ccases_t

ida_hexrays.cswitch_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cswitch_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

ida_hexrays.cswitch_t.mvnf:
	cswitch_t_mvnf_get(self) -> cnumber_t

class ida_hexrays.ctext_position_t():
	
	    Proxy of C++ ctext_position_t class
	    

ida_hexrays.ctext_position_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.ctext_position_t.in_ctree():
	
	        in_ctree(self, hdrlines) -> bool
	        

ida_hexrays.ctext_position_t.lnnum:
	ctext_position_t_lnnum_get(self) -> int

ida_hexrays.ctext_position_t.x:
	ctext_position_t_x_get(self) -> int

ida_hexrays.ctext_position_t.y:
	ctext_position_t_y_get(self) -> int

class ida_hexrays.ctree_anchor_t():
	
	    Proxy of C++ ctree_anchor_t class
	    

ida_hexrays.ctree_anchor_t.get_index():
	
	        get_index(self) -> int
	        

ida_hexrays.ctree_anchor_t.get_itp():
	
	        get_itp(self) -> item_preciser_t
	        

ida_hexrays.ctree_anchor_t.is_blkcmt_anchor():
	
	        is_blkcmt_anchor(self) -> bool
	        

ida_hexrays.ctree_anchor_t.is_citem_anchor():
	
	        is_citem_anchor(self) -> bool
	        

ida_hexrays.ctree_anchor_t.is_itp_anchor():
	
	        is_itp_anchor(self) -> bool
	        

ida_hexrays.ctree_anchor_t.is_lvar_anchor():
	
	        is_lvar_anchor(self) -> bool
	        

ida_hexrays.ctree_anchor_t.is_valid_anchor():
	
	        is_valid_anchor(self) -> bool
	        

ida_hexrays.ctree_anchor_t.value:
	ctree_anchor_t_value_get(self) -> uval_t

class ida_hexrays.ctree_item_t():
	
	    Proxy of C++ ctree_item_t class
	    

ida_hexrays.ctree_item_t.citype:
	ctree_item_t_citype_get(self) -> cursor_item_type_t

ida_hexrays.ctree_item_t.get_ea():
	
	        get_ea(self) -> ea_t
	        

ida_hexrays.ctree_item_t.get_label_num():
	
	        get_label_num(self, gln_flags) -> int
	        

ida_hexrays.ctree_item_t.get_lvar():
	
	        get_lvar(self) -> lvar_t
	        

ida_hexrays.ctree_item_t.get_memptr():
	
	        get_memptr(self, p_sptr=None) -> member_t *
	        

ida_hexrays.ctree_item_t.is_citem():
	
	        is_citem(self) -> bool
	        

ida_hexrays.ctree_item_t.loc:
	ctree_item_t_loc_get(self) -> treeloc_t

class ida_hexrays.ctree_items_t():
	
	    Proxy of C++ qvector<(p.citem_t)> class
	    

ida_hexrays.ctree_items_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.ctree_items_t.at():
	
	        __getitem__(self, i) -> citem_t
	        

ida_hexrays.ctree_items_t.begin():
	
	        begin(self) -> qvector< citem_t * >::iterator
	        begin(self) -> qvector< citem_t * >::const_iterator
	        

ida_hexrays.ctree_items_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.ctree_items_t.clear():
	
	        clear(self)
	        

ida_hexrays.ctree_items_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.ctree_items_t.end():
	
	        end(self) -> qvector< citem_t * >::iterator
	        end(self) -> qvector< citem_t * >::const_iterator
	        

ida_hexrays.ctree_items_t.erase():
	
	        erase(self, it) -> qvector< citem_t * >::iterator
	        erase(self, first, last) -> qvector< citem_t * >::iterator
	        

ida_hexrays.ctree_items_t.extract():
	
	        extract(self) -> citem_t **
	        

ida_hexrays.ctree_items_t.find():
	
	        find(self, x) -> qvector< citem_t * >::iterator
	        find(self, x) -> qvector< citem_t * >::const_iterator
	        

ida_hexrays.ctree_items_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.ctree_items_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.ctree_items_t.insert():
	
	        insert(self, it, x) -> qvector< citem_t * >::iterator
	        

ida_hexrays.ctree_items_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.ctree_items_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> citem_t *&
	        

ida_hexrays.ctree_items_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.ctree_items_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.ctree_items_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.ctree_items_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.ctree_items_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.ctree_items_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.ctree_parentee_t():
	
	    Proxy of C++ ctree_parentee_t class
	    

ida_hexrays.ctree_parentee_t.apply_to():
	
	        apply_to(self, item, parent) -> int
	        

ida_hexrays.ctree_parentee_t.apply_to_exprs():
	
	        apply_to_exprs(self, item, parent) -> int
	        

ida_hexrays.ctree_parentee_t.clr_prune():
	
	        clr_prune(self)
	        

ida_hexrays.ctree_parentee_t.clr_restart():
	
	        clr_restart(self)
	        

ida_hexrays.ctree_parentee_t.cv_flags:
	ctree_visitor_t_cv_flags_get(self) -> int

ida_hexrays.ctree_parentee_t.is_postorder():
	
	        is_postorder(self) -> bool
	        

ida_hexrays.ctree_parentee_t.leave_expr():
	
	        leave_expr(self, arg0) -> int
	        

ida_hexrays.ctree_parentee_t.leave_insn():
	
	        leave_insn(self, arg0) -> int
	        

ida_hexrays.ctree_parentee_t.maintain_parents():
	
	        maintain_parents(self) -> bool
	        

ida_hexrays.ctree_parentee_t.must_prune():
	
	        must_prune(self) -> bool
	        

ida_hexrays.ctree_parentee_t.must_restart():
	
	        must_restart(self) -> bool
	        

ida_hexrays.ctree_parentee_t.only_insns():
	
	        only_insns(self) -> bool
	        

ida_hexrays.ctree_parentee_t.parent_expr():
	
	        parent_expr(self) -> cexpr_t
	        

ida_hexrays.ctree_parentee_t.parent_insn():
	
	        parent_insn(self) -> cinsn_t
	        

ida_hexrays.ctree_parentee_t.parents:
	ctree_visitor_t_parents_get(self) -> ctree_items_t

ida_hexrays.ctree_parentee_t.prune_now():
	
	        prune_now(self)
	        

ida_hexrays.ctree_parentee_t.recalc_parent_types():
	
	        recalc_parent_types(self) -> bool
	        

ida_hexrays.ctree_parentee_t.set_restart():
	
	        set_restart(self)
	        

ida_hexrays.ctree_parentee_t.visit_expr():
	
	        visit_expr(self, arg0) -> int
	        

ida_hexrays.ctree_parentee_t.visit_insn():
	
	        visit_insn(self, arg0) -> int
	        

class ida_hexrays.ctree_visitor_t():
	
	    Proxy of C++ ctree_visitor_t class
	    

ida_hexrays.ctree_visitor_t.apply_to():
	
	        apply_to(self, item, parent) -> int
	        

ida_hexrays.ctree_visitor_t.apply_to_exprs():
	
	        apply_to_exprs(self, item, parent) -> int
	        

ida_hexrays.ctree_visitor_t.clr_prune():
	
	        clr_prune(self)
	        

ida_hexrays.ctree_visitor_t.clr_restart():
	
	        clr_restart(self)
	        

ida_hexrays.ctree_visitor_t.cv_flags:
	ctree_visitor_t_cv_flags_get(self) -> int

ida_hexrays.ctree_visitor_t.is_postorder():
	
	        is_postorder(self) -> bool
	        

ida_hexrays.ctree_visitor_t.leave_expr():
	
	        leave_expr(self, arg0) -> int
	        

ida_hexrays.ctree_visitor_t.leave_insn():
	
	        leave_insn(self, arg0) -> int
	        

ida_hexrays.ctree_visitor_t.maintain_parents():
	
	        maintain_parents(self) -> bool
	        

ida_hexrays.ctree_visitor_t.must_prune():
	
	        must_prune(self) -> bool
	        

ida_hexrays.ctree_visitor_t.must_restart():
	
	        must_restart(self) -> bool
	        

ida_hexrays.ctree_visitor_t.only_insns():
	
	        only_insns(self) -> bool
	        

ida_hexrays.ctree_visitor_t.parent_expr():
	
	        parent_expr(self) -> cexpr_t
	        

ida_hexrays.ctree_visitor_t.parent_insn():
	
	        parent_insn(self) -> cinsn_t
	        

ida_hexrays.ctree_visitor_t.parents:
	ctree_visitor_t_parents_get(self) -> ctree_items_t

ida_hexrays.ctree_visitor_t.prune_now():
	
	        prune_now(self)
	        

ida_hexrays.ctree_visitor_t.set_restart():
	
	        set_restart(self)
	        

ida_hexrays.ctree_visitor_t.visit_expr():
	
	        visit_expr(self, arg0) -> int
	        

ida_hexrays.ctree_visitor_t.visit_insn():
	
	        visit_insn(self, arg0) -> int
	        

class ida_hexrays.cwhile_t():
	
	    Proxy of C++ cwhile_t class
	    

ida_hexrays.cwhile_t.assign():
	
	        assign(self, r) -> cloop_t
	        

ida_hexrays.cwhile_t.body:
	cloop_t_body_get(self) -> cinsn_t

ida_hexrays.cwhile_t.cleanup():
	
	        cleanup(self)
	        

ida_hexrays.cwhile_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.cwhile_t.expr:
	ceinsn_t_expr_get(self) -> cexpr_t

ida_hexrays.debug_hexrays_ctree():
	
	  debug_hexrays_ctree(msg)
	  

ida_hexrays.decompile_many():
	
	  decompile_many(outfile, funcaddrs, flags) -> bool
	
	
	  Batch decompilation. Decompile all or the specified functions
	  
	  @param outfile: name of the output file (C++: const char *)
	  @param funcaddrs: list of functions to decompile. If NULL or empty,
	                    then decompile all nonlib functions (C++: eavec_t
	                    *)
	  @param flags: Batch decompilation bits (C++: int)
	  @return: true if no internal error occurred and the user has not
	           cancelled decompilation
	  

ida_hexrays.dummy_ptrtype():
	
	  dummy_ptrtype(ptrsize, isfp) -> tinfo_t
	
	
	  Generate a dummy pointer type
	  
	  @param ptrsize: size of pointed object (C++: int)
	  @param isfp: is floating point object? (C++: bool)
	  

ida_hexrays.eamap_begin():
	
	  eamap_begin(map) -> eamap_iterator_t
	
	
	  Get iterator pointing to the beginning of eamap_t.
	  
	  
	  @param map (C++: const eamap_t *)
	  

ida_hexrays.eamap_clear():
	
	  eamap_clear(map)
	
	
	  Clear eamap_t.
	  
	  
	  @param map (C++: eamap_t *)
	  

ida_hexrays.eamap_end():
	
	  eamap_end(map) -> eamap_iterator_t
	
	
	  Get iterator pointing to the end of eamap_t.
	  
	  
	  @param map (C++: const eamap_t *)
	  

ida_hexrays.eamap_erase():
	
	  eamap_erase(map, p)
	
	
	  Erase current element from eamap_t.
	  
	  
	  @param map (C++: eamap_t *)
	  @param p (C++: eamap_iterator_t)
	  

ida_hexrays.eamap_find():
	
	  eamap_find(map, key) -> eamap_iterator_t
	
	
	  Find the specified key in eamap_t.
	  
	  
	  @param map (C++: const eamap_t *)
	  @param key (C++: const ea_t &)
	  

ida_hexrays.eamap_first():
	
	  eamap_first(p) -> ea_t const &
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: eamap_iterator_t)
	  

ida_hexrays.eamap_free():
	
	  eamap_free(map)
	
	
	  Delete eamap_t instance.
	  
	  
	  @param map (C++: eamap_t *)
	  

ida_hexrays.eamap_insert():
	
	  eamap_insert(map, key, val) -> eamap_iterator_t
	
	
	  Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
	  
	  
	  @param map (C++: eamap_t *)
	  @param key (C++: const ea_t &)
	  @param val (C++: const  cinsnptrvec_t  &)
	  

class ida_hexrays.eamap_iterator_t():
	
	    Proxy of C++ eamap_iterator_t class
	    

ida_hexrays.eamap_iterator_t.x:
	eamap_iterator_t_x_get(self) -> iterator_word

ida_hexrays.eamap_new():
	
	  eamap_new() -> eamap_t
	
	
	  Create a new eamap_t instance.
	  

ida_hexrays.eamap_next():
	
	  eamap_next(p) -> eamap_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: eamap_iterator_t)
	  

ida_hexrays.eamap_prev():
	
	  eamap_prev(p) -> eamap_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: eamap_iterator_t)
	  

ida_hexrays.eamap_second():
	
	  eamap_second(p) -> cinsnptrvec_t
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: eamap_iterator_t)
	  

ida_hexrays.eamap_size():
	
	  eamap_size(map) -> size_t
	
	
	  Get size of eamap_t.
	  
	  
	  @param map (C++: eamap_t *)
	  

class ida_hexrays.eamap_t():
	
	    Proxy of C++ std::map<(ea_t,cinsnptrvec_t)> class
	    

ida_hexrays.eamap_t.at():
	
	        at(self, _Keyval) -> cinsnptrvec_t
	        

ida_hexrays.eamap_t.keytype.bit_length():
	long.bit_length() -> int or long
	
	Number of bits necessary to represent self in binary.
	>>> bin(37L)
	'0b100101'
	>>> (37L).bit_length()
	6

ida_hexrays.eamap_t.keytype.conjugate():
	Returns self, the complex conjugate of any long.

ida_hexrays.eamap_t.keytype.denominator:
	the denominator of a rational number in lowest terms

ida_hexrays.eamap_t.keytype.imag:
	the imaginary part of a complex number

ida_hexrays.eamap_t.keytype.numerator:
	the numerator of a rational number in lowest terms

ida_hexrays.eamap_t.keytype.real:
	the real part of a complex number

ida_hexrays.eamap_t.pop():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.eamap_t.popitem():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.eamap_t.setdefault():
	
	         Sets the value associated with the provided key. 
	        

class ida_hexrays.eamap_t.valuetype():
	
	    Proxy of C++ qvector<(p.cinsn_t)> class
	    

ida_hexrays.eamap_t.valuetype.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.eamap_t.valuetype.at():
	
	        __getitem__(self, i) -> cinsn_t
	        

ida_hexrays.eamap_t.valuetype.begin():
	
	        begin(self) -> qvector< cinsn_t * >::iterator
	        begin(self) -> qvector< cinsn_t * >::const_iterator
	        

ida_hexrays.eamap_t.valuetype.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.eamap_t.valuetype.clear():
	
	        clear(self)
	        

ida_hexrays.eamap_t.valuetype.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.eamap_t.valuetype.end():
	
	        end(self) -> qvector< cinsn_t * >::iterator
	        end(self) -> qvector< cinsn_t * >::const_iterator
	        

ida_hexrays.eamap_t.valuetype.erase():
	
	        erase(self, it) -> qvector< cinsn_t * >::iterator
	        erase(self, first, last) -> qvector< cinsn_t * >::iterator
	        

ida_hexrays.eamap_t.valuetype.extract():
	
	        extract(self) -> cinsn_t **
	        

ida_hexrays.eamap_t.valuetype.find():
	
	        find(self, x) -> qvector< cinsn_t * >::iterator
	        find(self, x) -> qvector< cinsn_t * >::const_iterator
	        

ida_hexrays.eamap_t.valuetype.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.eamap_t.valuetype.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.eamap_t.valuetype.insert():
	
	        insert(self, it, x) -> qvector< cinsn_t * >::iterator
	        

ida_hexrays.eamap_t.valuetype.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.eamap_t.valuetype.push_back():
	
	        push_back(self, x)
	        push_back(self) -> cinsn_t *&
	        

ida_hexrays.eamap_t.valuetype.qclear():
	
	        qclear(self)
	        

ida_hexrays.eamap_t.valuetype.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.eamap_t.valuetype.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.eamap_t.valuetype.size():
	
	        size(self) -> size_t
	        

ida_hexrays.eamap_t.valuetype.swap():
	
	        swap(self, r)
	        

ida_hexrays.eamap_t.valuetype.truncate():
	
	        truncate(self)
	        

class ida_hexrays.fnum_array():
	
	    Proxy of C++ wrapped_array_t<(uint16,6)> class
	    

ida_hexrays.fnum_array.data:
	fnum_array_data_get(self) -> unsigned short (&)[6]

class ida_hexrays.fnumber_t():
	
	    Proxy of C++ fnumber_t class
	    

ida_hexrays.fnumber_t._print():
	
	        _print(self)
	        

ida_hexrays.fnumber_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.fnumber_t.dereference_const_uint16():
	
	        dereference_const_uint16(self) -> uint16 const *
	        

ida_hexrays.fnumber_t.dereference_uint16():
	
	        dereference_uint16(self) -> uint16 *
	        

ida_hexrays.fnumber_t.fnum:
	
	        __get_fnum(self) -> fnum_array
	        

ida_hexrays.fnumber_t.nbytes:
	fnumber_t_nbytes_get(self) -> int

ida_hexrays.get_ctype_name():
	
	  get_ctype_name(op) -> char const *
	  

ida_hexrays.get_float_type():
	
	  get_float_type(width) -> tinfo_t
	
	
	  Get a type of a floating point value with the specified width
	  
	  @param width: width of the desired type (C++: int)
	  @return: type info object
	  

ida_hexrays.get_hexrays_version():
	
	  get_hexrays_version() -> char const *
	
	
	  Get decompiler version. The returned string is of the form
	  <major>.<minor>.<revision>.<build-date>
	  
	  @return: pointer to version string. For example: "2.0.0.140605"
	  

ida_hexrays.get_int_type_by_width_and_sign():
	
	  get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t
	
	
	  Create a type info by width and sign. Returns a simple type (examples:
	  int, short) with the given width and sign.
	  
	  @param srcwidth: size of the type in bytes (C++: int)
	  @param sign: sign of the type (C++: type_sign_t)
	  

ida_hexrays.get_member_type():
	
	  get_member_type(mptr, type) -> bool
	
	
	  Get type of a structure field. This function performs validity checks
	  of the field type. Wrong types are rejected.
	  
	  @param mptr: structure field (C++: const  member_t  *)
	  @param type: pointer to the variable where the type is returned. This
	               parameter can be NULL. (C++: tinfo_t  *)
	  @return: false if failed
	  

ida_hexrays.get_merror_desc():
	
	  get_merror_desc(code, mba) -> ea_t
	
	
	  Get textual description of an error code
	  
	  @param code: Microcode error codes (C++: merror_t)
	  @param mba: the microcode array (C++: mbl_array_t  *)
	  @return: the error address
	  

ida_hexrays.get_op_signness():
	
	  get_op_signness(op) -> type_sign_t
	
	
	  Get operator sign. Meaningful for sign-dependent operators, like
	  cot_sdiv.
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.get_type():
	
	  get_type(id, tif, guess) -> bool
	
	
	  Get a global type. Global types are types of addressable objects and
	  struct/union/enum types
	  
	  @param id: address or id of the object (C++: uval_t)
	  @param tif: buffer for the answer (C++: tinfo_t  *)
	  @param guess: what kind of types to consider (C++: type_source_t)
	  @return: success
	  

ida_hexrays.get_unk_type():
	
	  get_unk_type(size) -> tinfo_t
	
	
	  Create a partial type info by width. Returns a partially defined type
	  (examples: _DWORD, _BYTE) with the given width.
	  
	  @param size: size of the type in bytes (C++: int)
	  

ida_hexrays.get_widget_vdui():
	
	  get_widget_vdui(f) -> vdui_t
	
	
	  Get the 'vdui_t' instance associated to the TWidget
	  
	  @param f: pointer to window (C++: TWidget *)
	  @return: a  vdui_t  *, or NULL
	  

ida_hexrays.has_cached_cfunc():
	
	  has_cached_cfunc(ea) -> bool
	
	
	  Do we have a cached decompilation result for 'ea'?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_hexrays.hexrays_alloc():
	
	  hexrays_alloc(size) -> void *
	  

class ida_hexrays.hexrays_failure_t():
	
	    Proxy of C++ hexrays_failure_t class
	    

ida_hexrays.hexrays_failure_t.code:
	hexrays_failure_t_code_get(self) -> merror_t

ida_hexrays.hexrays_failure_t.desc():
	
	        desc(self) -> qstring
	        

ida_hexrays.hexrays_failure_t.errea:
	hexrays_failure_t_errea_get(self) -> ea_t

ida_hexrays.hexrays_failure_t.str:
	hexrays_failure_t_str_get(self) -> qstring *

ida_hexrays.hexrays_free():
	
	  hexrays_free(ptr)
	  

class ida_hexrays.hexwarn_t():
	
	    Proxy of C++ hexwarn_t class
	    

ida_hexrays.hexwarn_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.hexwarn_t.ea:
	hexwarn_t_ea_get(self) -> ea_t

ida_hexrays.hexwarn_t.id:
	hexwarn_t_id_get(self) -> warnid_t

ida_hexrays.hexwarn_t.text:
	hexwarn_t_text_get(self) -> qstring *

class ida_hexrays.hexwarns_t():
	
	    Proxy of C++ qvector<(hexwarn_t)> class
	    

ida_hexrays.hexwarns_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.hexwarns_t.at():
	
	        __getitem__(self, i) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.begin():
	
	        begin(self) -> hexwarn_t
	        begin(self) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.hexwarns_t.clear():
	
	        clear(self)
	        

ida_hexrays.hexwarns_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.hexwarns_t.end():
	
	        end(self) -> hexwarn_t
	        end(self) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.erase():
	
	        erase(self, it) -> hexwarn_t
	        erase(self, first, last) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.extract():
	
	        extract(self) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.find():
	
	        find(self, x) -> hexwarn_t
	        find(self, x) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.grow():
	
	        grow(self, x=hexwarn_t())
	        

ida_hexrays.hexwarns_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.hexwarns_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.hexwarns_t.insert():
	
	        insert(self, it, x) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.hexwarns_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> hexwarn_t
	        

ida_hexrays.hexwarns_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.hexwarns_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.hexwarns_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.hexwarns_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.hexwarns_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.hexwarns_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.history_item_t():
	
	    Proxy of C++ history_item_t class
	    

ida_hexrays.history_item_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.history_item_t.ea:
	history_item_t_ea_get(self) -> ea_t

ida_hexrays.history_item_t.end:
	history_item_t_end_get(self) -> ea_t

ida_hexrays.history_item_t.in_ctree():
	
	        in_ctree(self, hdrlines) -> bool
	        

ida_hexrays.history_item_t.lnnum:
	ctext_position_t_lnnum_get(self) -> int

ida_hexrays.history_item_t.x:
	ctext_position_t_x_get(self) -> int

ida_hexrays.history_item_t.y:
	ctext_position_t_y_get(self) -> int

class ida_hexrays.history_t():
	
	    Proxy of C++ qstack<(history_item_t)> class
	    

ida_hexrays.history_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.history_t.at():
	
	        __getitem__(self, i) -> history_item_t
	        

ida_hexrays.history_t.begin():
	
	        begin(self) -> history_item_t
	        begin(self) -> history_item_t
	        

ida_hexrays.history_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.history_t.clear():
	
	        clear(self)
	        

ida_hexrays.history_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.history_t.end():
	
	        end(self) -> history_item_t
	        end(self) -> history_item_t
	        

ida_hexrays.history_t.erase():
	
	        erase(self, it) -> history_item_t
	        erase(self, first, last) -> history_item_t
	        

ida_hexrays.history_t.extract():
	
	        extract(self) -> history_item_t
	        

ida_hexrays.history_t.find():
	
	        find(self, x) -> history_item_t
	        find(self, x) -> history_item_t
	        

ida_hexrays.history_t.grow():
	
	        grow(self, x=history_item_t())
	        

ida_hexrays.history_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.history_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.history_t.insert():
	
	        insert(self, it, x) -> history_item_t
	        

ida_hexrays.history_t.pop():
	
	        pop(self) -> history_item_t
	        

ida_hexrays.history_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.history_t.push():
	
	        push(self, v)
	        

ida_hexrays.history_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> history_item_t
	        

ida_hexrays.history_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.history_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.history_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.history_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.history_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.history_t.top():
	
	        top(self) -> history_item_t
	        top(self) -> history_item_t
	        

ida_hexrays.history_t.truncate():
	
	        truncate(self)
	        

ida_hexrays.init_hexrays_plugin():
	
	  init_hexrays_plugin(flags=0) -> bool
	
	
	  Initialize your plugin for hex-rays decompiler. This function must be
	  called before calling any other decompiler function. It initializes
	  the pointer to the dispatcher.
	  
	  @param flags: reserved, must be 0 (C++: int)
	  @return: true if the decompiler exists and the dispatcher pointer is
	           ready to use.
	  

ida_hexrays.install_hexrays_callback():
	Deprecated. Please use Hexrays_Hooks instead

ida_hexrays.install_microcode_filter():
	
	  install_microcode_filter(filter, install=True)
	
	
	  register/unregister non-standard microcode generator
	  
	  @param filter: - microcode generator object (C++: microcode_filter_t
	                 *)
	  @param install: - TRUE - register the object, FALSE - unregister (C++:
	                  bool)
	  

ida_hexrays.is_additive():
	
	  is_additive(op) -> bool
	
	
	  Is additive operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_allowed_on_small_struni():
	
	  is_allowed_on_small_struni(op) -> bool
	
	
	  Is the operator allowed on small struni (structure/union)?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_assignment():
	
	  is_assignment(op) -> bool
	
	
	  Is assignment operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_binary():
	
	  is_binary(op) -> bool
	
	
	  Is binary operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_bitop():
	
	  is_bitop(op) -> bool
	
	
	  Is bit related operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_bool_type():
	
	  is_bool_type(type) -> bool
	
	
	  Is a boolean type?
	  
	  @param type (C++: const  tinfo_t  &)
	  @return: true if the type is a boolean type
	  

ida_hexrays.is_break_consumer():
	
	  is_break_consumer(op) -> bool
	
	
	  Does a break statement influence the specified statement code?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_commutative():
	
	  is_commutative(op) -> bool
	
	
	  Is commutative operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_inplace_def():
	
	  is_inplace_def(type) -> bool
	
	
	  Is struct/union/enum definition (not declaration)?
	  
	  
	  @param type (C++: const  tinfo_t  &)
	  

ida_hexrays.is_logical():
	
	  is_logical(op) -> bool
	
	
	  Is logical operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_loop():
	
	  is_loop(op) -> bool
	
	
	  Is loop statement code?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_lvalue():
	
	  is_lvalue(op) -> bool
	
	
	  Is Lvalue operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_multiplicative():
	
	  is_multiplicative(op) -> bool
	
	
	  Is multiplicative operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_nonbool_type():
	
	  is_nonbool_type(type) -> bool
	
	
	  Is definitely a non-boolean type?
	  
	  @param type (C++: const  tinfo_t  &)
	  @return: true if the type is a non-boolean type (non bool and well
	           defined)
	  

ida_hexrays.is_paf():
	
	  is_paf(t) -> bool
	
	
	  Is a pointer, array, or function type?
	  
	  
	  @param t (C++: type_t)
	  

ida_hexrays.is_prepost():
	
	  is_prepost(op) -> bool
	
	
	  Is pre/post increment/decrement operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_ptr_or_array():
	
	  is_ptr_or_array(t) -> bool
	
	
	  Is a pointer or array type?
	  
	  
	  @param t (C++: type_t)
	  

ida_hexrays.is_relational():
	
	  is_relational(op) -> bool
	
	
	  Is comparison operator?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.is_small_struni():
	
	  is_small_struni(tif) -> bool
	
	
	  Is a small structure or union?
	  
	  @param tif (C++: const  tinfo_t  &)
	  @return: true if the type is a small UDT (user defined type). Small
	           UDTs fit into a register (or pair or registers) as a rule.
	  

ida_hexrays.is_type_correct():
	
	  is_type_correct(ptr) -> bool
	
	
	  Verify a type string.
	  
	  @param ptr (C++: const  type_t  *)
	  @return: true if type string is correct
	  

ida_hexrays.is_unary():
	
	  is_unary(op) -> bool
	
	
	  Is unary operator?
	  
	  
	  @param op (C++: ctype_t)
	  

class ida_hexrays.lvar_locator_t():
	
	    Proxy of C++ lvar_locator_t class
	    

ida_hexrays.lvar_locator_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.lvar_locator_t.defea:
	lvar_locator_t_defea_get(self) -> ea_t

ida_hexrays.lvar_locator_t.get_reg1():
	
	        get_reg1(self) -> mreg_t
	        

ida_hexrays.lvar_locator_t.get_reg2():
	
	        get_reg2(self) -> mreg_t
	        

ida_hexrays.lvar_locator_t.get_scattered():
	
	        get_scattered(self) -> scattered_aloc_t
	        get_scattered(self) -> scattered_aloc_t
	        

ida_hexrays.lvar_locator_t.get_stkoff():
	
	        get_stkoff(self) -> sval_t
	        

ida_hexrays.lvar_locator_t.is_reg1():
	
	        is_reg1(self) -> bool
	        

ida_hexrays.lvar_locator_t.is_reg2():
	
	        is_reg2(self) -> bool
	        

ida_hexrays.lvar_locator_t.is_reg_var():
	
	        is_reg_var(self) -> bool
	        

ida_hexrays.lvar_locator_t.is_scattered():
	
	        is_scattered(self) -> bool
	        

ida_hexrays.lvar_locator_t.is_stk_var():
	
	        is_stk_var(self) -> bool
	        

ida_hexrays.lvar_locator_t.location:
	lvar_locator_t_location_get(self) -> vdloc_t

ida_hexrays.lvar_mapping_begin():
	
	  lvar_mapping_begin(map) -> lvar_mapping_iterator_t
	
	
	  Get iterator pointing to the beginning of lvar_mapping_t.
	  
	  
	  @param map (C++: const lvar_mapping_t *)
	  

ida_hexrays.lvar_mapping_clear():
	
	  lvar_mapping_clear(map)
	
	
	  Clear lvar_mapping_t.
	  
	  
	  @param map (C++: lvar_mapping_t *)
	  

ida_hexrays.lvar_mapping_end():
	
	  lvar_mapping_end(map) -> lvar_mapping_iterator_t
	
	
	  Get iterator pointing to the end of lvar_mapping_t.
	  
	  
	  @param map (C++: const lvar_mapping_t *)
	  

ida_hexrays.lvar_mapping_erase():
	
	  lvar_mapping_erase(map, p)
	
	
	  Erase current element from lvar_mapping_t.
	  
	  
	  @param map (C++: lvar_mapping_t *)
	  @param p (C++: lvar_mapping_iterator_t)
	  

ida_hexrays.lvar_mapping_find():
	
	  lvar_mapping_find(map, key) -> lvar_mapping_iterator_t
	
	
	  Find the specified key in lvar_mapping_t.
	  
	  
	  @param map (C++: const lvar_mapping_t *)
	  @param key (C++: const  lvar_locator_t  &)
	  

ida_hexrays.lvar_mapping_first():
	
	  lvar_mapping_first(p) -> lvar_locator_t
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: lvar_mapping_iterator_t)
	  

ida_hexrays.lvar_mapping_free():
	
	  lvar_mapping_free(map)
	
	
	  Delete lvar_mapping_t instance.
	  
	  
	  @param map (C++: lvar_mapping_t *)
	  

ida_hexrays.lvar_mapping_insert():
	
	  lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t
	
	
	  Insert new ( 'lvar_locator_t' , 'lvar_locator_t' ) pair into
	  lvar_mapping_t.
	  
	  
	  @param map (C++: lvar_mapping_t *)
	  @param key (C++: const  lvar_locator_t  &)
	  @param val (C++: const  lvar_locator_t  &)
	  

class ida_hexrays.lvar_mapping_iterator_t():
	
	    Proxy of C++ lvar_mapping_iterator_t class
	    

ida_hexrays.lvar_mapping_iterator_t.x:
	lvar_mapping_iterator_t_x_get(self) -> iterator_word

ida_hexrays.lvar_mapping_new():
	
	  lvar_mapping_new() -> lvar_mapping_t
	
	
	  Create a new lvar_mapping_t instance.
	  

ida_hexrays.lvar_mapping_next():
	
	  lvar_mapping_next(p) -> lvar_mapping_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: lvar_mapping_iterator_t)
	  

ida_hexrays.lvar_mapping_prev():
	
	  lvar_mapping_prev(p) -> lvar_mapping_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: lvar_mapping_iterator_t)
	  

ida_hexrays.lvar_mapping_second():
	
	  lvar_mapping_second(p) -> lvar_locator_t
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: lvar_mapping_iterator_t)
	  

ida_hexrays.lvar_mapping_size():
	
	  lvar_mapping_size(map) -> size_t
	
	
	  Get size of lvar_mapping_t.
	  
	  
	  @param map (C++: lvar_mapping_t *)
	  

class ida_hexrays.lvar_mapping_t():
	
	    Proxy of C++ std::map<(lvar_locator_t,lvar_locator_t)> class
	    

ida_hexrays.lvar_mapping_t.at():
	
	        at(self, _Keyval) -> lvar_locator_t
	        

ida_hexrays.lvar_mapping_t.size():
	
	        size(self) -> size_t
	        

class ida_hexrays.lvar_saved_info_t():
	
	    Proxy of C++ lvar_saved_info_t class
	    

ida_hexrays.lvar_saved_info_t.clear_keep():
	
	        clear_keep(self)
	        

ida_hexrays.lvar_saved_info_t.clr_forced_lvar():
	
	        clr_forced_lvar(self)
	        

ida_hexrays.lvar_saved_info_t.clr_noptr_lvar():
	
	        clr_noptr_lvar(self)
	        

ida_hexrays.lvar_saved_info_t.cmt:
	lvar_saved_info_t_cmt_get(self) -> qstring *

ida_hexrays.lvar_saved_info_t.flags:
	lvar_saved_info_t_flags_get(self) -> int

ida_hexrays.lvar_saved_info_t.has_info():
	
	        has_info(self) -> bool
	        

ida_hexrays.lvar_saved_info_t.is_forced_lvar():
	
	        is_forced_lvar(self) -> bool
	        

ida_hexrays.lvar_saved_info_t.is_kept():
	
	        is_kept(self) -> bool
	        

ida_hexrays.lvar_saved_info_t.is_noptr_lvar():
	
	        is_noptr_lvar(self) -> bool
	        

ida_hexrays.lvar_saved_info_t.ll:
	lvar_saved_info_t_ll_get(self) -> lvar_locator_t

ida_hexrays.lvar_saved_info_t.name:
	lvar_saved_info_t_name_get(self) -> qstring *

ida_hexrays.lvar_saved_info_t.set_forced_lvar():
	
	        set_forced_lvar(self)
	        

ida_hexrays.lvar_saved_info_t.set_keep():
	
	        set_keep(self)
	        

ida_hexrays.lvar_saved_info_t.set_noptr_lvar():
	
	        set_noptr_lvar(self)
	        

ida_hexrays.lvar_saved_info_t.size:
	lvar_saved_info_t_size_get(self) -> ssize_t

ida_hexrays.lvar_saved_info_t.type:
	lvar_saved_info_t_type_get(self) -> tinfo_t

class ida_hexrays.lvar_saved_infos_t():
	
	    Proxy of C++ qvector<(lvar_saved_info_t)> class
	    

ida_hexrays.lvar_saved_infos_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.lvar_saved_infos_t.at():
	
	        __getitem__(self, i) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.begin():
	
	        begin(self) -> lvar_saved_info_t
	        begin(self) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.lvar_saved_infos_t.clear():
	
	        clear(self)
	        

ida_hexrays.lvar_saved_infos_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.lvar_saved_infos_t.end():
	
	        end(self) -> lvar_saved_info_t
	        end(self) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.erase():
	
	        erase(self, it) -> lvar_saved_info_t
	        erase(self, first, last) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.extract():
	
	        extract(self) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.find():
	
	        find(self, x) -> lvar_saved_info_t
	        find(self, x) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.grow():
	
	        grow(self, x=lvar_saved_info_t())
	        

ida_hexrays.lvar_saved_infos_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.lvar_saved_infos_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.lvar_saved_infos_t.insert():
	
	        insert(self, it, x) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.lvar_saved_infos_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> lvar_saved_info_t
	        

ida_hexrays.lvar_saved_infos_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.lvar_saved_infos_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.lvar_saved_infos_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.lvar_saved_infos_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.lvar_saved_infos_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.lvar_saved_infos_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.lvar_t():
	
	    Proxy of C++ lvar_t class
	    

ida_hexrays.lvar_t.accepts_type():
	
	        accepts_type(self, t, may_change_thisarg=False) -> bool
	        

ida_hexrays.lvar_t.append_list():
	
	        append_list(self, lst, pad_if_scattered=False)
	        

ida_hexrays.lvar_t.clear_used():
	
	        clear_used(self)
	        

ida_hexrays.lvar_t.clr_arg_var():
	
	        clr_arg_var(self)
	        

ida_hexrays.lvar_t.clr_fake_var():
	
	        clr_fake_var(self)
	        

ida_hexrays.lvar_t.clr_floating_var():
	
	        clr_floating_var(self)
	        

ida_hexrays.lvar_t.clr_forced_var():
	
	        clr_forced_var(self)
	        

ida_hexrays.lvar_t.clr_mapdst_var():
	
	        clr_mapdst_var(self)
	        

ida_hexrays.lvar_t.clr_mreg_done():
	
	        clr_mreg_done(self)
	        

ida_hexrays.lvar_t.clr_noptr_var():
	
	        clr_noptr_var(self)
	        

ida_hexrays.lvar_t.clr_overlapped_var():
	
	        clr_overlapped_var(self)
	        

ida_hexrays.lvar_t.clr_spoiled_var():
	
	        clr_spoiled_var(self)
	        

ida_hexrays.lvar_t.clr_thisarg():
	
	        clr_thisarg(self)
	        

ida_hexrays.lvar_t.clr_unknown_width():
	
	        clr_unknown_width(self)
	        

ida_hexrays.lvar_t.clr_user_info():
	
	        clr_user_info(self)
	        

ida_hexrays.lvar_t.clr_user_name():
	
	        clr_user_name(self)
	        

ida_hexrays.lvar_t.clr_user_type():
	
	        clr_user_type(self)
	        

ida_hexrays.lvar_t.cmt:
	lvar_t_cmt_get(self) -> qstring *

ida_hexrays.lvar_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.lvar_t.defblk:
	lvar_t_defblk_get(self) -> int

ida_hexrays.lvar_t.defea:
	lvar_locator_t_defea_get(self) -> ea_t

ida_hexrays.lvar_t.divisor:
	lvar_t_divisor_get(self) -> uint64

ida_hexrays.lvar_t.get_reg1():
	
	        get_reg1(self) -> mreg_t
	        

ida_hexrays.lvar_t.get_reg2():
	
	        get_reg2(self) -> mreg_t
	        

ida_hexrays.lvar_t.get_scattered():
	
	        get_scattered(self) -> scattered_aloc_t
	        get_scattered(self) -> scattered_aloc_t
	        

ida_hexrays.lvar_t.get_stkoff():
	
	        get_stkoff(self) -> sval_t
	        

ida_hexrays.lvar_t.has_common():
	
	        has_common(self, v) -> bool
	        

ida_hexrays.lvar_t.has_common_bit():
	
	        has_common_bit(self, loc, width2) -> bool
	        

ida_hexrays.lvar_t.has_nice_name:
	
	        has_nice_name(self) -> bool
	        

ida_hexrays.lvar_t.has_regname():
	
	        has_regname(self) -> bool
	        

ida_hexrays.lvar_t.has_user_info:
	
	        has_user_info(self) -> bool
	        

ida_hexrays.lvar_t.has_user_name:
	
	        has_user_name(self) -> bool
	        

ida_hexrays.lvar_t.has_user_type:
	
	        has_user_type(self) -> bool
	        

ida_hexrays.lvar_t.is_aliasable():
	
	        is_aliasable(self, mba) -> bool
	        

ida_hexrays.lvar_t.is_arg_var:
	
	        is_arg_var(self) -> bool
	        

ida_hexrays.lvar_t.is_fake_var:
	
	        is_fake_var(self) -> bool
	        

ida_hexrays.lvar_t.is_floating_var:
	
	        is_floating_var(self) -> bool
	        

ida_hexrays.lvar_t.is_forced_var():
	
	        is_forced_var(self) -> bool
	        

ida_hexrays.lvar_t.is_mapdst_var:
	
	        is_mapdst_var(self) -> bool
	        

ida_hexrays.lvar_t.is_noptr_var():
	
	        is_noptr_var(self) -> bool
	        

ida_hexrays.lvar_t.is_overlapped_var:
	
	        is_overlapped_var(self) -> bool
	        

ida_hexrays.lvar_t.is_reg1():
	
	        is_reg1(self) -> bool
	        

ida_hexrays.lvar_t.is_reg2():
	
	        is_reg2(self) -> bool
	        

ida_hexrays.lvar_t.is_reg_var():
	
	        is_reg_var(self) -> bool
	        

ida_hexrays.lvar_t.is_result_var:
	
	        is_result_var(self) -> bool
	        

ida_hexrays.lvar_t.is_scattered():
	
	        is_scattered(self) -> bool
	        

ida_hexrays.lvar_t.is_spoiled_var:
	
	        is_spoiled_var(self) -> bool
	        

ida_hexrays.lvar_t.is_stk_var():
	
	        is_stk_var(self) -> bool
	        

ida_hexrays.lvar_t.is_thisarg():
	
	        is_thisarg(self) -> bool
	        

ida_hexrays.lvar_t.is_unknown_width:
	
	        is_unknown_width(self) -> bool
	        

ida_hexrays.lvar_t.location:
	lvar_locator_t_location_get(self) -> vdloc_t

ida_hexrays.lvar_t.mreg_done:
	
	        mreg_done(self) -> bool
	        

ida_hexrays.lvar_t.name:
	lvar_t_name_get(self) -> qstring *

ida_hexrays.lvar_t.set_arg_var():
	
	        set_arg_var(self)
	        

ida_hexrays.lvar_t.set_fake_var():
	
	        set_fake_var(self)
	        

ida_hexrays.lvar_t.set_final_lvar_type():
	
	        set_final_lvar_type(self, t)
	        

ida_hexrays.lvar_t.set_floating_var():
	
	        set_floating_var(self)
	        

ida_hexrays.lvar_t.set_forced_var():
	
	        set_forced_var(self)
	        

ida_hexrays.lvar_t.set_lvar_type():
	
	        set_lvar_type(self, t, may_fail=False) -> bool
	        

ida_hexrays.lvar_t.set_mapdst_var():
	
	        set_mapdst_var(self)
	        

ida_hexrays.lvar_t.set_mreg_done():
	
	        set_mreg_done(self)
	        

ida_hexrays.lvar_t.set_non_typed():
	
	        set_non_typed(self)
	        

ida_hexrays.lvar_t.set_noptr_var():
	
	        set_noptr_var(self)
	        

ida_hexrays.lvar_t.set_overlapped_var():
	
	        set_overlapped_var(self)
	        

ida_hexrays.lvar_t.set_spoiled_var():
	
	        set_spoiled_var(self)
	        

ida_hexrays.lvar_t.set_thisarg():
	
	        set_thisarg(self)
	        

ida_hexrays.lvar_t.set_typed():
	
	        set_typed(self)
	        

ida_hexrays.lvar_t.set_unknown_width():
	
	        set_unknown_width(self)
	        

ida_hexrays.lvar_t.set_used():
	
	        set_used(self)
	        

ida_hexrays.lvar_t.set_user_name():
	
	        set_user_name(self)
	        

ida_hexrays.lvar_t.set_user_type():
	
	        set_user_type(self)
	        

ida_hexrays.lvar_t.set_width():
	
	        set_width(self, w, svw_flags=0) -> bool
	        

ida_hexrays.lvar_t.tif:
	lvar_t_tif_get(self) -> tinfo_t

ida_hexrays.lvar_t.type():
	
	        type(self) -> tinfo_t
	        type(self) -> tinfo_t
	        

ida_hexrays.lvar_t.typed:
	
	        typed(self) -> bool
	        

ida_hexrays.lvar_t.used:
	
	        used(self) -> bool
	        

ida_hexrays.lvar_t.width:
	lvar_t_width_get(self) -> int

class ida_hexrays.lvar_uservec_t():
	
	    Proxy of C++ lvar_uservec_t class
	    

ida_hexrays.lvar_uservec_t.find_info():
	
	        find_info(self, vloc) -> lvar_saved_info_t
	        

ida_hexrays.lvar_uservec_t.keep_info():
	
	        keep_info(self, v)
	        

ida_hexrays.lvar_uservec_t.lmaps:
	lvar_uservec_t_lmaps_get(self) -> lvar_mapping_t

ida_hexrays.lvar_uservec_t.lvvec:
	lvar_uservec_t_lvvec_get(self) -> lvar_saved_infos_t

ida_hexrays.lvar_uservec_t.stkoff_delta:
	lvar_uservec_t_stkoff_delta_get(self) -> uval_t

ida_hexrays.lvar_uservec_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.lvar_uservec_t.ulv_flags:
	lvar_uservec_t_ulv_flags_get(self) -> int

class ida_hexrays.lvars_t():
	
	    Proxy of C++ lvars_t class
	    

ida_hexrays.lvars_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.lvars_t.at():
	
	        __getitem__(self, i) -> lvar_t
	        

ida_hexrays.lvars_t.begin():
	
	        begin(self) -> lvar_t
	        begin(self) -> lvar_t
	        

ida_hexrays.lvars_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.lvars_t.clear():
	
	        clear(self)
	        

ida_hexrays.lvars_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.lvars_t.end():
	
	        end(self) -> lvar_t
	        end(self) -> lvar_t
	        

ida_hexrays.lvars_t.erase():
	
	        erase(self, it) -> lvar_t
	        erase(self, first, last) -> lvar_t
	        

ida_hexrays.lvars_t.extract():
	
	        extract(self) -> lvar_t
	        

ida_hexrays.lvars_t.find():
	
	        find(self, ll) -> lvar_t
	        

ida_hexrays.lvars_t.find_input_lvar():
	
	        find_input_lvar(self, argloc, _size) -> int
	        

ida_hexrays.lvars_t.find_lvar():
	
	        find_lvar(self, location, width, defblk=-1) -> int
	        

ida_hexrays.lvars_t.find_stkvar():
	
	        find_stkvar(self, spoff, width) -> int
	        

ida_hexrays.lvars_t.grow():
	
	        grow(self, x=lvar_t())
	        

ida_hexrays.lvars_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.lvars_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.lvars_t.insert():
	
	        insert(self, it, x) -> lvar_t
	        

ida_hexrays.lvars_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.lvars_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> lvar_t
	        

ida_hexrays.lvars_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.lvars_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.lvars_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.lvars_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.lvars_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.lvars_t.truncate():
	
	        truncate(self)
	        

ida_hexrays.make_pointer():
	
	  make_pointer(type) -> tinfo_t
	
	
	  Create a pointer type. This function performs the following
	  conversion: "type" -> "type*"
	  
	  @param type: object type. (C++: const  tinfo_t  &)
	  @return: "type*". for example, if 'char' is passed as the argument,
	  

ida_hexrays.mark_cfunc_dirty():
	
	  mark_cfunc_dirty(ea, close_views=False) -> bool
	
	
	  Flush the cached decompilation results. Erases a cache entry for the
	  specified function.
	  
	  @param ea: function to erase from the cache (C++: ea_t)
	  @param close_views: close pseudocode windows that show the function
	                      (C++: bool)
	  @return: if a cache entry existed.
	  

class ida_hexrays.microcode_filter_t():
	
	    Proxy of C++ microcode_filter_t class
	    

ida_hexrays.microcode_filter_t.apply():
	
	        apply(self, cdg) -> merror_t
	        

ida_hexrays.microcode_filter_t.match():
	
	        match(self, cdg) -> bool
	        

ida_hexrays.modify_user_lvars():
	
	  modify_user_lvars(entry_ea, mlv) -> bool
	
	
	  Modify saved local variable settings.
	  
	  @param entry_ea: function start address (C++: ea_t)
	  @param mlv: local variable modifier (C++: user_lvar_modifier_t  &)
	  @return: true if modified variables
	  

ida_hexrays.negated_relation():
	
	  negated_relation(op) -> ctype_t
	
	
	  Negate a comparison operator. For example, cot_sge becomes cot_slt.
	  
	  
	  @param op (C++: ctype_t)
	  

class ida_hexrays.number_format_t():
	
	    Proxy of C++ number_format_t class
	    

ida_hexrays.number_format_t.flags:
	number_format_t_flags_get(self) -> flags_t

ida_hexrays.number_format_t.get_radix():
	
	        get_radix(self) -> int
	        

ida_hexrays.number_format_t.is_char():
	
	        is_char(self) -> bool
	        

ida_hexrays.number_format_t.is_dec():
	
	        is_dec(self) -> bool
	        

ida_hexrays.number_format_t.is_enum():
	
	        is_enum(self) -> bool
	        

ida_hexrays.number_format_t.is_fixed():
	
	        is_fixed(self) -> bool
	        

ida_hexrays.number_format_t.is_hex():
	
	        is_hex(self) -> bool
	        

ida_hexrays.number_format_t.is_numop():
	
	        is_numop(self) -> bool
	        

ida_hexrays.number_format_t.is_oct():
	
	        is_oct(self) -> bool
	        

ida_hexrays.number_format_t.is_stroff():
	
	        is_stroff(self) -> bool
	        

ida_hexrays.number_format_t.needs_to_be_inverted():
	
	        needs_to_be_inverted(self) -> bool
	        

ida_hexrays.number_format_t.opnum:
	number_format_t_opnum_get(self) -> char

ida_hexrays.number_format_t.org_nbytes:
	number_format_t_org_nbytes_get(self) -> char

ida_hexrays.number_format_t.props:
	number_format_t_props_get(self) -> char

ida_hexrays.number_format_t.serial:
	number_format_t_serial_get(self) -> uchar

ida_hexrays.number_format_t.type_name:
	number_format_t_type_name_get(self) -> qstring *

ida_hexrays.op_uses_x():
	
	  op_uses_x(op) -> bool
	
	
	  Does operator use the 'x' field of 'cexpr_t' ?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.op_uses_y():
	
	  op_uses_y(op) -> bool
	
	
	  Does operator use the 'y' field of 'cexpr_t' ?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.op_uses_z():
	
	  op_uses_z(op) -> bool
	
	
	  Does operator use the 'z' field of 'cexpr_t' ?
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.open_pseudocode():
	
	  open_pseudocode(ea, new_window) -> vdui_t
	
	
	  Open pseudocode window. The specified function is decompiled and the
	  pseudocode window is opened.
	  
	  @param ea: function to decompile (C++: ea_t)
	  @param new_window: 0:reuse existing window; 1:open new window; -1:
	                     reuse existing window if the current view is
	                     pseudocode (C++: int)
	  @return: false if failed
	  

class ida_hexrays.operand_locator_t():
	
	    Proxy of C++ operand_locator_t class
	    

ida_hexrays.operand_locator_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.operand_locator_t.ea:
	operand_locator_t_ea_get(self) -> ea_t

ida_hexrays.operand_locator_t.opnum:
	operand_locator_t_opnum_get(self) -> int

class ida_hexrays.operator_info_t():
	
	    Proxy of C++ operator_info_t class
	    

ida_hexrays.operator_info_t.fixtype:
	operator_info_t_fixtype_get(self) -> uchar

ida_hexrays.operator_info_t.flags:
	operator_info_t_flags_get(self) -> uchar

ida_hexrays.operator_info_t.precedence:
	operator_info_t_precedence_get(self) -> uchar

ida_hexrays.operator_info_t.text:
	operator_info_t_text_get(self) -> char const *

ida_hexrays.operator_info_t.valency:
	operator_info_t_valency_get(self) -> uchar

ida_hexrays.parse_user_call():
	
	  parse_user_call(udc, decl, silent) -> bool
	
	
	  Convert function type declaration into internal structure
	  
	  @param udc: - pointer to output structure (C++: udcall_t  *)
	  @param decl: - function type declaration (C++: const char *)
	  @param silent: - if TRUE: do not show warning in case of incorrect
	                 type (C++: bool)
	  @return: success
	  

ida_hexrays.partial_type_num():
	
	  partial_type_num(type) -> int
	
	
	  Calculate number of partial subtypes.
	  
	  @param type (C++: const  tinfo_t  &)
	  @return: number of partial subtypes. The bigger is this number, the
	           uglier is the type.
	  

ida_hexrays.print_vdloc():
	
	  print_vdloc(loc, nbytes)
	
	
	  Print vdloc. Since vdloc does not always carry the size info, we pass
	  it as NBYTES..
	  
	  @param loc (C++: const  vdloc_t  &)
	  @param nbytes (C++: int)
	  

class ida_hexrays.qlist_cinsn_t():
	
	    Proxy of C++ qlist<(cinsn_t)> class
	    

ida_hexrays.qlist_cinsn_t.back():
	
	        back(self) -> cinsn_t
	        back(self) -> cinsn_t
	        

ida_hexrays.qlist_cinsn_t.begin():
	
	        begin(self) -> qlist_cinsn_t_iterator
	        

ida_hexrays.qlist_cinsn_t.clear():
	
	        clear(self)
	        

ida_hexrays.qlist_cinsn_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.qlist_cinsn_t.end():
	
	        end(self) -> qlist_cinsn_t_iterator
	        

ida_hexrays.qlist_cinsn_t.erase():
	
	        erase(self, p) -> qlist< cinsn_t >::iterator
	        erase(self, p1, p2)
	        erase(self, p)
	        

ida_hexrays.qlist_cinsn_t.front():
	
	        front(self) -> cinsn_t
	        front(self) -> cinsn_t
	        

ida_hexrays.qlist_cinsn_t.insert():
	
	        insert(self, p, x) -> qlist< cinsn_t >::iterator
	        insert(self, p) -> cinsn_t
	        insert(self, p, x) -> qlist_cinsn_t_iterator
	        

ida_hexrays.qlist_cinsn_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.qlist_cinsn_t.pop_front():
	
	        pop_front(self)
	        

ida_hexrays.qlist_cinsn_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> cinsn_t
	        

ida_hexrays.qlist_cinsn_t.push_front():
	
	        push_front(self, x)
	        

ida_hexrays.qlist_cinsn_t.rbegin():
	
	        rbegin(self) -> qlist< cinsn_t >::reverse_iterator
	        rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
	        

ida_hexrays.qlist_cinsn_t.rend():
	
	        rend(self) -> qlist< cinsn_t >::reverse_iterator
	        rend(self) -> qlist< cinsn_t >::const_reverse_iterator
	        

ida_hexrays.qlist_cinsn_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.qlist_cinsn_t.swap():
	
	        swap(self, x)
	        

class ida_hexrays.qlist_cinsn_t_iterator():
	
	    Proxy of C++ qlist_cinsn_t_iterator class
	    

ida_hexrays.qlist_cinsn_t_iterator.cur:
	qlist_cinsn_t_iterator_cur_get(self) -> cinsn_t

ida_hexrays.qlist_cinsn_t_iterator.next():
	
	        next(self)
	        

class ida_hexrays.qstring_printer_t():
	
	    Proxy of C++ qstring_printer_t class
	    

ida_hexrays.qstring_printer_t._print():
	
	        _print(self, indent, format) -> int
	        

ida_hexrays.qstring_printer_t.func:
	vc_printer_t_func_get(self) -> cfunc_t

ida_hexrays.qstring_printer_t.get_s():
	
	        get_s(self) -> qstring
	        

ida_hexrays.qstring_printer_t.hdrlines:
	vd_printer_t_hdrlines_get(self) -> int

ida_hexrays.qstring_printer_t.lastchar:
	vc_printer_t_lastchar_get(self) -> char

ida_hexrays.qstring_printer_t.oneliner():
	
	        oneliner(self) -> bool
	        

ida_hexrays.qstring_printer_t.with_tags:
	qstring_printer_t_with_tags_get(self) -> bool

ida_hexrays.qswap():
	
	  qswap(a, b)
	  

class ida_hexrays.qvector_carg_t():
	
	    Proxy of C++ qvector<(carg_t)> class
	    

ida_hexrays.qvector_carg_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.qvector_carg_t.at():
	
	        __getitem__(self, i) -> carg_t
	        

ida_hexrays.qvector_carg_t.begin():
	
	        begin(self) -> carg_t
	        begin(self) -> carg_t
	        

ida_hexrays.qvector_carg_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.qvector_carg_t.clear():
	
	        clear(self)
	        

ida_hexrays.qvector_carg_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.qvector_carg_t.end():
	
	        end(self) -> carg_t
	        end(self) -> carg_t
	        

ida_hexrays.qvector_carg_t.erase():
	
	        erase(self, it) -> carg_t
	        erase(self, first, last) -> carg_t
	        

ida_hexrays.qvector_carg_t.extract():
	
	        extract(self) -> carg_t
	        

ida_hexrays.qvector_carg_t.find():
	
	        find(self, x) -> carg_t
	        find(self, x) -> carg_t
	        

ida_hexrays.qvector_carg_t.grow():
	
	        grow(self, x=carg_t())
	        

ida_hexrays.qvector_carg_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.qvector_carg_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.qvector_carg_t.insert():
	
	        insert(self, it, x) -> carg_t
	        

ida_hexrays.qvector_carg_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.qvector_carg_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> carg_t
	        

ida_hexrays.qvector_carg_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.qvector_carg_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.qvector_carg_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.qvector_carg_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.qvector_carg_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.qvector_carg_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.qvector_ccase_t():
	
	    Proxy of C++ qvector<(ccase_t)> class
	    

ida_hexrays.qvector_ccase_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.qvector_ccase_t.at():
	
	        __getitem__(self, i) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.begin():
	
	        begin(self) -> ccase_t
	        begin(self) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.qvector_ccase_t.clear():
	
	        clear(self)
	        

ida_hexrays.qvector_ccase_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.qvector_ccase_t.end():
	
	        end(self) -> ccase_t
	        end(self) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.erase():
	
	        erase(self, it) -> ccase_t
	        erase(self, first, last) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.extract():
	
	        extract(self) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.find():
	
	        find(self, x) -> ccase_t
	        find(self, x) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.grow():
	
	        grow(self, x=ccase_t())
	        

ida_hexrays.qvector_ccase_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.qvector_ccase_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.qvector_ccase_t.insert():
	
	        insert(self, it, x) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.qvector_ccase_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> ccase_t
	        

ida_hexrays.qvector_ccase_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.qvector_ccase_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.qvector_ccase_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.qvector_ccase_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.qvector_ccase_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.qvector_ccase_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.qvector_history_t():
	
	    Proxy of C++ qvector<(history_item_t)> class
	    

ida_hexrays.qvector_history_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.qvector_history_t.at():
	
	        at(self, _idx) -> history_item_t
	        

ida_hexrays.qvector_history_t.begin():
	
	        begin(self) -> history_item_t
	        begin(self) -> history_item_t
	        

ida_hexrays.qvector_history_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.qvector_history_t.clear():
	
	        clear(self)
	        

ida_hexrays.qvector_history_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.qvector_history_t.end():
	
	        end(self) -> history_item_t
	        end(self) -> history_item_t
	        

ida_hexrays.qvector_history_t.erase():
	
	        erase(self, it) -> history_item_t
	        erase(self, first, last) -> history_item_t
	        

ida_hexrays.qvector_history_t.extract():
	
	        extract(self) -> history_item_t
	        

ida_hexrays.qvector_history_t.find():
	
	        find(self, x) -> history_item_t
	        find(self, x) -> history_item_t
	        

ida_hexrays.qvector_history_t.grow():
	
	        grow(self, x=history_item_t())
	        

ida_hexrays.qvector_history_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.qvector_history_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.qvector_history_t.insert():
	
	        insert(self, it, x) -> history_item_t
	        

ida_hexrays.qvector_history_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.qvector_history_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> history_item_t
	        

ida_hexrays.qvector_history_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.qvector_history_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.qvector_history_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.qvector_history_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.qvector_history_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.qvector_history_t.truncate():
	
	        truncate(self)
	        

class ida_hexrays.qvector_lvar_t():
	
	    Proxy of C++ qvector<(lvar_t)> class
	    

ida_hexrays.qvector_lvar_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.qvector_lvar_t.at():
	
	        __getitem__(self, i) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.begin():
	
	        begin(self) -> lvar_t
	        begin(self) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.qvector_lvar_t.clear():
	
	        clear(self)
	        

ida_hexrays.qvector_lvar_t.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.qvector_lvar_t.end():
	
	        end(self) -> lvar_t
	        end(self) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.erase():
	
	        erase(self, it) -> lvar_t
	        erase(self, first, last) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.extract():
	
	        extract(self) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.find():
	
	        find(self, x) -> lvar_t
	        find(self, x) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.grow():
	
	        grow(self, x=lvar_t())
	        

ida_hexrays.qvector_lvar_t.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.qvector_lvar_t.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.qvector_lvar_t.insert():
	
	        insert(self, it, x) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.qvector_lvar_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> lvar_t
	        

ida_hexrays.qvector_lvar_t.qclear():
	
	        qclear(self)
	        

ida_hexrays.qvector_lvar_t.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.qvector_lvar_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.qvector_lvar_t.size():
	
	        size(self) -> size_t
	        

ida_hexrays.qvector_lvar_t.swap():
	
	        swap(self, r)
	        

ida_hexrays.qvector_lvar_t.truncate():
	
	        truncate(self)
	        

ida_hexrays.remitem():
	
	  remitem(e)
	  

ida_hexrays.remove_hexrays_callback():
	Deprecated. Please use Hexrays_Hooks instead

ida_hexrays.restore_user_cmts():
	
	  restore_user_cmts(func_ea) -> user_cmts_t
	
	
	  Restore user defined comments from the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @return: collection of user defined comments. The returned object must
	           be deleted by the caller using delete_user_cmts()
	  

ida_hexrays.restore_user_defined_calls():
	
	  restore_user_defined_calls(udcalls, func_ea) -> bool
	
	
	  Restore user defined function calls from the database.
	  
	  @param udcalls: ptr to output buffer (C++: udcall_map_t *)
	  @param func_ea: entry address of the function (C++: ea_t)
	  @return: success
	  

ida_hexrays.restore_user_iflags():
	
	  restore_user_iflags(func_ea) -> user_iflags_t
	
	
	  Restore user defined citem iflags from the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @return: collection of user defined iflags. The returned object must
	           be deleted by the caller using delete_user_iflags()
	  

ida_hexrays.restore_user_labels():
	
	  restore_user_labels(func_ea) -> user_labels_t
	
	
	  Restore user defined labels from the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @return: collection of user defined labels. The returned object must
	           be deleted by the caller using delete_user_labels()
	  

ida_hexrays.restore_user_lvar_settings():
	
	  restore_user_lvar_settings(lvinf, func_ea) -> bool
	
	
	  Restore user defined local variable settings in the database.
	  
	  @param lvinf: ptr to output buffer (C++: lvar_uservec_t  *)
	  @param func_ea: entry address of the function (C++: ea_t)
	  @return: success
	  

ida_hexrays.restore_user_numforms():
	
	  restore_user_numforms(func_ea) -> user_numforms_t
	
	
	  Restore user defined number formats from the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @return: collection of user defined number formats. The returned
	           object must be deleted by the caller using
	           delete_user_numforms()
	  

ida_hexrays.restore_user_unions():
	
	  restore_user_unions(func_ea) -> user_unions_t
	
	
	  Restore user defined union field selections from the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @return: collection of union field selections The returned object must
	           be deleted by the caller using delete_user_unions()
	  

ida_hexrays.save_user_cmts():
	
	  save_user_cmts(func_ea, user_cmts)
	
	
	  Save user defined comments into the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @param user_cmts: collection of user defined comments (C++: const
	                    user_cmts_t *)
	  

ida_hexrays.save_user_defined_calls():
	
	  save_user_defined_calls(func_ea, udcalls)
	
	
	  Save user defined local function calls into the database.
	  
	  @param func_ea: entry address of the function (C++: ea_t)
	  @param udcalls: user-specified info about user defined function calls
	                  (C++: const udcall_map_t &)
	  

ida_hexrays.save_user_iflags():
	
	  save_user_iflags(func_ea, iflags)
	
	
	  Save user defined citem iflags into the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @param iflags: collection of user defined citem iflags (C++: const
	                 user_iflags_t *)
	  

ida_hexrays.save_user_labels():
	
	  save_user_labels(func_ea, user_labels)
	
	
	  Save user defined labels into the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @param user_labels: collection of user defined labels (C++: const
	                      user_labels_t *)
	  

ida_hexrays.save_user_lvar_settings():
	
	  save_user_lvar_settings(func_ea, lvinf)
	
	
	  Save user defined local variable settings into the database.
	  
	  @param func_ea: entry address of the function (C++: ea_t)
	  @param lvinf: user-specified info about local variables (C++: const
	                lvar_uservec_t  &)
	  

ida_hexrays.save_user_numforms():
	
	  save_user_numforms(func_ea, numforms)
	
	
	  Save user defined number formats into the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @param numforms: collection of user defined comments (C++: const
	                   user_numforms_t *)
	  

ida_hexrays.save_user_unions():
	
	  save_user_unions(func_ea, unions)
	
	
	  Save user defined union field selections into the database.
	  
	  @param func_ea: the entry address of the function (C++: ea_t)
	  @param unions: collection of union field selections (C++: const
	                 user_unions_t *)
	  

ida_hexrays.send_database():
	
	  send_database(err, silent)
	
	
	  Send the database to Hex-Rays. This function sends the current
	  database to the Hex-Rays server. The database is sent in the
	  compressed form over an encrypted (SSL) connection.
	  
	  @param err: failure description object. Empty  hexrays_failure_t
	              object can be used if error information is not available.
	              (C++: const  hexrays_failure_t  &)
	  @param silent: if false, a dialog box will be displayed before sending
	                 the database. (C++: bool)
	  

ida_hexrays.set_type():
	
	  set_type(id, tif, source, force=False) -> bool
	
	
	  Set a global type.
	  
	  @param id: address or id of the object (C++: uval_t)
	  @param tif: new type info (C++: const  tinfo_t  &)
	  @param source: where the type comes from (C++: type_source_t)
	  @param force: true means to set the type as is, false means to merge
	                the new type with the possibly existing old type info.
	                (C++: bool)
	  @return: success
	  

ida_hexrays.swapped_relation():
	
	  swapped_relation(op) -> ctype_t
	
	
	  Swap a comparison operator. For example, cot_sge becomes cot_sle.
	  
	  
	  @param op (C++: ctype_t)
	  

ida_hexrays.term_hexrays_plugin():
	
	  term_hexrays_plugin()
	
	
	  Stop working with hex-rays decompiler.
	  

class ida_hexrays.treeloc_t():
	
	    Proxy of C++ treeloc_t class
	    

ida_hexrays.treeloc_t.ea:
	treeloc_t_ea_get(self) -> ea_t

ida_hexrays.treeloc_t.itp:
	treeloc_t_itp_get(self) -> item_preciser_t

class ida_hexrays.udc_filter_t():
	
	    Proxy of C++ udc_filter_t class
	    

ida_hexrays.udc_filter_t.apply():
	
	        apply(self, cdg) -> merror_t
	        

ida_hexrays.udc_filter_t.init():
	
	        init(self, decl) -> bool
	        

ida_hexrays.udc_filter_t.match():
	
	        match(self, cdg) -> bool
	        

ida_hexrays.udcall_map_begin():
	
	  udcall_map_begin(map) -> udcall_map_iterator_t
	
	
	  Get iterator pointing to the beginning of udcall_map_t.
	  
	  
	  @param map (C++: const udcall_map_t *)
	  

ida_hexrays.udcall_map_clear():
	
	  udcall_map_clear(map)
	
	
	  Clear udcall_map_t.
	  
	  
	  @param map (C++: udcall_map_t *)
	  

ida_hexrays.udcall_map_end():
	
	  udcall_map_end(map) -> udcall_map_iterator_t
	
	
	  Get iterator pointing to the end of udcall_map_t.
	  
	  
	  @param map (C++: const udcall_map_t *)
	  

ida_hexrays.udcall_map_erase():
	
	  udcall_map_erase(map, p)
	
	
	  Erase current element from udcall_map_t.
	  
	  
	  @param map (C++: udcall_map_t *)
	  @param p (C++: udcall_map_iterator_t)
	  

ida_hexrays.udcall_map_find():
	
	  udcall_map_find(map, key) -> udcall_map_iterator_t
	
	
	  Find the specified key in udcall_map_t.
	  
	  
	  @param map (C++: const udcall_map_t *)
	  @param key (C++: const ea_t &)
	  

ida_hexrays.udcall_map_first():
	
	  udcall_map_first(p) -> ea_t const &
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: udcall_map_iterator_t)
	  

ida_hexrays.udcall_map_free():
	
	  udcall_map_free(map)
	
	
	  Delete udcall_map_t instance.
	  
	  
	  @param map (C++: udcall_map_t *)
	  

ida_hexrays.udcall_map_insert():
	
	  udcall_map_insert(map, key, val) -> udcall_map_iterator_t
	
	
	  Insert new (ea_t, 'udcall_t' ) pair into udcall_map_t.
	  
	  
	  @param map (C++: udcall_map_t *)
	  @param key (C++: const ea_t &)
	  @param val (C++: const  udcall_t  &)
	  

class ida_hexrays.udcall_map_iterator_t():
	
	    Proxy of C++ udcall_map_iterator_t class
	    

ida_hexrays.udcall_map_iterator_t.x:
	udcall_map_iterator_t_x_get(self) -> iterator_word

ida_hexrays.udcall_map_new():
	
	  udcall_map_new() -> udcall_map_t *
	
	
	  Create a new udcall_map_t instance.
	  

ida_hexrays.udcall_map_next():
	
	  udcall_map_next(p) -> udcall_map_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: udcall_map_iterator_t)
	  

ida_hexrays.udcall_map_prev():
	
	  udcall_map_prev(p) -> udcall_map_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: udcall_map_iterator_t)
	  

ida_hexrays.udcall_map_second():
	
	  udcall_map_second(p) -> udcall_t
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: udcall_map_iterator_t)
	  

ida_hexrays.udcall_map_size():
	
	  udcall_map_size(map) -> size_t
	
	
	  Get size of udcall_map_t.
	  
	  
	  @param map (C++: udcall_map_t *)
	  

class ida_hexrays.udcall_t():
	
	    Proxy of C++ udcall_t class
	    

ida_hexrays.udcall_t.name:
	udcall_t_name_get(self) -> qstring *

ida_hexrays.udcall_t.tif:
	udcall_t_tif_get(self) -> tinfo_t

ida_hexrays.user_cmts_begin():
	
	  user_cmts_begin(map) -> user_cmts_iterator_t
	
	
	  Get iterator pointing to the beginning of user_cmts_t.
	  
	  
	  @param map (C++: const user_cmts_t *)
	  

ida_hexrays.user_cmts_clear():
	
	  user_cmts_clear(map)
	
	
	  Clear user_cmts_t.
	  
	  
	  @param map (C++: user_cmts_t *)
	  

ida_hexrays.user_cmts_end():
	
	  user_cmts_end(map) -> user_cmts_iterator_t
	
	
	  Get iterator pointing to the end of user_cmts_t.
	  
	  
	  @param map (C++: const user_cmts_t *)
	  

ida_hexrays.user_cmts_erase():
	
	  user_cmts_erase(map, p)
	
	
	  Erase current element from user_cmts_t.
	  
	  
	  @param map (C++: user_cmts_t *)
	  @param p (C++: user_cmts_iterator_t)
	  

ida_hexrays.user_cmts_find():
	
	  user_cmts_find(map, key) -> user_cmts_iterator_t
	
	
	  Find the specified key in user_cmts_t.
	  
	  
	  @param map (C++: const user_cmts_t *)
	  @param key (C++: const  treeloc_t  &)
	  

ida_hexrays.user_cmts_first():
	
	  user_cmts_first(p) -> treeloc_t
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: user_cmts_iterator_t)
	  

ida_hexrays.user_cmts_free():
	
	  user_cmts_free(map)
	
	
	  Delete user_cmts_t instance.
	  
	  
	  @param map (C++: user_cmts_t *)
	  

ida_hexrays.user_cmts_insert():
	
	  user_cmts_insert(map, key, val) -> user_cmts_iterator_t
	
	
	  Insert new ( 'treeloc_t' , 'citem_cmt_t' ) pair into user_cmts_t.
	  
	  
	  @param map (C++: user_cmts_t *)
	  @param key (C++: const  treeloc_t  &)
	  @param val (C++: const  citem_cmt_t  &)
	  

class ida_hexrays.user_cmts_iterator_t():
	
	    Proxy of C++ user_cmts_iterator_t class
	    

ida_hexrays.user_cmts_iterator_t.x:
	user_cmts_iterator_t_x_get(self) -> iterator_word

ida_hexrays.user_cmts_new():
	
	  user_cmts_new() -> user_cmts_t
	
	
	  Create a new user_cmts_t instance.
	  

ida_hexrays.user_cmts_next():
	
	  user_cmts_next(p) -> user_cmts_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: user_cmts_iterator_t)
	  

ida_hexrays.user_cmts_prev():
	
	  user_cmts_prev(p) -> user_cmts_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: user_cmts_iterator_t)
	  

ida_hexrays.user_cmts_second():
	
	  user_cmts_second(p) -> citem_cmt_t
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: user_cmts_iterator_t)
	  

ida_hexrays.user_cmts_size():
	
	  user_cmts_size(map) -> size_t
	
	
	  Get size of user_cmts_t.
	  
	  
	  @param map (C++: user_cmts_t *)
	  

class ida_hexrays.user_cmts_t():
	
	    Proxy of C++ std::map<(treeloc_t,citem_cmt_t)> class
	    

ida_hexrays.user_cmts_t.at():
	
	        at(self, _Keyval) -> citem_cmt_t
	        

class ida_hexrays.user_cmts_t.keytype():
	
	    Proxy of C++ treeloc_t class
	    

ida_hexrays.user_cmts_t.keytype.ea:
	treeloc_t_ea_get(self) -> ea_t

ida_hexrays.user_cmts_t.keytype.itp:
	treeloc_t_itp_get(self) -> item_preciser_t

ida_hexrays.user_cmts_t.pop():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_cmts_t.popitem():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_cmts_t.setdefault():
	
	         Sets the value associated with the provided key. 
	        

class ida_hexrays.user_cmts_t.valuetype():
	
	    Proxy of C++ citem_cmt_t class
	    

ida_hexrays.user_cmts_t.valuetype.c_str():
	
	        c_str(self) -> char const *
	        

ida_hexrays.user_cmts_t.valuetype.used:
	citem_cmt_t_used_get(self) -> bool

ida_hexrays.user_iflags_begin():
	
	  user_iflags_begin(map) -> user_iflags_iterator_t
	
	
	  Get iterator pointing to the beginning of user_iflags_t.
	  
	  
	  @param map (C++: const user_iflags_t *)
	  

ida_hexrays.user_iflags_clear():
	
	  user_iflags_clear(map)
	
	
	  Clear user_iflags_t.
	  
	  
	  @param map (C++: user_iflags_t *)
	  

ida_hexrays.user_iflags_end():
	
	  user_iflags_end(map) -> user_iflags_iterator_t
	
	
	  Get iterator pointing to the end of user_iflags_t.
	  
	  
	  @param map (C++: const user_iflags_t *)
	  

ida_hexrays.user_iflags_erase():
	
	  user_iflags_erase(map, p)
	
	
	  Erase current element from user_iflags_t.
	  
	  
	  @param map (C++: user_iflags_t *)
	  @param p (C++: user_iflags_iterator_t)
	  

ida_hexrays.user_iflags_find():
	
	  user_iflags_find(map, key) -> user_iflags_iterator_t
	
	
	  Find the specified key in user_iflags_t.
	  
	  
	  @param map (C++: const user_iflags_t *)
	  @param key (C++: const  citem_locator_t  &)
	  

ida_hexrays.user_iflags_first():
	
	  user_iflags_first(p) -> citem_locator_t
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: user_iflags_iterator_t)
	  

ida_hexrays.user_iflags_free():
	
	  user_iflags_free(map)
	
	
	  Delete user_iflags_t instance.
	  
	  
	  @param map (C++: user_iflags_t *)
	  

ida_hexrays.user_iflags_insert():
	
	  user_iflags_insert(map, key, val) -> user_iflags_iterator_t
	
	
	  Insert new ( 'citem_locator_t' , int32) pair into user_iflags_t.
	  
	  
	  @param map (C++: user_iflags_t *)
	  @param key (C++: const  citem_locator_t  &)
	  @param val (C++: const  int32  &)
	  

class ida_hexrays.user_iflags_iterator_t():
	
	    Proxy of C++ user_iflags_iterator_t class
	    

ida_hexrays.user_iflags_iterator_t.x:
	user_iflags_iterator_t_x_get(self) -> iterator_word

ida_hexrays.user_iflags_new():
	
	  user_iflags_new() -> user_iflags_t
	
	
	  Create a new user_iflags_t instance.
	  

ida_hexrays.user_iflags_next():
	
	  user_iflags_next(p) -> user_iflags_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: user_iflags_iterator_t)
	  

ida_hexrays.user_iflags_prev():
	
	  user_iflags_prev(p) -> user_iflags_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: user_iflags_iterator_t)
	  

ida_hexrays.user_iflags_second():
	
	  user_iflags_second(p) -> int32 const &
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: user_iflags_iterator_t)
	  

ida_hexrays.user_iflags_size():
	
	  user_iflags_size(map) -> size_t
	
	
	  Get size of user_iflags_t.
	  
	  
	  @param map (C++: user_iflags_t *)
	  

class ida_hexrays.user_iflags_t():
	
	    Proxy of C++ std::map<(citem_locator_t,int32)> class
	    

ida_hexrays.user_iflags_t.at():
	
	        at(self, _Keyval) -> int &
	        

class ida_hexrays.user_iflags_t.keytype():
	
	    Proxy of C++ citem_locator_t class
	    

ida_hexrays.user_iflags_t.keytype.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.user_iflags_t.keytype.ea:
	citem_locator_t_ea_get(self) -> ea_t

ida_hexrays.user_iflags_t.keytype.op:
	citem_locator_t_op_get(self) -> ctype_t

ida_hexrays.user_iflags_t.pop():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_iflags_t.popitem():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_iflags_t.setdefault():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_iflags_t.valuetype.bit_length():
	int.bit_length() -> int
	
	Number of bits necessary to represent self in binary.
	>>> bin(37)
	'0b100101'
	>>> (37).bit_length()
	6

ida_hexrays.user_iflags_t.valuetype.conjugate():
	Returns self, the complex conjugate of any int.

ida_hexrays.user_iflags_t.valuetype.denominator:
	the denominator of a rational number in lowest terms

ida_hexrays.user_iflags_t.valuetype.imag:
	the imaginary part of a complex number

ida_hexrays.user_iflags_t.valuetype.numerator:
	the numerator of a rational number in lowest terms

ida_hexrays.user_iflags_t.valuetype.real:
	the real part of a complex number

ida_hexrays.user_labels_begin():
	
	  user_labels_begin(map) -> user_labels_iterator_t
	
	
	  Get iterator pointing to the beginning of user_labels_t.
	  
	  
	  @param map (C++: const user_labels_t *)
	  

ida_hexrays.user_labels_clear():
	
	  user_labels_clear(map)
	
	
	  Clear user_labels_t.
	  
	  
	  @param map (C++: user_labels_t *)
	  

ida_hexrays.user_labels_end():
	
	  user_labels_end(map) -> user_labels_iterator_t
	
	
	  Get iterator pointing to the end of user_labels_t.
	  
	  
	  @param map (C++: const user_labels_t *)
	  

ida_hexrays.user_labels_erase():
	
	  user_labels_erase(map, p)
	
	
	  Erase current element from user_labels_t.
	  
	  
	  @param map (C++: user_labels_t *)
	  @param p (C++: user_labels_iterator_t)
	  

ida_hexrays.user_labels_find():
	
	  user_labels_find(map, key) -> user_labels_iterator_t
	
	
	  Find the specified key in user_labels_t.
	  
	  
	  @param map (C++: const user_labels_t *)
	  @param key (C++: const int &)
	  

ida_hexrays.user_labels_first():
	
	  user_labels_first(p) -> int const &
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: user_labels_iterator_t)
	  

ida_hexrays.user_labels_free():
	
	  user_labels_free(map)
	
	
	  Delete user_labels_t instance.
	  
	  
	  @param map (C++: user_labels_t *)
	  

ida_hexrays.user_labels_insert():
	
	  user_labels_insert(map, key, val) -> user_labels_iterator_t
	
	
	  Insert new (int, qstring) pair into user_labels_t.
	  
	  
	  @param map (C++: user_labels_t *)
	  @param key (C++: const int &)
	  @param val (C++: const  qstring  &)
	  

class ida_hexrays.user_labels_iterator_t():
	
	    Proxy of C++ user_labels_iterator_t class
	    

ida_hexrays.user_labels_iterator_t.x:
	user_labels_iterator_t_x_get(self) -> iterator_word

ida_hexrays.user_labels_new():
	
	  user_labels_new() -> user_labels_t
	
	
	  Create a new user_labels_t instance.
	  

ida_hexrays.user_labels_next():
	
	  user_labels_next(p) -> user_labels_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: user_labels_iterator_t)
	  

ida_hexrays.user_labels_prev():
	
	  user_labels_prev(p) -> user_labels_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: user_labels_iterator_t)
	  

ida_hexrays.user_labels_second():
	
	  user_labels_second(p) -> qstring &
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: user_labels_iterator_t)
	  

ida_hexrays.user_labels_size():
	
	  user_labels_size(map) -> size_t
	
	
	  Get size of user_labels_t.
	  
	  
	  @param map (C++: user_labels_t *)
	  

class ida_hexrays.user_labels_t():
	
	    Proxy of C++ std::map<(int,qstring)> class
	    

ida_hexrays.user_labels_t.at():
	
	        at(self, _Keyval) -> _qstring< char > &
	        

ida_hexrays.user_labels_t.size():
	
	        size(self) -> size_t
	        

class ida_hexrays.user_lvar_modifier_t():
	
	    Proxy of C++ user_lvar_modifier_t class
	    

ida_hexrays.user_lvar_modifier_t.modify_lvars():
	
	        modify_lvars(self, lvinf) -> bool
	        

ida_hexrays.user_numforms_begin():
	
	  user_numforms_begin(map) -> user_numforms_iterator_t
	
	
	  Get iterator pointing to the beginning of user_numforms_t.
	  
	  
	  @param map (C++: const user_numforms_t *)
	  

ida_hexrays.user_numforms_clear():
	
	  user_numforms_clear(map)
	
	
	  Clear user_numforms_t.
	  
	  
	  @param map (C++: user_numforms_t *)
	  

ida_hexrays.user_numforms_end():
	
	  user_numforms_end(map) -> user_numforms_iterator_t
	
	
	  Get iterator pointing to the end of user_numforms_t.
	  
	  
	  @param map (C++: const user_numforms_t *)
	  

ida_hexrays.user_numforms_erase():
	
	  user_numforms_erase(map, p)
	
	
	  Erase current element from user_numforms_t.
	  
	  
	  @param map (C++: user_numforms_t *)
	  @param p (C++: user_numforms_iterator_t)
	  

ida_hexrays.user_numforms_find():
	
	  user_numforms_find(map, key) -> user_numforms_iterator_t
	
	
	  Find the specified key in user_numforms_t.
	  
	  
	  @param map (C++: const user_numforms_t *)
	  @param key (C++: const  operand_locator_t  &)
	  

ida_hexrays.user_numforms_first():
	
	  user_numforms_first(p) -> operand_locator_t
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: user_numforms_iterator_t)
	  

ida_hexrays.user_numforms_free():
	
	  user_numforms_free(map)
	
	
	  Delete user_numforms_t instance.
	  
	  
	  @param map (C++: user_numforms_t *)
	  

ida_hexrays.user_numforms_insert():
	
	  user_numforms_insert(map, key, val) -> user_numforms_iterator_t
	
	
	  Insert new ( 'operand_locator_t' , 'number_format_t' ) pair into
	  user_numforms_t.
	  
	  
	  @param map (C++: user_numforms_t *)
	  @param key (C++: const  operand_locator_t  &)
	  @param val (C++: const  number_format_t  &)
	  

class ida_hexrays.user_numforms_iterator_t():
	
	    Proxy of C++ user_numforms_iterator_t class
	    

ida_hexrays.user_numforms_iterator_t.x:
	user_numforms_iterator_t_x_get(self) -> iterator_word

ida_hexrays.user_numforms_new():
	
	  user_numforms_new() -> user_numforms_t
	
	
	  Create a new user_numforms_t instance.
	  

ida_hexrays.user_numforms_next():
	
	  user_numforms_next(p) -> user_numforms_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: user_numforms_iterator_t)
	  

ida_hexrays.user_numforms_prev():
	
	  user_numforms_prev(p) -> user_numforms_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: user_numforms_iterator_t)
	  

ida_hexrays.user_numforms_second():
	
	  user_numforms_second(p) -> number_format_t
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: user_numforms_iterator_t)
	  

ida_hexrays.user_numforms_size():
	
	  user_numforms_size(map) -> size_t
	
	
	  Get size of user_numforms_t.
	  
	  
	  @param map (C++: user_numforms_t *)
	  

class ida_hexrays.user_numforms_t():
	
	    Proxy of C++ std::map<(operand_locator_t,number_format_t)> class
	    

ida_hexrays.user_numforms_t.at():
	
	        at(self, _Keyval) -> number_format_t
	        

class ida_hexrays.user_numforms_t.keytype():
	
	    Proxy of C++ operand_locator_t class
	    

ida_hexrays.user_numforms_t.keytype.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.user_numforms_t.keytype.ea:
	operand_locator_t_ea_get(self) -> ea_t

ida_hexrays.user_numforms_t.keytype.opnum:
	operand_locator_t_opnum_get(self) -> int

ida_hexrays.user_numforms_t.pop():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_numforms_t.popitem():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_numforms_t.setdefault():
	
	         Sets the value associated with the provided key. 
	        

class ida_hexrays.user_numforms_t.valuetype():
	
	    Proxy of C++ number_format_t class
	    

ida_hexrays.user_numforms_t.valuetype.flags:
	number_format_t_flags_get(self) -> flags_t

ida_hexrays.user_numforms_t.valuetype.get_radix():
	
	        get_radix(self) -> int
	        

ida_hexrays.user_numforms_t.valuetype.is_char():
	
	        is_char(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_dec():
	
	        is_dec(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_enum():
	
	        is_enum(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_fixed():
	
	        is_fixed(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_hex():
	
	        is_hex(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_numop():
	
	        is_numop(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_oct():
	
	        is_oct(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.is_stroff():
	
	        is_stroff(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.needs_to_be_inverted():
	
	        needs_to_be_inverted(self) -> bool
	        

ida_hexrays.user_numforms_t.valuetype.opnum:
	number_format_t_opnum_get(self) -> char

ida_hexrays.user_numforms_t.valuetype.org_nbytes:
	number_format_t_org_nbytes_get(self) -> char

ida_hexrays.user_numforms_t.valuetype.props:
	number_format_t_props_get(self) -> char

ida_hexrays.user_numforms_t.valuetype.serial:
	number_format_t_serial_get(self) -> uchar

ida_hexrays.user_numforms_t.valuetype.type_name:
	number_format_t_type_name_get(self) -> qstring *

ida_hexrays.user_unions_begin():
	
	  user_unions_begin(map) -> user_unions_iterator_t
	
	
	  Get iterator pointing to the beginning of user_unions_t.
	  
	  
	  @param map (C++: const user_unions_t *)
	  

ida_hexrays.user_unions_clear():
	
	  user_unions_clear(map)
	
	
	  Clear user_unions_t.
	  
	  
	  @param map (C++: user_unions_t *)
	  

ida_hexrays.user_unions_end():
	
	  user_unions_end(map) -> user_unions_iterator_t
	
	
	  Get iterator pointing to the end of user_unions_t.
	  
	  
	  @param map (C++: const user_unions_t *)
	  

ida_hexrays.user_unions_erase():
	
	  user_unions_erase(map, p)
	
	
	  Erase current element from user_unions_t.
	  
	  
	  @param map (C++: user_unions_t *)
	  @param p (C++: user_unions_iterator_t)
	  

ida_hexrays.user_unions_find():
	
	  user_unions_find(map, key) -> user_unions_iterator_t
	
	
	  Find the specified key in user_unions_t.
	  
	  
	  @param map (C++: const user_unions_t *)
	  @param key (C++: const ea_t &)
	  

ida_hexrays.user_unions_first():
	
	  user_unions_first(p) -> ea_t const &
	
	
	  Get reference to the current map key.
	  
	  
	  @param p (C++: user_unions_iterator_t)
	  

ida_hexrays.user_unions_free():
	
	  user_unions_free(map)
	
	
	  Delete user_unions_t instance.
	  
	  
	  @param map (C++: user_unions_t *)
	  

ida_hexrays.user_unions_insert():
	
	  user_unions_insert(map, key, val) -> user_unions_iterator_t
	
	
	  Insert new (ea_t, intvec_t) pair into user_unions_t.
	  
	  
	  @param map (C++: user_unions_t *)
	  @param key (C++: const ea_t &)
	  @param val (C++: const  intvec_t  &)
	  

class ida_hexrays.user_unions_iterator_t():
	
	    Proxy of C++ user_unions_iterator_t class
	    

ida_hexrays.user_unions_iterator_t.x:
	user_unions_iterator_t_x_get(self) -> iterator_word

ida_hexrays.user_unions_new():
	
	  user_unions_new() -> user_unions_t
	
	
	  Create a new user_unions_t instance.
	  

ida_hexrays.user_unions_next():
	
	  user_unions_next(p) -> user_unions_iterator_t
	
	
	  Move to the next element.
	  
	  
	  @param p (C++: user_unions_iterator_t)
	  

ida_hexrays.user_unions_prev():
	
	  user_unions_prev(p) -> user_unions_iterator_t
	
	
	  Move to the previous element.
	  
	  
	  @param p (C++: user_unions_iterator_t)
	  

ida_hexrays.user_unions_second():
	
	  user_unions_second(p) -> intvec_t &
	
	
	  Get reference to the current map value.
	  
	  
	  @param p (C++: user_unions_iterator_t)
	  

ida_hexrays.user_unions_size():
	
	  user_unions_size(map) -> size_t
	
	
	  Get size of user_unions_t.
	  
	  
	  @param map (C++: user_unions_t *)
	  

class ida_hexrays.user_unions_t():
	
	    Proxy of C++ std::map<(ea_t,intvec_t)> class
	    

ida_hexrays.user_unions_t.at():
	
	        at(self, _Keyval) -> qvector< int > &
	        

ida_hexrays.user_unions_t.pop():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_unions_t.popitem():
	
	         Sets the value associated with the provided key. 
	        

ida_hexrays.user_unions_t.setdefault():
	
	         Sets the value associated with the provided key. 
	        

class ida_hexrays.user_unions_t.valuetype():
	
	    Proxy of C++ qvector<(int)> class
	    

ida_hexrays.user_unions_t.valuetype.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_hexrays.user_unions_t.valuetype.at():
	
	        __getitem__(self, i) -> int const &
	        

ida_hexrays.user_unions_t.valuetype.begin():
	
	        begin(self) -> qvector< int >::iterator
	        begin(self) -> qvector< int >::const_iterator
	        

ida_hexrays.user_unions_t.valuetype.capacity():
	
	        capacity(self) -> size_t
	        

ida_hexrays.user_unions_t.valuetype.clear():
	
	        clear(self)
	        

ida_hexrays.user_unions_t.valuetype.empty():
	
	        empty(self) -> bool
	        

ida_hexrays.user_unions_t.valuetype.end():
	
	        end(self) -> qvector< int >::iterator
	        end(self) -> qvector< int >::const_iterator
	        

ida_hexrays.user_unions_t.valuetype.erase():
	
	        erase(self, it) -> qvector< int >::iterator
	        erase(self, first, last) -> qvector< int >::iterator
	        

ida_hexrays.user_unions_t.valuetype.extract():
	
	        extract(self) -> int *
	        

ida_hexrays.user_unions_t.valuetype.find():
	
	        find(self, x) -> qvector< int >::iterator
	        find(self, x) -> qvector< int >::const_iterator
	        

ida_hexrays.user_unions_t.valuetype.has():
	
	        has(self, x) -> bool
	        

ida_hexrays.user_unions_t.valuetype.inject():
	
	        inject(self, s, len)
	        

ida_hexrays.user_unions_t.valuetype.insert():
	
	        insert(self, it, x) -> qvector< int >::iterator
	        

ida_hexrays.user_unions_t.valuetype.pop_back():
	
	        pop_back(self)
	        

ida_hexrays.user_unions_t.valuetype.push_back():
	
	        push_back(self, x)
	        push_back(self) -> int &
	        

ida_hexrays.user_unions_t.valuetype.qclear():
	
	        qclear(self)
	        

ida_hexrays.user_unions_t.valuetype.reserve():
	
	        reserve(self, cnt)
	        

ida_hexrays.user_unions_t.valuetype.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_hexrays.user_unions_t.valuetype.size():
	
	        size(self) -> size_t
	        

ida_hexrays.user_unions_t.valuetype.swap():
	
	        swap(self, r)
	        

ida_hexrays.user_unions_t.valuetype.truncate():
	
	        truncate(self)
	        

class ida_hexrays.var_ref_t():
	
	    Proxy of C++ var_ref_t class
	    

ida_hexrays.var_ref_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.var_ref_t.idx:
	var_ref_t_idx_get(self) -> int

ida_hexrays.var_ref_t.mba:
	var_ref_t_mba_get(self) -> mbl_array_t *

class ida_hexrays.vc_printer_t():
	
	    Proxy of C++ vc_printer_t class
	    

ida_hexrays.vc_printer_t._print():
	
	        _print(self, indent, format) -> int
	        

ida_hexrays.vc_printer_t.func:
	vc_printer_t_func_get(self) -> cfunc_t

ida_hexrays.vc_printer_t.hdrlines:
	vd_printer_t_hdrlines_get(self) -> int

ida_hexrays.vc_printer_t.lastchar:
	vc_printer_t_lastchar_get(self) -> char

ida_hexrays.vc_printer_t.oneliner():
	
	        oneliner(self) -> bool
	        

class ida_hexrays.vd_failure_t():
	
	    Proxy of C++ vd_failure_t class
	    

ida_hexrays.vd_failure_t.desc():
	
	        desc(self) -> qstring
	        

ida_hexrays.vd_failure_t.hf:
	vd_failure_t_hf_get(self) -> hexrays_failure_t

class ida_hexrays.vd_interr_t():
	
	    Proxy of C++ vd_interr_t class
	    

ida_hexrays.vd_interr_t.desc():
	
	        desc(self) -> qstring
	        

ida_hexrays.vd_interr_t.hf:
	vd_failure_t_hf_get(self) -> hexrays_failure_t

class ida_hexrays.vd_printer_t():
	
	    Proxy of C++ vd_printer_t class
	    

ida_hexrays.vd_printer_t._print():
	
	        _print(self, indent, format) -> int
	        

ida_hexrays.vd_printer_t.hdrlines:
	vd_printer_t_hdrlines_get(self) -> int

class ida_hexrays.vdloc_t():
	
	    Proxy of C++ vdloc_t class
	    

ida_hexrays.vdloc_t.advance():
	
	        advance(self, delta) -> bool
	        

ida_hexrays.vdloc_t.atype():
	
	        atype(self) -> argloc_type_t
	        

ida_hexrays.vdloc_t.calc_offset():
	
	        calc_offset(self) -> sval_t
	        

ida_hexrays.vdloc_t.compare():
	
	        compare(self, r) -> int
	        

ida_hexrays.vdloc_t.consume_rrel():
	
	        consume_rrel(self, p)
	        

ida_hexrays.vdloc_t.consume_scattered():
	
	        consume_scattered(self, p)
	        

ida_hexrays.vdloc_t.get_biggest():
	
	        get_biggest(self) -> argloc_t::biggest_t
	        

ida_hexrays.vdloc_t.get_custom():
	
	        get_custom(self) -> void *
	        

ida_hexrays.vdloc_t.get_ea():
	
	        get_ea(self) -> ea_t
	        

ida_hexrays.vdloc_t.get_reginfo():
	
	        get_reginfo(self) -> uint32
	        

ida_hexrays.vdloc_t.get_rrel():
	
	        get_rrel(self) -> rrel_t
	        get_rrel(self) -> rrel_t
	        

ida_hexrays.vdloc_t.is_aliasable():
	
	        is_aliasable(self, mb, size) -> bool
	        

ida_hexrays.vdloc_t.is_badloc():
	
	        is_badloc(self) -> bool
	        

ida_hexrays.vdloc_t.is_custom():
	
	        is_custom(self) -> bool
	        

ida_hexrays.vdloc_t.is_ea():
	
	        is_ea(self) -> bool
	        

ida_hexrays.vdloc_t.is_fragmented():
	
	        is_fragmented(self) -> bool
	        

ida_hexrays.vdloc_t.is_mixed_scattered():
	
	        is_mixed_scattered(self) -> bool
	        

ida_hexrays.vdloc_t.is_reg():
	
	        is_reg(self) -> bool
	        

ida_hexrays.vdloc_t.is_reg1():
	
	        is_reg1(self) -> bool
	        

ida_hexrays.vdloc_t.is_reg2():
	
	        is_reg2(self) -> bool
	        

ida_hexrays.vdloc_t.is_rrel():
	
	        is_rrel(self) -> bool
	        

ida_hexrays.vdloc_t.is_scattered():
	
	        is_scattered(self) -> bool
	        

ida_hexrays.vdloc_t.is_stkoff():
	
	        is_stkoff(self) -> bool
	        

ida_hexrays.vdloc_t.reg1():
	
	        reg1(self) -> int
	        

ida_hexrays.vdloc_t.reg2():
	
	        reg2(self) -> int
	        

ida_hexrays.vdloc_t.regoff():
	
	        regoff(self) -> int
	        

ida_hexrays.vdloc_t.scattered():
	
	        scattered(self) -> scattered_aloc_t
	        scattered(self) -> scattered_aloc_t
	        

ida_hexrays.vdloc_t.set_badloc():
	
	        set_badloc(self)
	        

ida_hexrays.vdloc_t.set_ea():
	
	        set_ea(self, _ea)
	        

ida_hexrays.vdloc_t.set_reg1():
	
	        set_reg1(self, r1)
	        

ida_hexrays.vdloc_t.set_reg2():
	
	        set_reg2(self, _reg1, _reg2)
	        

ida_hexrays.vdloc_t.set_stkoff():
	
	        set_stkoff(self, off)
	        

ida_hexrays.vdloc_t.stkoff():
	
	        stkoff(self) -> sval_t
	        

ida_hexrays.vdloc_t.swap():
	
	        swap(self, r)
	        

class ida_hexrays.vdui_t():
	
	    Proxy of C++ vdui_t class
	    

ida_hexrays.vdui_t.calc_cmt_type():
	
	        calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
	        

ida_hexrays.vdui_t.cfunc:
	vdui_t_cfunc_get(self) -> cfuncptr_t

ida_hexrays.vdui_t.clear():
	
	        clear(self)
	        

ida_hexrays.vdui_t.collapse_item():
	
	        collapse_item(self, hide) -> bool
	        

ida_hexrays.vdui_t.collapse_lvars():
	
	        collapse_lvars(self, hide) -> bool
	        

ida_hexrays.vdui_t.cpos:
	vdui_t_cpos_get(self) -> ctext_position_t

ida_hexrays.vdui_t.ct:
	vdui_t_ct_get(self) -> TWidget *

ida_hexrays.vdui_t.ctree_to_disasm():
	
	        ctree_to_disasm(self) -> bool
	        

ida_hexrays.vdui_t.del_orphan_cmts():
	
	        del_orphan_cmts(self) -> bool
	        

ida_hexrays.vdui_t.edit_cmt():
	
	        edit_cmt(self, loc) -> bool
	        

ida_hexrays.vdui_t.edit_func_cmt():
	
	        edit_func_cmt(self) -> bool
	        

ida_hexrays.vdui_t.flags:
	vdui_t_flags_get(self) -> int

ida_hexrays.vdui_t.get_current_item():
	
	        get_current_item(self, idv) -> bool
	        

ida_hexrays.vdui_t.get_current_label():
	
	        get_current_label(self) -> int
	        

ida_hexrays.vdui_t.get_number():
	
	        get_number(self) -> cnumber_t
	        

ida_hexrays.vdui_t.head:
	vdui_t_head_get(self) -> ctree_item_t

ida_hexrays.vdui_t.in_ctree():
	
	        in_ctree(self) -> bool
	        

ida_hexrays.vdui_t.invert_bits():
	
	        invert_bits(self) -> bool
	        

ida_hexrays.vdui_t.invert_sign():
	
	        invert_sign(self) -> bool
	        

ida_hexrays.vdui_t.item:
	vdui_t_item_get(self) -> ctree_item_t

ida_hexrays.vdui_t.jump_enter():
	
	        jump_enter(self, idv, omflags) -> bool
	        

ida_hexrays.vdui_t.last_code:
	vdui_t_last_code_get(self) -> merror_t

ida_hexrays.vdui_t.locked():
	
	        locked(self) -> bool
	        

ida_hexrays.vdui_t.map_lvar():
	
	        map_lvar(self, _from, to) -> bool
	        

ida_hexrays.vdui_t.mba:
	vdui_t_mba_get(self) -> mbl_array_t *

ida_hexrays.vdui_t.refresh_cpos():
	
	        refresh_cpos(self, idv) -> bool
	        

ida_hexrays.vdui_t.refresh_ctext():
	
	        refresh_ctext(self, activate=True)
	        

ida_hexrays.vdui_t.refresh_view():
	
	        refresh_view(self, redo_mba)
	        

ida_hexrays.vdui_t.rename_global():
	
	        rename_global(self, ea) -> bool
	        

ida_hexrays.vdui_t.rename_label():
	
	        rename_label(self, label) -> bool
	        

ida_hexrays.vdui_t.rename_lvar():
	
	        rename_lvar(self, v, name, is_user_name) -> bool
	        

ida_hexrays.vdui_t.rename_strmem():
	
	        rename_strmem(self, sptr, mptr) -> bool
	        

ida_hexrays.vdui_t.set_global_type():
	
	        set_global_type(self, ea) -> bool
	        

ida_hexrays.vdui_t.set_locked():
	
	        set_locked(self, v) -> bool
	        

ida_hexrays.vdui_t.set_lvar_cmt():
	
	        set_lvar_cmt(self, v, cmt) -> bool
	        

ida_hexrays.vdui_t.set_lvar_type():
	
	        set_lvar_type(self, v, type) -> bool
	        

ida_hexrays.vdui_t.set_noptr_lvar():
	
	        set_noptr_lvar(self, v) -> bool
	        

ida_hexrays.vdui_t.set_num_enum():
	
	        set_num_enum(self) -> bool
	        

ida_hexrays.vdui_t.set_num_radix():
	
	        set_num_radix(self, base) -> bool
	        

ida_hexrays.vdui_t.set_num_stroff():
	
	        set_num_stroff(self) -> bool
	        

ida_hexrays.vdui_t.set_strmem_type():
	
	        set_strmem_type(self, sptr, mptr) -> bool
	        

ida_hexrays.vdui_t.set_valid():
	
	        set_valid(self, v)
	        

ida_hexrays.vdui_t.set_visible():
	
	        set_visible(self, v)
	        

ida_hexrays.vdui_t.split_item():
	
	        split_item(self, split) -> bool
	        

ida_hexrays.vdui_t.switch_to():
	
	        switch_to(self, f, activate)
	        

ida_hexrays.vdui_t.tail:
	vdui_t_tail_get(self) -> ctree_item_t

ida_hexrays.vdui_t.toplevel:
	vdui_t_toplevel_get(self) -> TWidget *

ida_hexrays.vdui_t.ui_edit_lvar_cmt():
	
	        ui_edit_lvar_cmt(self, v) -> bool
	        

ida_hexrays.vdui_t.ui_map_lvar():
	
	        ui_map_lvar(self, v) -> bool
	        

ida_hexrays.vdui_t.ui_rename_lvar():
	
	        ui_rename_lvar(self, v) -> bool
	        

ida_hexrays.vdui_t.ui_set_call_type():
	
	        ui_set_call_type(self, e) -> bool
	        

ida_hexrays.vdui_t.ui_set_lvar_type():
	
	        ui_set_lvar_type(self, v) -> bool
	        

ida_hexrays.vdui_t.ui_unmap_lvar():
	
	        ui_unmap_lvar(self, v) -> bool
	        

ida_hexrays.vdui_t.valid():
	
	        valid(self) -> bool
	        

ida_hexrays.vdui_t.view_idx:
	vdui_t_view_idx_get(self) -> int

ida_hexrays.vdui_t.visible():
	
	        visible(self) -> bool
	        


=== ida_hexrays EPYDOC INJECTIONS ===
ida_hexrays.ANCHOR_BLKCMT
"""
block comment (for ctree items)
"""

ida_hexrays.ANCHOR_CITEM
"""
c-tree item
"""

ida_hexrays.ANCHOR_ITP
"""
item type preciser
"""

ida_hexrays.ANCHOR_LVAR
"""
declaration of local variable
"""

ida_hexrays.CFL_FINAL
"""
call type is final, should not be changed
"""

ida_hexrays.CFL_HELPER
"""
created from a decompiler helper function
"""

ida_hexrays.CFS_BOUNDS
"""
'eamap' and 'boundaries' are ready
"""

ida_hexrays.CFS_LVARS_HIDDEN
"""
local variable definitions are collapsed
"""

ida_hexrays.CFS_TEXT
"""
'sv' is ready (and hdrlines)
"""

ida_hexrays.CIT_COLLAPSED
"""
display element in collapsed form
"""

ida_hexrays.CV_FAST
"""
do not maintain parent information
"""

ida_hexrays.CV_INSNS
"""
visit only statements, prune all expressions do not use before the
final ctree maturity because expressions may contain statements at
intermediate stages (see cot_insn). Otherwise you risk missing
statements embedded into expressions.
"""

ida_hexrays.CV_PARENTS
"""
maintain parent information
"""

ida_hexrays.CV_POST
"""
call the leave...() functions
"""

ida_hexrays.CV_PRUNE
"""
this bit is set by visit...() to prune the walk
"""

ida_hexrays.CV_RESTART
"""
restart enumeration at the top expr (apply_to_exprs)
"""

ida_hexrays.DECOMP_NO_CACHE
"""
do not use decompilation cache
"""

ida_hexrays.DECOMP_NO_FRAME
"""
do not use function frame info (only snippet mode)
"""

ida_hexrays.DECOMP_NO_WAIT
"""
do not display waitbox
"""

ida_hexrays.DECOMP_WARNINGS
"""
display warnings in the output window
"""

ida_hexrays.EXFL_ALL
"""
all currently defined bits
"""

ida_hexrays.EXFL_ALONE
"""
standalone helper
"""

ida_hexrays.EXFL_CPADONE
"""
pointer arithmetic correction done
"""

ida_hexrays.EXFL_CSTR
"""
string literal
"""

ida_hexrays.EXFL_FPOP
"""
floating point operation
"""

ida_hexrays.EXFL_JUMPOUT
"""
jump out-of-function
"""

ida_hexrays.EXFL_LVALUE
"""
expression is lvalue even if it doesn't look like it
"""

ida_hexrays.EXFL_PARTIAL
"""
type of the expression is considered partial
"""

ida_hexrays.EXFL_UNDEF
"""
expression uses undefined value
"""

ida_hexrays.EXFL_VFTABLE
"""
is ptr to vftable (used for cot_memptr, cot_memref)
"""

ida_hexrays.GLN_ALL
"""
get both
"""

ida_hexrays.GLN_CURRENT
"""
get label of the current item
"""

ida_hexrays.GLN_GOTO_TARGET
"""
get goto target
"""

ida_hexrays.LVINF_FORCE
"""
force allocation of a new variable. forces the decompiler to create a
new variable at ll.defea
"""

ida_hexrays.LVINF_KEEP
"""
preserve saved user settings regardless of vars for example, if a var
loses all its user-defined attributes or even gets destroyed, keep its
'lvar_saved_info_t' . this is used for ephemeral variables that get
destroyed by macro recognition.
"""

ida_hexrays.LVINF_NOPTR
"""
variable type should not be a pointer
"""

ida_hexrays.NF_BINVDONE
"""
temporary internal bit: inverting bits is done
"""

ida_hexrays.NF_BITNOT
"""
The user asked to invert bits of the constant.
"""

ida_hexrays.NF_FIXED
"""
number format has been defined by the user
"""

ida_hexrays.NF_NEGATE
"""
The user asked to negate the constant.
"""

ida_hexrays.NF_NEGDONE
"""
temporary internal bit: negation has been performed
"""

ida_hexrays.NF_STROFF
"""
internal bit: used as stroff, valid iff 'is_stroff()'
"""

ida_hexrays.SHINS_LDXEA
"""
display address of ldx expressions (not used)
"""

ida_hexrays.SHINS_NUMADDR
"""
display definition addresses for numbers
"""

ida_hexrays.SHINS_SHORT
"""
do not display use-def chains and other attrs
"""

ida_hexrays.SHINS_VALNUM
"""
display value numbers
"""

ida_hexrays.ULV_PRECISE_DEFEA
"""
Use precise defea's for lvar locations.
"""

ida_hexrays.VDRUN_APPEND
"""
Create a new file or append to existing file.
"""

ida_hexrays.VDRUN_CMDLINE
"""
called from ida's command line
"""

ida_hexrays.VDRUN_LUMINA
"""
use lumina server
"""

ida_hexrays.VDRUN_MAYSTOP
"""
the user can cancel decompilation
"""

ida_hexrays.VDRUN_NEWFILE
"""
Create a new file or overwrite existing file.
"""

ida_hexrays.VDRUN_ONLYNEW
"""
Fail if output file already exists.
"""

ida_hexrays.VDRUN_SENDIDB
"""
Send problematic databases to hex-rays.com.
"""

ida_hexrays.VDRUN_SILENT
"""
Silent decompilation.
"""

ida_hexrays.VDRUN_STATS
"""
print statistics into vd_stats.txt
"""

ida_hexrays.VDUI_LOCKED
"""
is locked?
"""

ida_hexrays.VDUI_VALID
"""
is valid?
"""

ida_hexrays.VDUI_VISIBLE
"""
is visible?
"""
=== ida_hexrays EPYDOC INJECTIONS END ===
ida_ida.calc_default_idaplace_flags():
	
	  calc_default_idaplace_flags() -> int
	
	
	  Get default disassembly line options.
	  

class ida_ida.compiler_info_t():
	
	    Proxy of C++ compiler_info_t class
	    

ida_ida.compiler_info_t.cm:
	compiler_info_t_cm_get(self) -> cm_t

ida_ida.compiler_info_t.defalign:
	compiler_info_t_defalign_get(self) -> uchar

ida_ida.compiler_info_t.id:
	compiler_info_t_id_get(self) -> comp_t

ida_ida.compiler_info_t.set_64bit_pointer_size():
	
	        set_64bit_pointer_size(self)
	        

ida_ida.compiler_info_t.size_b:
	compiler_info_t_size_b_get(self) -> uchar

ida_ida.compiler_info_t.size_e:
	compiler_info_t_size_e_get(self) -> uchar

ida_ida.compiler_info_t.size_i:
	compiler_info_t_size_i_get(self) -> uchar

ida_ida.compiler_info_t.size_l:
	compiler_info_t_size_l_get(self) -> uchar

ida_ida.compiler_info_t.size_ldbl:
	compiler_info_t_size_ldbl_get(self) -> uchar

ida_ida.compiler_info_t.size_ll:
	compiler_info_t_size_ll_get(self) -> uchar

ida_ida.compiler_info_t.size_s:
	compiler_info_t_size_s_get(self) -> uchar

class ida_ida.idainfo():
	
	    Proxy of C++ idainfo class
	    

ida_ida.idainfo.abibits:
	idainfo_abibits_get(self) -> uint32

ida_ida.idainfo.abiname:
	
	        get_abiname(self) -> qstring
	        

ida_ida.idainfo.af:
	idainfo_af_get(self) -> uint32

ida_ida.idainfo.af2:
	idainfo_af2_get(self) -> uint32

ida_ida.idainfo.appcall_options:
	idainfo_appcall_options_get(self) -> uint32

ida_ida.idainfo.apptype:
	idainfo_apptype_get(self) -> ushort

ida_ida.idainfo.asmtype:
	idainfo_asmtype_get(self) -> uchar

ida_ida.idainfo.baseaddr:
	idainfo_baseaddr_get(self) -> uval_t

ida_ida.idainfo.big_arg_align():
	
	        big_arg_align(self) -> bool
	        

ida_ida.idainfo.bin_prefix_size:
	idainfo_bin_prefix_size_get(self) -> short

ida_ida.idainfo.cc:
	idainfo_cc_get(self) -> compiler_info_t

ida_ida.idainfo.comment:
	idainfo_comment_get(self) -> uchar

ida_ida.idainfo.database_change_count:
	idainfo_database_change_count_get(self) -> uint32

ida_ida.idainfo.datatypes:
	idainfo_datatypes_get(self) -> uval_t

ida_ida.idainfo.demnames:
	idainfo_demnames_get(self) -> uchar

ida_ida.idainfo.filetype:
	idainfo_filetype_get(self) -> ushort

ida_ida.idainfo.gen_lzero():
	
	        gen_lzero(self) -> bool
	        

ida_ida.idainfo.gen_null():
	
	        gen_null(self) -> bool
	        

ida_ida.idainfo.gen_tryblks():
	
	        gen_tryblks(self) -> bool
	        

ida_ida.idainfo.get_abiname():
	
	        get_abiname(self) -> qstring
	        

ida_ida.idainfo.get_demname_form():
	
	        get_demname_form(self) -> uchar
	        

ida_ida.idainfo.get_maxEA():
	
	        get_maxEA(self) -> ea_t
	        

ida_ida.idainfo.get_minEA():
	
	        get_minEA(self) -> ea_t
	        

ida_ida.idainfo.get_pack_mode():
	
	        get_pack_mode(self) -> int
	        

ida_ida.idainfo.get_procName():
	
	        get_procName(self) -> qstring
	        

ida_ida.idainfo.highoff:
	idainfo_highoff_get(self) -> ea_t

ida_ida.idainfo.indent:
	idainfo_indent_get(self) -> uchar

ida_ida.idainfo.is_32bit():
	
	        is_32bit(self) -> bool
	        

ida_ida.idainfo.is_64bit():
	
	        is_64bit(self) -> bool
	        

ida_ida.idainfo.is_auto_enabled():
	
	        is_auto_enabled(self) -> bool
	        

ida_ida.idainfo.is_be():
	
	        is_be(self) -> bool
	        

ida_ida.idainfo.is_dll():
	
	        is_dll(self) -> bool
	        

ida_ida.idainfo.is_flat_off32():
	
	        is_flat_off32(self) -> bool
	        

ida_ida.idainfo.is_graph_view():
	
	        is_graph_view(self) -> bool
	        

ida_ida.idainfo.is_hard_float():
	
	        is_hard_float(self) -> bool
	        

ida_ida.idainfo.is_kernel_mode():
	
	        is_kernel_mode(self) -> bool
	        

ida_ida.idainfo.is_mem_aligned4():
	
	        is_mem_aligned4(self) -> bool
	        

ida_ida.idainfo.is_snapshot():
	
	        is_snapshot(self) -> bool
	        

ida_ida.idainfo.is_wide_high_byte_first():
	
	        is_wide_high_byte_first(self) -> bool
	        

ida_ida.idainfo.lenxref:
	idainfo_lenxref_get(self) -> ushort

ida_ida.idainfo.lflags:
	idainfo_lflags_get(self) -> uint32

ida_ida.idainfo.like_binary():
	
	        like_binary(self) -> bool
	        

ida_ida.idainfo.line_pref_with_seg():
	
	        line_pref_with_seg(self) -> bool
	        

ida_ida.idainfo.listnames:
	idainfo_listnames_get(self) -> uchar

ida_ida.idainfo.loading_idc():
	
	        loading_idc(self) -> bool
	        

ida_ida.idainfo.long_demnames:
	idainfo_long_demnames_get(self) -> uint32

ida_ida.idainfo.lowoff:
	idainfo_lowoff_get(self) -> ea_t

ida_ida.idainfo.main:
	idainfo_main_get(self) -> ea_t

ida_ida.idainfo.margin:
	idainfo_margin_get(self) -> ushort

ida_ida.idainfo.maxEA:
	
	        get_maxEA(self) -> ea_t
	        

ida_ida.idainfo.max_autoname_len:
	idainfo_max_autoname_len_get(self) -> ushort

ida_ida.idainfo.max_ea:
	idainfo_max_ea_get(self) -> ea_t

ida_ida.idainfo.maxref:
	idainfo_maxref_get(self) -> uval_t

ida_ida.idainfo.minEA:
	
	        get_minEA(self) -> ea_t
	        

ida_ida.idainfo.min_ea:
	idainfo_min_ea_get(self) -> ea_t

ida_ida.idainfo.nametype:
	idainfo_nametype_get(self) -> char

ida_ida.idainfo.omax_ea:
	idainfo_omax_ea_get(self) -> ea_t

ida_ida.idainfo.omin_ea:
	idainfo_omin_ea_get(self) -> ea_t

ida_ida.idainfo.ostype:
	idainfo_ostype_get(self) -> ushort

ida_ida.idainfo.outflags:
	idainfo_outflags_get(self) -> uint32

ida_ida.idainfo.pack_stkargs():
	
	        pack_stkargs(self) -> bool
	        

ida_ida.idainfo.procName:
	
	        get_procName(self) -> qstring
	        

ida_ida.idainfo.procname:
	idainfo_procname_get(self) -> char [16]

ida_ida.idainfo.readonly_idb():
	
	        readonly_idb(self) -> bool
	        

ida_ida.idainfo.refcmtnum:
	idainfo_refcmtnum_get(self) -> uchar

ida_ida.idainfo.s_cmtflg:
	idainfo_s_cmtflg_get(self) -> uchar

ida_ida.idainfo.s_genflags:
	idainfo_s_genflags_get(self) -> ushort

ida_ida.idainfo.s_limiter:
	idainfo_s_limiter_get(self) -> uchar

ida_ida.idainfo.s_prefflag:
	idainfo_s_prefflag_get(self) -> uchar

ida_ida.idainfo.s_xrefflag:
	idainfo_s_xrefflag_get(self) -> uchar

ida_ida.idainfo.set_64bit():
	
	        set_64bit(self)
	        

ida_ida.idainfo.set_auto_enabled():
	
	        set_auto_enabled(self, value)
	        

ida_ida.idainfo.set_be():
	
	        set_be(self, value) -> bool
	        

ida_ida.idainfo.set_gen_lzero():
	
	        set_gen_lzero(self, value)
	        

ida_ida.idainfo.set_gen_null():
	
	        set_gen_null(self, value)
	        

ida_ida.idainfo.set_gen_tryblks():
	
	        set_gen_tryblks(self, value)
	        

ida_ida.idainfo.set_graph_view():
	
	        set_graph_view(self, value)
	        

ida_ida.idainfo.set_line_pref_with_seg():
	
	        set_line_pref_with_seg(self, value)
	        

ida_ida.idainfo.set_maxEA():
	
	        set_maxEA(self, ea)
	        

ida_ida.idainfo.set_minEA():
	
	        set_minEA(self, ea)
	        

ida_ida.idainfo.set_pack_mode():
	
	        set_pack_mode(self, pack_mode) -> int
	        

ida_ida.idainfo.set_show_auto():
	
	        set_show_auto(self, value)
	        

ida_ida.idainfo.set_show_line_pref():
	
	        set_show_line_pref(self, value)
	        

ida_ida.idainfo.set_show_void():
	
	        set_show_void(self, value)
	        

ida_ida.idainfo.set_wide_high_byte_first():
	
	        set_wide_high_byte_first(self, value)
	        

ida_ida.idainfo.short_demnames:
	idainfo_short_demnames_get(self) -> uint32

ida_ida.idainfo.show_auto():
	
	        show_auto(self) -> bool
	        

ida_ida.idainfo.show_line_pref():
	
	        show_line_pref(self) -> bool
	        

ida_ida.idainfo.show_void():
	
	        show_void(self) -> bool
	        

ida_ida.idainfo.specsegs:
	idainfo_specsegs_get(self) -> uchar

ida_ida.idainfo.stack_ldbl():
	
	        stack_ldbl(self) -> bool
	        

ida_ida.idainfo.stack_varargs():
	
	        stack_varargs(self) -> bool
	        

ida_ida.idainfo.start_cs:
	idainfo_start_cs_get(self) -> sel_t

ida_ida.idainfo.start_ea:
	idainfo_start_ea_get(self) -> ea_t

ida_ida.idainfo.start_ip:
	idainfo_start_ip_get(self) -> ea_t

ida_ida.idainfo.start_sp:
	idainfo_start_sp_get(self) -> ea_t

ida_ida.idainfo.start_ss:
	idainfo_start_ss_get(self) -> sel_t

ida_ida.idainfo.strlit_break:
	idainfo_strlit_break_get(self) -> uchar

ida_ida.idainfo.strlit_flags:
	idainfo_strlit_flags_get(self) -> uchar

ida_ida.idainfo.strlit_pref:
	idainfo_strlit_pref_get(self) -> char [16]

ida_ida.idainfo.strlit_sernum:
	idainfo_strlit_sernum_get(self) -> uval_t

ida_ida.idainfo.strlit_zeroes:
	idainfo_strlit_zeroes_get(self) -> char

ida_ida.idainfo.strtype:
	idainfo_strtype_get(self) -> int32

ida_ida.idainfo.tag:
	idainfo_tag_get(self) -> char [3]

ida_ida.idainfo.type_xrefnum:
	idainfo_type_xrefnum_get(self) -> uchar

ida_ida.idainfo.use_allasm():
	
	        use_allasm(self) -> bool
	        

ida_ida.idainfo.use_gcc_layout():
	
	        use_gcc_layout(self) -> bool
	        

ida_ida.idainfo.version:
	idainfo_version_get(self) -> ushort

ida_ida.idainfo.xrefnum:
	idainfo_xrefnum_get(self) -> uchar

ida_ida.should_create_stkvars():
	
	  should_create_stkvars() -> bool
	
	
	  Is IDA configured to create stack variables?
	  

ida_ida.should_trace_sp():
	
	  should_trace_sp() -> bool
	
	
	  Is IDA configured to trace the stack pointer?
	  

ida_ida.show_all_comments():
	
	  show_all_comments() -> bool
	
	
	  Is IDA configured to show all comment lines?
	  

ida_ida.show_comments():
	
	  show_comments() -> bool
	
	
	  Is IDA configured to show any comments at all?
	  

ida_ida.show_repeatables():
	
	  show_repeatables() -> bool
	
	
	  Is IDA configured to show all repeatable comments?
	  

ida_ida.to_ea():
	
	  to_ea(reg_cs, reg_ip) -> ea_t
	
	
	  Convert (seg,off) value to a linear address.
	  
	  
	  @param reg_cs (C++: sel_t)
	  @param reg_ip (C++: ea_t)
	  


=== ida_ida EPYDOC INJECTIONS ===
ida_ida.ABI_8ALIGN4
"""
4 byte alignment for 8byte scalars (__int64/double) inside structures?
"""

ida_ida.ABI_BIGARG_ALIGN
"""
(e.g. __int64 argument should be 8byte aligned on some 32bit
platforms)

use natural type alignment for argument if the alignment exceeds
native word size
"""

ida_ida.ABI_GCC_LAYOUT
"""
use gcc layout for udts (used for mingw)
"""

ida_ida.ABI_HARD_FLOAT
"""
use the floating-point register set
"""

ida_ida.ABI_PACK_STKARGS
"""
do not align stack arguments to stack slots
"""

ida_ida.ABI_SET_BY_USER
"""
compiler/abi were set by user flag and require SETCOMP_BY_USER flag to
be changed
"""

ida_ida.ABI_STACK_LDBL
"""
long double areuments are passed on stack
"""

ida_ida.ABI_STACK_VARARGS
"""
varargs are always passed on stack (even when there are free
registers)
"""

ida_ida.AF2_DOEH
"""
Handle EH information.
"""

ida_ida.AF2_DORTTI
"""
Handle RTTI information
"""

ida_ida.AF_ANORET
"""
Perform 'no-return' analysis.
"""

ida_ida.AF_CHKUNI
"""
Check for unicode strings.
"""

ida_ida.AF_CODE
"""
Trace execution flow.
"""

ida_ida.AF_DATOFF
"""
Automatically convert data to offsets.
"""

ida_ida.AF_DOCODE
"""
Coagulate code segs at the final pass.
"""

ida_ida.AF_DODATA
"""
Coagulate data segs at the final pass.
"""

ida_ida.AF_DREFOFF
"""
Create offset if data xref to seg32 exists.
"""

ida_ida.AF_FINAL
"""
Final pass of analysis.
"""

ida_ida.AF_FIXUP
"""
Create offsets and segments using fixup info.
"""

ida_ida.AF_FLIRT
"""
Use flirt signatures.
"""

ida_ida.AF_FTAIL
"""
Create function tails.
"""

ida_ida.AF_HFLIRT
"""
Automatically hide library functions.
"""

ida_ida.AF_IMMOFF
"""
Convert 32bit instruction operand to offset.
"""

ida_ida.AF_JFUNC
"""
Rename jump functions as j_...
"""

ida_ida.AF_JUMPTBL
"""
Locate and create jump tables.
"""

ida_ida.AF_LVAR
"""
Create stack variables.
"""

ida_ida.AF_MARKCODE
"""
Mark typical code sequences as code.
"""

ida_ida.AF_MEMFUNC
"""
Try to guess member function types.
"""

ida_ida.AF_NULLSUB
"""
Rename empty functions as nullsub_...
"""

ida_ida.AF_PROC
"""
Create functions if call is present.
"""

ida_ida.AF_PROCPTR
"""
Create function if data xref data->code32 exists.
"""

ida_ida.AF_PURDAT
"""
Control flow to data segment is ignored.
"""

ida_ida.AF_REGARG
"""
Propagate register argument information.
"""

ida_ida.AF_SIGCMT
"""
Append a signature name comment for recognized anonymous library
functions.
"""

ida_ida.AF_SIGMLT
"""
Allow recognition of several copies of the same function.
"""

ida_ida.AF_STKARG
"""
Propagate stack argument information.
"""

ida_ida.AF_STRLIT
"""
Create string literal if data xref exists.
"""

ida_ida.AF_TRACE
"""
Trace stack pointer.
"""

ida_ida.AF_TRFUNC
"""
Truncate functions upon code deletion.
"""

ida_ida.AF_UNK
"""
Delete instructions with no xrefs.
"""

ida_ida.AF_USED
"""
Analyze and create all xrefs.
"""

ida_ida.AF_VERSP
"""
Perform full SP-analysis. ({verify_sp})
"""

ida_ida.DEMNAM_CMNT
"""
display demangled names as comments
"""

ida_ida.DEMNAM_FIRST
"""
override type info
"""

ida_ida.DEMNAM_GCC3
"""
assume gcc3 names (valid for gnu compiler)
"""

ida_ida.DEMNAM_MASK
"""
mask for name form
"""

ida_ida.DEMNAM_NAME
"""
display demangled names as regular names
"""

ida_ida.DEMNAM_NONE
"""
don't display demangled names
"""

ida_ida.IDB_COMPRESSED
"""
compress & pack database components
"""

ida_ida.IDB_PACKED
"""
pack database components into .idb
"""

ida_ida.IDB_UNPACKED
"""
leave database components unpacked
"""

ida_ida.INFFL_ALLASM
"""
the target assembler

may use constructs not supported by
"""

ida_ida.INFFL_AUTO
"""
Autoanalysis is enabled?
"""

ida_ida.INFFL_CHKOPS
"""
check manual operands? (unused)
"""

ida_ida.INFFL_GRAPH_VIEW
"""
currently using graph options ({graph})
"""

ida_ida.INFFL_LOADIDC
"""
loading an idc file that contains database info
"""

ida_ida.INFFL_NMOPS
"""
allow non-matched operands? (unused)
"""

ida_ida.INFFL_NOUSER
"""
do not store user info in the database
"""

ida_ida.INFFL_READONLY
"""
(internal) temporary interdiction to modify the database
"""

ida_ida.LFLG_64BIT
"""
64-bit program?
"""

ida_ida.LFLG_COMPRESS
"""
compress the database?
"""

ida_ida.LFLG_DBG_NOPATH
"""
do not store input full path in debugger process options
"""

ida_ida.LFLG_FLAT_OFF32
"""
treat 'REF_OFF32' as 32-bit offset for 16bit segments (otherwise try
SEG16:OFF16)
"""

ida_ida.LFLG_IS_DLL
"""
Is dynamic library?
"""

ida_ida.LFLG_KERNMODE
"""
is kernel mode binary?
"""

ida_ida.LFLG_MSF
"""
Byte order: is MSB first?
"""

ida_ida.LFLG_PACK
"""
pack the database?
"""

ida_ida.LFLG_PC_FLAT
"""
32-bit program?
"""

ida_ida.LFLG_PC_FPP
"""
decode floating point processor instructions?
"""

ida_ida.LFLG_SNAPSHOT
"""
memory snapshot was taken?
"""

ida_ida.LFLG_WIDE_HBF
"""
(wide bytes: {dnbits} > 8)

Bit order of wide bytes: high byte first?
"""

ida_ida.LMT_EMPTY
"""
empty lines at the end of basic blocks
"""

ida_ida.LMT_THICK
"""
thick borders
"""

ida_ida.LMT_THIN
"""
thin borders
"""

ida_ida.LN_AUTO
"""
include autogenerated names
"""

ida_ida.LN_NORMAL
"""
include normal names
"""

ida_ida.LN_PUBLIC
"""
include public names
"""

ida_ida.LN_WEAK
"""
include weak names
"""

ida_ida.OFLG_GEN_ASSUME
"""
Generate 'assume' directives?
"""

ida_ida.OFLG_GEN_NULL
"""
Generate empty lines?
"""

ida_ida.OFLG_GEN_ORG
"""
Generate 'org' directives?
"""

ida_ida.OFLG_GEN_TRYBLKS
"""
Generate try/catch directives?
"""

ida_ida.OFLG_LZERO
"""
generate leading zeroes in numbers
"""

ida_ida.OFLG_PREF_SEG
"""
line prefixes with segment name?
"""

ida_ida.OFLG_SHOW_AUTO
"""
Display autoanalysis indicator?
"""

ida_ida.OFLG_SHOW_PREF
"""
Show line prefixes?
"""

ida_ida.OFLG_SHOW_VOID
"""
Display void marks?
"""

ida_ida.PREF_FNCOFF
"""
show function offsets?
"""

ida_ida.PREF_SEGADR
"""
show segment addresses?
"""

ida_ida.PREF_STACK
"""
show stack pointer?
"""

ida_ida.STRF_AUTO
"""
names have 'autogenerated' bit?
"""

ida_ida.STRF_COMMENT
"""
generate auto comment for string references?
"""

ida_ida.STRF_GEN
"""
generate names?
"""

ida_ida.STRF_SAVECASE
"""
preserve case of strings for identifiers
"""

ida_ida.STRF_SERIAL
"""
generate serial names?
"""

ida_ida.STRF_UNICODE
"""
unicode strings are present?
"""

ida_ida.SW_ALLCMT
"""
comment all lines?
"""

ida_ida.SW_LINNUM
"""
show source line numbers
"""

ida_ida.SW_NOCMT
"""
no comments at all
"""

ida_ida.SW_RPTCMT
"""
show repeatable comments?
"""

ida_ida.SW_SEGXRF
"""
show segments in xrefs?
"""

ida_ida.SW_SHHID_FUNC
"""
show hidden functions
"""

ida_ida.SW_SHHID_ITEM
"""
show hidden instructions
"""

ida_ida.SW_SHHID_SEGM
"""
show hidden segments
"""

ida_ida.SW_TESTMODE
"""
testida.idc is running
"""

ida_ida.SW_XRFFNC
"""
show function offsets?
"""

ida_ida.SW_XRFMRK
"""
show xref type marks?
"""

ida_ida.SW_XRFVAL
"""
show xref values? (otherwise-"...")
"""

ida_ida.UA_MAXOP
"""
max number of operands allowed for an instruction
"""
=== ida_ida EPYDOC INJECTIONS END ===
ida_idaapi.CustomIDAMemo.CreateGroups():
	
	        Send a request to modify the graph by creating a
	        (set of) group(s), and perform an animation.
	
	        Each object in the 'groups_infos' list must be of the format:
	        {
	          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
	          "text" : <string>                    # The synthetic text for that group
	        }
	
	        @param groups_infos: A list of objects that describe those groups.
	        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
	        

ida_idaapi.CustomIDAMemo.DelNodesInfos():
	
	        Delete the properties for the given node(s).
	
	        @param nodes: A list of node IDs
	        

ida_idaapi.CustomIDAMemo.DeleteGroups():
	
	        Send a request to delete the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param new_current: A node to focus on after the groups have been deleted
	        @return: True on success, False otherwise.
	        

ida_idaapi.CustomIDAMemo.GetNodeInfo():
	
	        Get the properties for the given node.
	
	        @param node: The index of the node.
	        @return: A tuple (bg_color, frame_color, ea, text), or None.
	        

ida_idaapi.CustomIDAMemo.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_idaapi.CustomIDAMemo.Refresh():
	
	        Refreshes the view. This causes the OnRefresh() to be called
	        

ida_idaapi.CustomIDAMemo.SetCurrentRendererType():
	
	        Set the current view's renderer.
	
	        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
	        

ida_idaapi.CustomIDAMemo.SetGroupsVisibility():
	
	        Send a request to expand/collapse the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param expand: True to expand the group, False otherwise.
	        @param new_current: A node to focus on after the groups have been expanded/collapsed.
	        @return: True on success, False otherwise.
	        

ida_idaapi.CustomIDAMemo.SetNodeInfo():
	
	        Set the properties for the given node.
	
	        Example usage (set second nodes's bg color to red):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff0000
	          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
	
	        @param node_index: The node index.
	        @param node_info: An idaapi.node_info_t instance.
	        @param flags: An OR'ed value of NIF_* values.
	        

ida_idaapi.CustomIDAMemo.SetNodesInfos():
	
	        Set the properties for the given nodes.
	
	        Example usage (set first three nodes's bg color to purple):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff00ff
	          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
	
	        @param values: A dictionary of 'int -> node_info_t' objects.
	        

ida_idaapi.CustomIDAMemo.hook():
	
	        hook(self) -> bool
	        

ida_idaapi.CustomIDAMemo.unhook():
	
	        unhook(self) -> bool
	        

ida_idaapi.CustomIDAMemo.view_created():
	
	        view_created(self, view)
	        

ida_idaapi.IDAPython_Completion():
	
	    Internal utility class for auto-completion support
	    

ida_idaapi.IDAPython_ExecScript():
	
	    Run the specified script.
	    It also addresses http://code.google.com/p/idapython/issues/detail?id=42
	
	    This function is used by the low-level plugin code.
	    

ida_idaapi.IDAPython_ExecSystem():
	
	    Executes a command with popen().
	    

ida_idaapi.IDAPython_FormatExc():
	
	    This function is used to format an exception given the
	    values returned by a PyErr_Fetch()
	    

ida_idaapi.IDAPython_LoadProcMod():
	
	    Load processor module.
	    

ida_idaapi.IDAPython_UnLoadProcMod():
	
	    Unload processor module.
	    

class ida_idaapi.PyIdc_cvt_int64__():
	
	    Helper class for explicitly representing VT_INT64 values
	    

class ida_idaapi.PyIdc_cvt_refclass__():
	
	    Helper class for representing references to immutable objects
	    

ida_idaapi.PyIdc_cvt_refclass__.cstr():
	
	        Returns the string as a C string (up to the zero termination)
	        

ida_idaapi.as_cstr():
	
	    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
	    It scans for the first   and returns the string value up to that point.
	    

ida_idaapi.as_int32():
	
	    Returns a number as a signed int32 number
	    

ida_idaapi.as_signed():
	
	    Returns a number as signed. The number of bits are specified by the user.
	    The MSB holds the sign.
	    

ida_idaapi.as_uint32():
	
	    Returns a number as an unsigned int32 number
	    

ida_idaapi.as_unicode():
	
	    Convenience function to convert a string into appropriate unicode format
	    

ida_idaapi.copy_bits():
	
	    Copy bits from a value
	    @param v: the value
	    @param s: starting bit (0-based)
	    @param e: ending bit
	    

ida_idaapi.disable_script_timeout():
	
	  disable_script_timeout()
	
	
	  Disables the script timeout and hides the script wait box.
	  Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
	  
	  @return: None
	  

ida_idaapi.enable_extlang_python():
	
	  enable_extlang_python(enable)
	
	
	  Enables or disables Python extlang.
	  When enabled, all expressions will be evaluated by Python.
	  @param enable: Set to True to enable, False otherwise
	  

ida_idaapi.enable_python_cli():
	
	  enable_python_cli(enable)
	  

ida_idaapi.get_inf_structure():
	
	  get_inf_structure() -> idainfo
	
	
	  Returns the global variable 'inf' (an instance of idainfo structure, see ida.hpp)
	  

class ida_idaapi.loader_input_t():
	
	    Proxy of C++ loader_input_t class
	
	
	    A helper class to work with linput_t related functions.
	    This class is also used by file loaders scripts.
	    

ida_idaapi.loader_input_t.close():
	
	        close(self)
	        

ida_idaapi.loader_input_t.file2base():
	
	        file2base(self, pos, ea1, ea2, patchable) -> int
	
	
	        Load portion of file into the database
	        This function will include (ea1..ea2) into the addressing space of the
	        program (make it enabled)
	        @param li: pointer ot input source
	        @param pos: position in the file
	        @param (ea1..ea2): range of destination linear addresses
	        @param patchable: should the kernel remember correspondance of
	                          file offsets to linear addresses.
	        @return: 1-ok,0-read error, a warning is displayed
	        

ida_idaapi.loader_input_t.filename():
	
	        filename(self) -> PyObject *
	        

ida_idaapi.loader_input_t.from_cobject():
	
	        from_cobject(pycobject) -> loader_input_t
	        

ida_idaapi.loader_input_t.from_fp():
	
	        from_fp(fp) -> loader_input_t
	
	
	        A static method to construct an instance from a FILE*
	        

ida_idaapi.loader_input_t.from_linput():
	
	        from_linput(linput) -> loader_input_t
	        

ida_idaapi.loader_input_t.get_char():
	
	        get_char(self) -> PyObject *
	
	
	        Reads a single character from the file. Returns None if EOF or the read character
	        

ida_idaapi.loader_input_t.get_linput():
	
	        get_linput(self) -> linput_t *
	        

ida_idaapi.loader_input_t.gets():
	
	        gets(self, len) -> PyObject *
	
	
	        Reads a line from the input file. Returns the read line or None
	        

ida_idaapi.loader_input_t.getz():
	
	        getz(self, sz, fpos=-1) -> PyObject *
	
	
	        Returns a zero terminated string at the given position
	        @param sz: maximum size of the string
	        @param fpos: if != -1 then seek will be performed before reading
	        @return: The string or None on failure.
	        

ida_idaapi.loader_input_t.open():
	
	        open(self, filename, remote=False) -> bool
	
	
	        Opens a file (or a remote file)
	        @return: Boolean
	        

ida_idaapi.loader_input_t.open_memory():
	
	        open_memory(self, start, size=0) -> bool
	
	
	        Create a linput for process memory (By internally calling idaapi.create_memory_linput())
	        This linput will use dbg->read_memory() to read data
	        @param start: starting address of the input
	        @param size: size of the memory range to represent as linput
	                    if unknown, may be passed as 0
	        

ida_idaapi.loader_input_t.opened():
	
	        opened(self) -> bool
	
	
	        Checks if the file is opened or not
	        

ida_idaapi.loader_input_t.read():
	
	        read(self, size) -> PyObject *
	
	
	        Reads from the file. Returns the buffer or None
	        

ida_idaapi.loader_input_t.readbytes():
	
	        readbytes(self, size, big_endian) -> PyObject *
	
	
	        Similar to read() but it respect the endianness
	        

ida_idaapi.loader_input_t.seek():
	
	        seek(self, pos, whence=SEEK_SET) -> int64
	
	
	        Set input source position
	        @return: the new position (not 0 as fseek!)
	        

ida_idaapi.loader_input_t.set_linput():
	
	        set_linput(self, linput)
	
	
	        Links the current loader_input_t instance to a linput_t instance
	        

ida_idaapi.loader_input_t.size():
	
	        size(self) -> int64
	        

ida_idaapi.loader_input_t.tell():
	
	        tell(self) -> int64
	
	
	        Returns the current position
	        

ida_idaapi.loader_input_t_from_cobject():
	
	  loader_input_t_from_cobject(pycobject) -> loader_input_t
	  

ida_idaapi.loader_input_t_from_fp():
	
	  loader_input_t_from_fp(fp) -> loader_input_t
	  

ida_idaapi.loader_input_t_from_linput():
	
	  loader_input_t_from_linput(linput) -> loader_input_t
	  

ida_idaapi.notify_when():
	
	  notify_when(when, py_callable) -> bool
	
	
	  Register a callback that will be called when an event happens.
	  @param when: one of NW_XXXX constants
	  @param callback: This callback prototype varies depending on the 'when' parameter:
	                   The general callback format:
	                       def notify_when_callback(nw_code)
	                   In the case of NW_OPENIDB:
	                       def notify_when_callback(nw_code, is_old_database)
	  @return: Boolean
	  

class ida_idaapi.object_t():
	
	    Helper class used to initialize empty objects
	    

ida_idaapi.parse_command_line3():
	
	  parse_command_line3(cmdline) -> PyObject *
	  

class ida_idaapi.plugin_t():
	
	    Base class for all scripted plugins.
	    

class ida_idaapi.py_clinked_object_t():
	
	    This is a utility and base class for C linked objects
	    

ida_idaapi.py_clinked_object_t._free():
	
	        Explicitly delete the link (only if not static)
	        

ida_idaapi.py_clinked_object_t.assign():
	
	        Overwrite me.
	        This method allows you to assign an instance contents to anothers
	        @return: Boolean
	        

ida_idaapi.py_clinked_object_t.copy():
	
	        Returns a new copy of this class
	        

ida_idaapi.pycim_get_tcustom_control():
	
	  pycim_get_widget(self) -> TWidget *
	  

ida_idaapi.pycim_get_tform():
	
	  pycim_get_widget(self) -> TWidget *
	  

ida_idaapi.pycim_get_widget():
	
	  pycim_get_widget(self) -> TWidget *
	  

ida_idaapi.pycim_view_close():
	
	  pycim_view_close(self)
	  

ida_idaapi.pygc_create_groups():
	
	  pygc_create_groups(self, groups_infos) -> PyObject *
	  

ida_idaapi.pygc_del_nodes_infos():
	
	  pygc_del_nodes_infos(self, py_nodes)
	  

ida_idaapi.pygc_delete_groups():
	
	  pygc_delete_groups(self, groups, new_current) -> PyObject *
	  

ida_idaapi.pygc_get_current_renderer_type():
	
	  pygc_get_current_renderer_type(self) -> PyObject *
	  

ida_idaapi.pygc_get_node_info():
	
	  pygc_get_node_info(self, py_node_idx) -> PyObject *
	  

ida_idaapi.pygc_refresh():
	
	  pygc_refresh(self)
	  

ida_idaapi.pygc_set_current_renderer_type():
	
	  pygc_set_current_renderer_type(self, py_rt)
	  

ida_idaapi.pygc_set_groups_visibility():
	
	  pygc_set_groups_visibility(self, groups, expand, new_current) -> PyObject *
	  

ida_idaapi.pygc_set_node_info():
	
	  pygc_set_node_info(self, py_node_idx, py_node_info, py_flags)
	  

ida_idaapi.pygc_set_nodes_infos():
	
	  pygc_set_nodes_infos(self, values)
	  

class ida_idaapi.pyidc_cvt_helper__():
	
	    This is a special helper object that helps detect which kind
	    of object is this python object wrapping and how to convert it
	    back and from IDC.
	    This object is characterized by its special attribute and its value
	    

class ida_idaapi.pyidc_opaque_object_t():
	
	    This is the base class for all Python<->IDC opaque objects
	    

ida_idaapi.require():
	
	    Load, or reload a module.
	
	    When under heavy development, a user's tool might consist of multiple
	    modules. If those are imported using the standard 'import' mechanism,
	    there is no guarantee that the Python implementation will re-read
	    and re-evaluate the module's Python code. In fact, it usually doesn't.
	    What should be done instead is 'reload()'-ing that module.
	
	    This is a simple helper function that will do just that: In case the
	    module doesn't exist, it 'import's it, and if it does exist,
	    'reload()'s it.
	
	    The importing module (i.e., the module calling require()) will have
	    the loaded module bound to its globals(), under the name 'modulename'.
	    (If require() is called from the command line, the importing module
	    will be '__main__'.)
	
	    For more information, see: <http://www.hexblog.com/?p=749>.
	    

ida_idaapi.set_script_timeout():
	
	  set_script_timeout(timeout) -> int
	
	
	  Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
	  See also L{disable_script_timeout}.
	  
	  @param timeout: This value is in seconds.
	                  If this value is set to zero then the script will never timeout.
	  @return: Returns the old timeout value
	  

ida_idaapi.struct_unpack():
	
	    Unpack a buffer given its length and offset using struct.unpack_from().
	    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
	    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.
	    

ida_idc.get_mark_comment():
	
	  get_mark_comment(slot) -> PyObject *
	  

ida_idc.get_marked_pos():
	
	  get_marked_pos(slot) -> ea_t
	  

ida_idc.mark_position():
	
	  mark_position(ea, lnnum, x, y, slot, comment)
	  

ida_idd.Appcall__.array():
	
	        Defines an array type. Later you need to pack() / unpack()
	        

ida_idd.Appcall__.buffer():
	
	        Creates a string buffer. The returned value (r) will be a byref object.
	        Use r.value to get the contents and r.size to get the buffer's size
	        

ida_idd.Appcall__.byref():
	
	        Method to create references to immutable objects
	        Currently we support references to int/strings
	        Objects need not be passed by reference (this will be done automatically)
	        

ida_idd.Appcall__.cleanup_appcall():
	
	        Equivalent to IDC's CleanupAppcall()
	        

ida_idd.Appcall__.get_appcall_options():
	
	        Return the global Appcall options
	        

ida_idd.Appcall__.int64():
	
	        Whenever a 64bit number is needed use this method to construct an object
	        

ida_idd.Appcall__.obj():
	
	        Returns an empty object or objects with attributes as passed via its keywords arguments
	        

ida_idd.Appcall__.proto():
	
	        Allows you to instantiate an appcall (callable object) with the desired prototype
	        @param name_or_ea: The name of the function (will be resolved with LocByName())
	        @param prototype:
	        @return:
	            - On failure it raises an exception if the prototype could not be parsed
	              or the address is not resolvable
	            - Returns a callbable Appcall instance with the given prototypes and flags
	        

ida_idd.Appcall__.set_appcall_options():
	
	        Method to change the Appcall options globally (not per Appcall)
	        

ida_idd.Appcall__.typedobj():
	
	        Parses a type string and returns an appcall object.
	        One can then use retrieve() member method
	        @param ea: Optional parameter that later can be used to retrieve the type
	        @return: Appcall object or raises ValueError exception
	        

ida_idd.Appcall__.valueof():
	
	        Returns the numeric value of a given name string.
	        If the name could not be resolved then the default value will be returned
	        

class ida_idd.Appcall_array__():
	
	    This class is used with Appcall.array() method
	    

ida_idd.Appcall_array__.pack():
	
	        Packs a list or tuple into a byref buffer
	        

ida_idd.Appcall_array__.try_to_convert_to_list():
	
	        Is this object a list? We check for the existance of attribute zero and attribute self.size-1
	        

ida_idd.Appcall_array__.unpack():
	
	        Unpacks an array back into a list or an object
	        

class ida_idd.Appcall_callable__():
	
	    Helper class to issue appcalls using a natural syntax:
	      appcall.FunctionNameInTheDatabase(arguments, ....)
	    or
	      appcall["Function@8"](arguments, ...)
	    or
	      f8 = appcall["Function@8"]
	      f8(arg1, arg2, ...)
	    or
	      o = appcall.obj()
	      i = byref(5)
	      appcall.funcname(arg1, i, "hello", o)
	    

ida_idd.Appcall_callable__.retrieve():
	
	        Unpacks a typed object from the database if an ea is given or from a string if a string was passed
	        @param src: the address of the object or a string
	        @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
	        

ida_idd.Appcall_callable__.store():
	
	        Packs an object into a given ea if provided or into a string if no address was passed.
	        @param obj: The object to pack
	        @param dest_ea: If packing to idb this will be the store location
	        @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
	
	        @return:
	            - If packing to a string then a Tuple(Boolean, packed_string or error code)
	            - If packing to the database then a return code is returned (0 is success)
	        

class ida_idd.Appcall_consts__():
	
	    Helper class used by Appcall.Consts attribute
	    It is used to retrieve constants via attribute access
	

ida_idd.appcall():
	
	  appcall(func_ea, tid, py_type, py_fields, arg_list) -> PyObject *
	  

class ida_idd.bptaddr_t():
	
	    Proxy of C++ bptaddr_t class
	    

ida_idd.bptaddr_t.hea:
	bptaddr_t_hea_get(self) -> ea_t

ida_idd.bptaddr_t.kea:
	bptaddr_t_kea_get(self) -> ea_t

class ida_idd.call_stack_info_t():
	
	    Proxy of C++ call_stack_info_t class
	    

ida_idd.call_stack_info_t.callea:
	call_stack_info_t_callea_get(self) -> ea_t

ida_idd.call_stack_info_t.fp:
	call_stack_info_t_fp_get(self) -> ea_t

ida_idd.call_stack_info_t.funcea:
	call_stack_info_t_funcea_get(self) -> ea_t

ida_idd.call_stack_info_t.funcok:
	call_stack_info_t_funcok_get(self) -> bool

class ida_idd.call_stack_t():
	
	    Proxy of C++ qvector<(call_stack_info_t)> class
	    

ida_idd.call_stack_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_idd.call_stack_t.at():
	
	        at(self, _idx) -> call_stack_info_t
	        

ida_idd.call_stack_t.begin():
	
	        begin(self) -> call_stack_info_t
	        begin(self) -> call_stack_info_t
	        

ida_idd.call_stack_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_idd.call_stack_t.clear():
	
	        clear(self)
	        

ida_idd.call_stack_t.empty():
	
	        empty(self) -> bool
	        

ida_idd.call_stack_t.end():
	
	        end(self) -> call_stack_info_t
	        end(self) -> call_stack_info_t
	        

ida_idd.call_stack_t.erase():
	
	        erase(self, it) -> call_stack_info_t
	        erase(self, first, last) -> call_stack_info_t
	        

ida_idd.call_stack_t.extract():
	
	        extract(self) -> call_stack_info_t
	        

ida_idd.call_stack_t.find():
	
	        find(self, x) -> call_stack_info_t
	        find(self, x) -> call_stack_info_t
	        

ida_idd.call_stack_t.grow():
	
	        grow(self, x=call_stack_info_t())
	        

ida_idd.call_stack_t.has():
	
	        has(self, x) -> bool
	        

ida_idd.call_stack_t.inject():
	
	        inject(self, s, len)
	        

ida_idd.call_stack_t.insert():
	
	        insert(self, it, x) -> call_stack_info_t
	        

ida_idd.call_stack_t.pop_back():
	
	        pop_back(self)
	        

ida_idd.call_stack_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> call_stack_info_t
	        

ida_idd.call_stack_t.qclear():
	
	        qclear(self)
	        

ida_idd.call_stack_t.reserve():
	
	        reserve(self, cnt)
	        

ida_idd.call_stack_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_idd.call_stack_t.size():
	
	        size(self) -> size_t
	        

ida_idd.call_stack_t.swap():
	
	        swap(self, r)
	        

ida_idd.call_stack_t.truncate():
	
	        truncate(self)
	        

ida_idd.can_exc_continue():
	
	  can_exc_continue(ev) -> bool
	  

ida_idd.cleanup_appcall():
	
	  cleanup_appcall(tid) -> error_t
	
	
	  Cleanup after manual appcall.
	  
	  @param tid: thread to use.  NO_THREAD  means to use the current thread
	              The application state is restored as it was before calling
	              the last appcall(). Nested appcalls are supported. (C++:
	              thid_t)
	  @return: eOk  if successful, otherwise an error code
	  

ida_idd.dbg_appcall():
	
	  dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t
	
	
	  Call a function from the debugged application.
	  
	  @param retval (C++: idc_value_t  *)
	  @param func_ea: address to call (C++: ea_t)
	  @param tid: thread to use.  NO_THREAD  means to use the current thread
	              (C++: thid_t)
	  @param ptif: pointer to type of the function to call (C++: const
	               tinfo_t  *)
	  @param argv: array of arguments (C++: idc_value_t  *)
	  @param argnum: number of actual arguments (C++: size_t)
	  @return: eOk  if successful, otherwise an error code
	  

ida_idd.dbg_can_query():
	dbg_can_query() -> bool

ida_idd.dbg_get_memory_info():
	
	  dbg_get_memory_info() -> PyObject *
	
	
	  This function returns the memory configuration of a debugged process.
	  @return:
	      None if no debugger is active
	      tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)
	  

ida_idd.dbg_get_name():
	
	  dbg_get_name() -> PyObject *
	
	
	  This function returns the current debugger's name.
	  @return: Debugger name or None if no debugger is active
	  

ida_idd.dbg_get_registers():
	
	  dbg_get_registers() -> PyObject *
	
	
	  This function returns the register definition from the currently loaded debugger.
	  Basically, it returns an array of structure similar to to idd.hpp / register_info_t
	  @return:
	      None if no debugger is loaded
	      tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
	      The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)
	  

ida_idd.dbg_get_thread_sreg_base():
	
	  dbg_get_thread_sreg_base(py_tid, py_sreg_value) -> PyObject *
	
	
	  Returns the segment register base value
	  @param tid: thread id
	  @param sreg_value: segment register (selector) value
	  @return:
	      - The base as an 'ea'
	      - Or None on failure
	  

ida_idd.dbg_read_memory():
	
	  dbg_read_memory(py_ea, py_sz) -> PyObject *
	
	
	  Reads from the debugee's memory at the specified ea
	  @return:
	      - The read buffer (as a string)
	      - Or None on failure
	  

ida_idd.dbg_write_memory():
	
	  dbg_write_memory(py_ea, py_buf) -> PyObject *
	
	
	  Writes a buffer to the debugee's memory
	  @return: Boolean
	  

class ida_idd.debapp_attrs_t():
	
	    Proxy of C++ debapp_attrs_t class
	    

ida_idd.debapp_attrs_t.addrsize:
	debapp_attrs_t_addrsize_get(self) -> int

ida_idd.debapp_attrs_t.cbsize:
	debapp_attrs_t_cbsize_get(self) -> int32

ida_idd.debapp_attrs_t.is_be:
	debapp_attrs_t_is_be_get(self) -> int

ida_idd.debapp_attrs_t.platform:
	debapp_attrs_t_platform_get(self) -> qstring *

class ida_idd.debug_event_t():
	
	    Proxy of C++ debug_event_t class
	    

ida_idd.debug_event_t.bpt():
	
	        bpt(self) -> bptaddr_t
	        bpt(self) -> bptaddr_t
	        

ida_idd.debug_event_t.bpt_ea():
	
	        bpt_ea(self) -> ea_t
	        

ida_idd.debug_event_t.clear():
	
	        clear(self)
	        

ida_idd.debug_event_t.clear_all():
	
	        clear_all(self)
	        

ida_idd.debug_event_t.copy():
	
	        copy(self, r) -> debug_event_t
	        

ida_idd.debug_event_t.ea:
	debug_event_t_ea_get(self) -> ea_t

ida_idd.debug_event_t.eid():
	
	        eid(self) -> event_id_t
	        

ida_idd.debug_event_t.exc():
	
	        exc(self) -> excinfo_t
	        exc(self) -> excinfo_t
	        

ida_idd.debug_event_t.exit_code():
	
	        exit_code(self) -> int const &
	        

ida_idd.debug_event_t.handled:
	debug_event_t_handled_get(self) -> bool

ida_idd.debug_event_t.info():
	
	        info(self) -> qstring
	        info(self) -> qstring const &
	        

ida_idd.debug_event_t.modinfo():
	
	        modinfo(self) -> modinfo_t
	        modinfo(self) -> modinfo_t
	        

ida_idd.debug_event_t.pid:
	debug_event_t_pid_get(self) -> pid_t

ida_idd.debug_event_t.set_bpt():
	
	        set_bpt(self) -> bptaddr_t
	        

ida_idd.debug_event_t.set_eid():
	
	        set_eid(self, id)
	        

ida_idd.debug_event_t.set_exception():
	
	        set_exception(self) -> excinfo_t
	        

ida_idd.debug_event_t.set_exit_code():
	
	        set_exit_code(self, id, code)
	        

ida_idd.debug_event_t.set_info():
	
	        set_info(self, id) -> qstring &
	        

ida_idd.debug_event_t.set_modinfo():
	
	        set_modinfo(self, id) -> modinfo_t
	        

ida_idd.debug_event_t.tid:
	debug_event_t_tid_get(self) -> thid_t

class ida_idd.exception_info_t():
	
	    Proxy of C++ exception_info_t class
	    

ida_idd.exception_info_t.break_on():
	
	        break_on(self) -> bool
	        

ida_idd.exception_info_t.code:
	exception_info_t_code_get(self) -> uint

ida_idd.exception_info_t.desc:
	exception_info_t_desc_get(self) -> qstring *

ida_idd.exception_info_t.flags:
	exception_info_t_flags_get(self) -> uint32

ida_idd.exception_info_t.handle():
	
	        handle(self) -> bool
	        

ida_idd.exception_info_t.name:
	exception_info_t_name_get(self) -> qstring *

class ida_idd.excinfo_t():
	
	    Proxy of C++ excinfo_t class
	    

ida_idd.excinfo_t.can_cont:
	excinfo_t_can_cont_get(self) -> bool

ida_idd.excinfo_t.code:
	excinfo_t_code_get(self) -> uint32

ida_idd.excinfo_t.ea:
	excinfo_t_ea_get(self) -> ea_t

ida_idd.excinfo_t.info:
	excinfo_t_info_get(self) -> qstring *

class ida_idd.excvec_t():
	
	    Proxy of C++ qvector<(exception_info_t)> class
	    

ida_idd.excvec_t.at():
	
	        at(self, _idx) -> exception_info_t
	        

ida_idd.excvec_t.begin():
	
	        begin(self) -> exception_info_t
	        begin(self) -> exception_info_t
	        

ida_idd.excvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_idd.excvec_t.clear():
	
	        clear(self)
	        

ida_idd.excvec_t.empty():
	
	        empty(self) -> bool
	        

ida_idd.excvec_t.end():
	
	        end(self) -> exception_info_t
	        end(self) -> exception_info_t
	        

ida_idd.excvec_t.erase():
	
	        erase(self, it) -> exception_info_t
	        erase(self, first, last) -> exception_info_t
	        

ida_idd.excvec_t.extract():
	
	        extract(self) -> exception_info_t
	        

ida_idd.excvec_t.grow():
	
	        grow(self, x=exception_info_t())
	        

ida_idd.excvec_t.inject():
	
	        inject(self, s, len)
	        

ida_idd.excvec_t.insert():
	
	        insert(self, it, x) -> exception_info_t
	        

ida_idd.excvec_t.pop_back():
	
	        pop_back(self)
	        

ida_idd.excvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> exception_info_t
	        

ida_idd.excvec_t.qclear():
	
	        qclear(self)
	        

ida_idd.excvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_idd.excvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_idd.excvec_t.size():
	
	        size(self) -> size_t
	        

ida_idd.excvec_t.swap():
	
	        swap(self, r)
	        

ida_idd.excvec_t.truncate():
	
	        truncate(self)
	        

ida_idd.get_event_bpt_hea():
	
	  get_event_bpt_hea(ev) -> ea_t
	  

ida_idd.get_event_exc_code():
	
	  get_event_exc_code(ev) -> uint
	  

ida_idd.get_event_exc_ea():
	
	  get_event_exc_ea(ev) -> ea_t
	  

ida_idd.get_event_exc_info():
	
	  get_event_exc_info(ev) -> char
	  

ida_idd.get_event_info():
	
	  get_event_info(ev) -> char
	  

ida_idd.get_event_module_base():
	
	  get_event_module_base(ev) -> ea_t
	  

ida_idd.get_event_module_name():
	
	  get_event_module_name(ev) -> char
	  

ida_idd.get_event_module_size():
	
	  get_event_module_size(ev) -> asize_t
	  

class ida_idd.meminfo_vec_t():
	
	    Proxy of C++ qvector<(memory_info_t)> class
	    

ida_idd.meminfo_vec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_idd.meminfo_vec_t.at():
	
	        at(self, _idx) -> memory_info_t
	        

ida_idd.meminfo_vec_t.begin():
	
	        begin(self) -> memory_info_t
	        begin(self) -> memory_info_t
	        

ida_idd.meminfo_vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_idd.meminfo_vec_t.clear():
	
	        clear(self)
	        

ida_idd.meminfo_vec_t.empty():
	
	        empty(self) -> bool
	        

ida_idd.meminfo_vec_t.end():
	
	        end(self) -> memory_info_t
	        end(self) -> memory_info_t
	        

ida_idd.meminfo_vec_t.erase():
	
	        erase(self, it) -> memory_info_t
	        erase(self, first, last) -> memory_info_t
	        

ida_idd.meminfo_vec_t.extract():
	
	        extract(self) -> memory_info_t
	        

ida_idd.meminfo_vec_t.find():
	
	        find(self, x) -> memory_info_t
	        find(self, x) -> memory_info_t
	        

ida_idd.meminfo_vec_t.grow():
	
	        grow(self, x=memory_info_t())
	        

ida_idd.meminfo_vec_t.has():
	
	        has(self, x) -> bool
	        

ida_idd.meminfo_vec_t.inject():
	
	        inject(self, s, len)
	        

ida_idd.meminfo_vec_t.insert():
	
	        insert(self, it, x) -> memory_info_t
	        

ida_idd.meminfo_vec_t.pop_back():
	
	        pop_back(self)
	        

ida_idd.meminfo_vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> memory_info_t
	        

ida_idd.meminfo_vec_t.qclear():
	
	        qclear(self)
	        

ida_idd.meminfo_vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_idd.meminfo_vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_idd.meminfo_vec_t.size():
	
	        size(self) -> size_t
	        

ida_idd.meminfo_vec_t.swap():
	
	        swap(self, r)
	        

ida_idd.meminfo_vec_t.truncate():
	
	        truncate(self)
	        

class ida_idd.memory_info_t():
	
	    Proxy of C++ memory_info_t class
	    

ida_idd.memory_info_t._print():
	
	        _print(self) -> size_t
	        

ida_idd.memory_info_t.bitness:
	memory_info_t_bitness_get(self) -> uchar

ida_idd.memory_info_t.clear():
	
	        clear(self)
	        

ida_idd.memory_info_t.compare():
	
	        compare(self, r) -> int
	        

ida_idd.memory_info_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_idd.memory_info_t.empty():
	
	        empty(self) -> bool
	        

ida_idd.memory_info_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_idd.memory_info_t.extend():
	
	        extend(self, ea)
	        

ida_idd.memory_info_t.intersect():
	
	        intersect(self, r)
	        

ida_idd.memory_info_t.name:
	memory_info_t_name_get(self) -> qstring *

ida_idd.memory_info_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_idd.memory_info_t.perm:
	memory_info_t_perm_get(self) -> uchar

ida_idd.memory_info_t.sbase:
	memory_info_t_sbase_get(self) -> ea_t

ida_idd.memory_info_t.sclass:
	memory_info_t_sclass_get(self) -> qstring *

ida_idd.memory_info_t.size():
	
	        size(self) -> asize_t
	        

ida_idd.memory_info_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

class ida_idd.modinfo_t():
	
	    Proxy of C++ modinfo_t class
	    

ida_idd.modinfo_t.base:
	modinfo_t_base_get(self) -> ea_t

ida_idd.modinfo_t.name:
	modinfo_t_name_get(self) -> qstring *

ida_idd.modinfo_t.rebase_to:
	modinfo_t_rebase_to_get(self) -> ea_t

ida_idd.modinfo_t.size:
	modinfo_t_size_get(self) -> asize_t

class ida_idd.process_info_t():
	
	    Proxy of C++ process_info_t class
	    

ida_idd.process_info_t.name:
	process_info_t_name_get(self) -> qstring *

ida_idd.process_info_t.pid:
	process_info_t_pid_get(self) -> pid_t

class ida_idd.procinfo_vec_t():
	
	    Proxy of C++ qvector<(process_info_t)> class
	    

ida_idd.procinfo_vec_t.at():
	
	        at(self, _idx) -> process_info_t
	        

ida_idd.procinfo_vec_t.begin():
	
	        begin(self) -> process_info_t
	        begin(self) -> process_info_t
	        

ida_idd.procinfo_vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_idd.procinfo_vec_t.clear():
	
	        clear(self)
	        

ida_idd.procinfo_vec_t.empty():
	
	        empty(self) -> bool
	        

ida_idd.procinfo_vec_t.end():
	
	        end(self) -> process_info_t
	        end(self) -> process_info_t
	        

ida_idd.procinfo_vec_t.erase():
	
	        erase(self, it) -> process_info_t
	        erase(self, first, last) -> process_info_t
	        

ida_idd.procinfo_vec_t.extract():
	
	        extract(self) -> process_info_t
	        

ida_idd.procinfo_vec_t.grow():
	
	        grow(self, x=process_info_t())
	        

ida_idd.procinfo_vec_t.inject():
	
	        inject(self, s, len)
	        

ida_idd.procinfo_vec_t.insert():
	
	        insert(self, it, x) -> process_info_t
	        

ida_idd.procinfo_vec_t.pop_back():
	
	        pop_back(self)
	        

ida_idd.procinfo_vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> process_info_t
	        

ida_idd.procinfo_vec_t.qclear():
	
	        qclear(self)
	        

ida_idd.procinfo_vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_idd.procinfo_vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_idd.procinfo_vec_t.size():
	
	        size(self) -> size_t
	        

ida_idd.procinfo_vec_t.swap():
	
	        swap(self, r)
	        

ida_idd.procinfo_vec_t.truncate():
	
	        truncate(self)
	        

class ida_idd.regval_t():
	
	    Proxy of C++ regval_t class
	    

ida_idd.regval_t.bytes():
	
	        bytes(self) -> bytevec_t
	        bytes(self) -> bytevec_t const &
	        

ida_idd.regval_t.clear():
	
	        clear(self)
	        

ida_idd.regval_t.fval:
	regval_t_fval_get(self) -> uint16 [6]

ida_idd.regval_t.get_data():
	
	        get_data(self)
	        get_data(self) -> void const *
	        

ida_idd.regval_t.get_data_size():
	
	        get_data_size(self) -> size_t
	        

ida_idd.regval_t.ival:
	regval_t_ival_get(self) -> uint64

ida_idd.regval_t.rvtype:
	regval_t_rvtype_get(self) -> int32

ida_idd.regval_t.set_bytes():
	
	        set_bytes(self, data, size)
	        set_bytes(self, v)
	        set_bytes(self) -> bytevec_t &
	        

ida_idd.regval_t.set_float():
	
	        set_float(self, x)
	        

ida_idd.regval_t.set_int():
	
	        set_int(self, x)
	        

ida_idd.regval_t.swap():
	
	        swap(self, r)
	        

class ida_idd.scattered_segm_t():
	
	    Proxy of C++ scattered_segm_t class
	    

ida_idd.scattered_segm_t._print():
	
	        _print(self) -> size_t
	        

ida_idd.scattered_segm_t.clear():
	
	        clear(self)
	        

ida_idd.scattered_segm_t.compare():
	
	        compare(self, r) -> int
	        

ida_idd.scattered_segm_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_idd.scattered_segm_t.empty():
	
	        empty(self) -> bool
	        

ida_idd.scattered_segm_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_idd.scattered_segm_t.extend():
	
	        extend(self, ea)
	        

ida_idd.scattered_segm_t.intersect():
	
	        intersect(self, r)
	        

ida_idd.scattered_segm_t.name:
	scattered_segm_t_name_get(self) -> qstring *

ida_idd.scattered_segm_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_idd.scattered_segm_t.size():
	
	        size(self) -> asize_t
	        

ida_idd.scattered_segm_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

ida_idd.set_debug_event_code():
	
	  set_debug_event_code(ev, id)
	  

class ida_idd.thread_name_t():
	
	    Proxy of C++ thread_name_t class
	    

ida_idd.thread_name_t.name:
	thread_name_t_name_get(self) -> qstring *

ida_idd.thread_name_t.tid:
	thread_name_t_tid_get(self) -> thid_t


=== ida_idd EPYDOC INJECTIONS ===
ida_idd.EXC_BREAK
"""
break on the exception
"""

ida_idd.EXC_HANDLE
"""
should be handled by the debugger?
"""

ida_idd.EXC_MSG
"""
instead of a warning, log the exception to the output window
"""

ida_idd.EXC_SILENT
"""
do not warn or log to the output window
"""

ida_idd.IDD_INTERFACE_VERSION
"""
The IDD interface version number.
"""

ida_idd.NO_PROCESS
"""
No process.
"""

ida_idd.NO_THREAD
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""

ida_idd.RVT_FLOAT
"""
floating point
"""

ida_idd.RVT_INT
"""
integer
"""

ida_idd.RVT_UNAVAILABLE
"""
other values mean custom data type

unavailable
"""
=== ida_idd EPYDOC INJECTIONS END ===
ida_idp.AssembleLine():
	
	  AssembleLine(ea, cs, ip, use32, nonnul_line) -> PyObject *
	
	
	  Assemble an instruction to a string (display a warning if an error is found)
	  
	  @param ea: linear address of instruction
	  @param cs:  cs of instruction
	  @param ip:  ip of instruction
	  @param use32: is 32bit segment
	  @param line: line to assemble
	  @return:
	      - None on failure
	      - or a string containing the assembled instruction
	  

class ida_idp.IDB_Hooks():
	
	    Proxy of C++ IDB_Hooks class
	    

ida_idp.IDB_Hooks.allsegs_moved():
	
	        allsegs_moved(self, info) -> int
	        

ida_idp.IDB_Hooks.auto_empty():
	
	        auto_empty(self) -> int
	        

ida_idp.IDB_Hooks.auto_empty_finally():
	
	        auto_empty_finally(self) -> int
	        

ida_idp.IDB_Hooks.bookmark_changed():
	
	        bookmark_changed(self, index, pos, desc) -> int
	        

ida_idp.IDB_Hooks.byte_patched():
	
	        byte_patched(self, ea, old_value) -> int
	        

ida_idp.IDB_Hooks.callee_addr_changed():
	
	        callee_addr_changed(self, ea, callee) -> int
	        

ida_idp.IDB_Hooks.changing_cmt():
	
	        changing_cmt(self, ea, repeatable_cmt, newcmt) -> int
	        

ida_idp.IDB_Hooks.changing_enum_bf():
	
	        changing_enum_bf(self, id, new_bf) -> int
	        

ida_idp.IDB_Hooks.changing_enum_cmt():
	
	        changing_enum_cmt(self, id, repeatable, newcmt) -> int
	        

ida_idp.IDB_Hooks.changing_op_ti():
	
	        changing_op_ti(self, ea, n, new_type, new_fnames) -> int
	        

ida_idp.IDB_Hooks.changing_op_type():
	
	        changing_op_type(self, ea, n, opinfo) -> int
	        

ida_idp.IDB_Hooks.changing_range_cmt():
	
	        changing_range_cmt(self, kind, a, cmt, repeatable) -> int
	        

ida_idp.IDB_Hooks.changing_segm_class():
	
	        changing_segm_class(self, s) -> int
	        

ida_idp.IDB_Hooks.changing_segm_end():
	
	        changing_segm_end(self, s, new_end, segmod_flags) -> int
	        

ida_idp.IDB_Hooks.changing_segm_name():
	
	        changing_segm_name(self, s, oldname) -> int
	        

ida_idp.IDB_Hooks.changing_segm_start():
	
	        changing_segm_start(self, s, new_start, segmod_flags) -> int
	        

ida_idp.IDB_Hooks.changing_struc_align():
	
	        changing_struc_align(self, sptr) -> int
	        

ida_idp.IDB_Hooks.changing_struc_cmt():
	
	        changing_struc_cmt(self, struc_id, repeatable, newcmt) -> int
	        

ida_idp.IDB_Hooks.changing_struc_member():
	
	        changing_struc_member(self, sptr, mptr, flag, ti, nbytes) -> int
	        

ida_idp.IDB_Hooks.changing_ti():
	
	        changing_ti(self, ea, new_type, new_fnames) -> int
	        

ida_idp.IDB_Hooks.closebase():
	
	        closebase(self) -> int
	        

ida_idp.IDB_Hooks.cmt_changed():
	
	        cmt_changed(self, ea, repeatable_cmt) -> int
	        

ida_idp.IDB_Hooks.compiler_changed():
	
	        compiler_changed(self) -> int
	        

ida_idp.IDB_Hooks.deleting_enum():
	
	        deleting_enum(self, id) -> int
	        

ida_idp.IDB_Hooks.deleting_enum_member():
	
	        deleting_enum_member(self, id, cid) -> int
	        

ida_idp.IDB_Hooks.deleting_func():
	
	        deleting_func(self, pfn) -> int
	        

ida_idp.IDB_Hooks.deleting_func_tail():
	
	        deleting_func_tail(self, pfn, tail) -> int
	        

ida_idp.IDB_Hooks.deleting_segm():
	
	        deleting_segm(self, start_ea) -> int
	        

ida_idp.IDB_Hooks.deleting_struc():
	
	        deleting_struc(self, sptr) -> int
	        

ida_idp.IDB_Hooks.deleting_struc_member():
	
	        deleting_struc_member(self, sptr, mptr) -> int
	        

ida_idp.IDB_Hooks.deleting_tryblks():
	
	        deleting_tryblks(self, range) -> int
	        

ida_idp.IDB_Hooks.destroyed_items():
	
	        destroyed_items(self, ea1, ea2, will_disable_range) -> int
	        

ida_idp.IDB_Hooks.determined_main():
	
	        determined_main(self, main) -> int
	        

ida_idp.IDB_Hooks.enum_bf_changed():
	
	        enum_bf_changed(self, id) -> int
	        

ida_idp.IDB_Hooks.enum_cmt_changed():
	
	        enum_cmt_changed(self, id, repeatable) -> int
	        

ida_idp.IDB_Hooks.enum_created():
	
	        enum_created(self, id) -> int
	        

ida_idp.IDB_Hooks.enum_deleted():
	
	        enum_deleted(self, id) -> int
	        

ida_idp.IDB_Hooks.enum_member_created():
	
	        enum_member_created(self, id, cid) -> int
	        

ida_idp.IDB_Hooks.enum_member_deleted():
	
	        enum_member_deleted(self, id, cid) -> int
	        

ida_idp.IDB_Hooks.enum_renamed():
	
	        enum_renamed(self, id) -> int
	        

ida_idp.IDB_Hooks.expanding_struc():
	
	        expanding_struc(self, sptr, offset, delta) -> int
	        

ida_idp.IDB_Hooks.extlang_changed():
	
	        extlang_changed(self, kind, el, idx) -> int
	        

ida_idp.IDB_Hooks.extra_cmt_changed():
	
	        extra_cmt_changed(self, ea, line_idx, cmt) -> int
	        

ida_idp.IDB_Hooks.flow_chart_created():
	
	        flow_chart_created(self, fc) -> int
	        

ida_idp.IDB_Hooks.frame_deleted():
	
	        frame_deleted(self, pfn) -> int
	        

ida_idp.IDB_Hooks.func_added():
	
	        func_added(self, pfn) -> int
	        

ida_idp.IDB_Hooks.func_noret_changed():
	
	        func_noret_changed(self, pfn) -> int
	        

ida_idp.IDB_Hooks.func_tail_appended():
	
	        func_tail_appended(self, pfn, tail) -> int
	        

ida_idp.IDB_Hooks.func_tail_deleted():
	
	        func_tail_deleted(self, pfn, tail_ea) -> int
	        

ida_idp.IDB_Hooks.func_updated():
	
	        func_updated(self, pfn) -> int
	        

ida_idp.IDB_Hooks.hook():
	
	        hook(self) -> bool
	        

ida_idp.IDB_Hooks.idasgn_loaded():
	
	        idasgn_loaded(self, short_sig_name) -> int
	        

ida_idp.IDB_Hooks.item_color_changed():
	
	        item_color_changed(self, ea, color) -> int
	        

ida_idp.IDB_Hooks.kernel_config_loaded():
	
	        kernel_config_loaded(self) -> int
	        

ida_idp.IDB_Hooks.loader_finished():
	
	        loader_finished(self, li, neflags, filetypename) -> int
	        

ida_idp.IDB_Hooks.local_types_changed():
	
	        local_types_changed(self) -> int
	        

ida_idp.IDB_Hooks.make_code():
	
	        make_code(self, insn) -> int
	        

ida_idp.IDB_Hooks.make_data():
	
	        make_data(self, ea, flags, tid, len) -> int
	        

ida_idp.IDB_Hooks.op_ti_changed():
	
	        op_ti_changed(self, ea, n, type, fnames) -> int
	        

ida_idp.IDB_Hooks.op_type_changed():
	
	        op_type_changed(self, ea, n) -> int
	        

ida_idp.IDB_Hooks.range_cmt_changed():
	
	        range_cmt_changed(self, kind, a, cmt, repeatable) -> int
	        

ida_idp.IDB_Hooks.renamed():
	
	        renamed(self, ea, new_name, local_name) -> int
	        

ida_idp.IDB_Hooks.renaming_enum():
	
	        renaming_enum(self, id, is_enum, newname) -> int
	        

ida_idp.IDB_Hooks.renaming_struc():
	
	        renaming_struc(self, id, oldname, newname) -> int
	        

ida_idp.IDB_Hooks.renaming_struc_member():
	
	        renaming_struc_member(self, sptr, mptr, newname) -> int
	        

ida_idp.IDB_Hooks.savebase():
	
	        savebase(self) -> int
	        

ida_idp.IDB_Hooks.segm_added():
	
	        segm_added(self, s) -> int
	        

ida_idp.IDB_Hooks.segm_attrs_updated():
	
	        segm_attrs_updated(self, s) -> int
	        

ida_idp.IDB_Hooks.segm_class_changed():
	
	        segm_class_changed(self, s, sclass) -> int
	        

ida_idp.IDB_Hooks.segm_deleted():
	
	        segm_deleted(self, start_ea, end_ea) -> int
	        

ida_idp.IDB_Hooks.segm_end_changed():
	
	        segm_end_changed(self, s, oldend) -> int
	        

ida_idp.IDB_Hooks.segm_moved():
	
	        segm_moved(self, _from, to, size, changed_netmap) -> int
	        

ida_idp.IDB_Hooks.segm_name_changed():
	
	        segm_name_changed(self, s, name) -> int
	        

ida_idp.IDB_Hooks.segm_start_changed():
	
	        segm_start_changed(self, s, oldstart) -> int
	        

ida_idp.IDB_Hooks.set_func_end():
	
	        set_func_end(self, pfn, new_end) -> int
	        

ida_idp.IDB_Hooks.set_func_start():
	
	        set_func_start(self, pfn, new_start) -> int
	        

ida_idp.IDB_Hooks.sgr_changed():
	
	        sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag) -> int
	        

ida_idp.IDB_Hooks.sgr_deleted():
	
	        sgr_deleted(self, start_ea, end_ea, regnum) -> int
	        

ida_idp.IDB_Hooks.stkpnts_changed():
	
	        stkpnts_changed(self, pfn) -> int
	        

ida_idp.IDB_Hooks.struc_align_changed():
	
	        struc_align_changed(self, sptr) -> int
	        

ida_idp.IDB_Hooks.struc_cmt_changed():
	
	        struc_cmt_changed(self, struc_id, repeatable_cmt) -> int
	        

ida_idp.IDB_Hooks.struc_created():
	
	        struc_created(self, struc_id) -> int
	        

ida_idp.IDB_Hooks.struc_deleted():
	
	        struc_deleted(self, struc_id) -> int
	        

ida_idp.IDB_Hooks.struc_expanded():
	
	        struc_expanded(self, sptr) -> int
	        

ida_idp.IDB_Hooks.struc_member_changed():
	
	        struc_member_changed(self, sptr, mptr) -> int
	        

ida_idp.IDB_Hooks.struc_member_created():
	
	        struc_member_created(self, sptr, mptr) -> int
	        

ida_idp.IDB_Hooks.struc_member_deleted():
	
	        struc_member_deleted(self, sptr, member_id, offset) -> int
	        

ida_idp.IDB_Hooks.struc_member_renamed():
	
	        struc_member_renamed(self, sptr, mptr) -> int
	        

ida_idp.IDB_Hooks.struc_renamed():
	
	        struc_renamed(self, sptr) -> int
	        

ida_idp.IDB_Hooks.tail_owner_changed():
	
	        tail_owner_changed(self, tail, owner_func, old_owner) -> int
	        

ida_idp.IDB_Hooks.thunk_func_created():
	
	        thunk_func_created(self, pfn) -> int
	        

ida_idp.IDB_Hooks.ti_changed():
	
	        ti_changed(self, ea, type, fnames) -> int
	        

ida_idp.IDB_Hooks.tryblks_updated():
	
	        tryblks_updated(self, tbv) -> int
	        

ida_idp.IDB_Hooks.unhook():
	
	        unhook(self) -> bool
	        

ida_idp.IDB_Hooks.updating_tryblks():
	
	        updating_tryblks(self, tbv) -> int
	        

ida_idp.IDB_Hooks.upgraded():
	
	        upgraded(self, _from) -> int
	        

class ida_idp.IDP_Hooks():
	
	    Proxy of C++ IDP_Hooks class
	    

ida_idp.IDP_Hooks.ev_add_cref():
	
	        ev_add_cref(self, _from, to, type) -> int
	        

ida_idp.IDP_Hooks.ev_add_dref():
	
	        ev_add_dref(self, _from, to, type) -> int
	        

ida_idp.IDP_Hooks.ev_adjust_argloc():
	
	        ev_adjust_argloc(self, argloc, optional_type, size) -> int
	        

ida_idp.IDP_Hooks.ev_adjust_libfunc_ea():
	
	        ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
	        

ida_idp.IDP_Hooks.ev_adjust_refinfo():
	
	        ev_adjust_refinfo(self, ri, ea, n, fd) -> int
	        

ida_idp.IDP_Hooks.ev_ana_insn():
	
	        ev_ana_insn(self, out) -> bool
	
	
	        Analyzes and decodes an instruction at insn.ea
	           - insn.itype must be set >= idaapi.CUSTOM_CMD_ITYPE
	           - insn.size must be set to the instruction length
	        
	        @return: Boolean
	            - False if the instruction is not recognized
	            - True if the instruction was decoded. 'insn' should be filled in that case.
	        

ida_idp.IDP_Hooks.ev_analyze_prolog():
	
	        ev_analyze_prolog(self, ea) -> int
	        

ida_idp.IDP_Hooks.ev_arg_addrs_ready():
	
	        ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
	        

ida_idp.IDP_Hooks.ev_assemble():
	
	        ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
	
	
	        Assembles an instruction
	        
	        @param ea: linear address of instruction
	        @param cs: cs of instruction
	        @param ip: ip of instruction
	        @param use32: is 32bit segment?
	        @param line: line to assemble
	        
	        @return: - None to let the underlying processor module assemble the line
	                 - or a string containing the assembled buffer
	        

ida_idp.IDP_Hooks.ev_auto_queue_empty():
	
	        ev_auto_queue_empty(self, type)
	        

ida_idp.IDP_Hooks.ev_calc_arglocs():
	
	        ev_calc_arglocs(self, fti) -> int
	        

ida_idp.IDP_Hooks.ev_calc_cdecl_purged_bytes():
	
	        ev_calc_cdecl_purged_bytes(self, ea) -> int
	        

ida_idp.IDP_Hooks.ev_calc_next_eas():
	
	        ev_calc_next_eas(self, res, insn, over) -> int
	        

ida_idp.IDP_Hooks.ev_calc_purged_bytes():
	
	        ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
	        

ida_idp.IDP_Hooks.ev_calc_retloc():
	
	        ev_calc_retloc(self, retloc, rettype, cc) -> int
	        

ida_idp.IDP_Hooks.ev_calc_spdelta():
	
	        ev_calc_spdelta(self, spdelta, insn) -> int
	        

ida_idp.IDP_Hooks.ev_calc_step_over():
	
	        ev_calc_step_over(self, target, ip) -> int
	        

ida_idp.IDP_Hooks.ev_calc_switch_cases():
	
	        ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
	        

ida_idp.IDP_Hooks.ev_calc_varglocs():
	
	        ev_calc_varglocs(self, ftd, regs, stkargs, nfixed) -> int
	        

ida_idp.IDP_Hooks.ev_calcrel():
	
	        ev_calcrel(self) -> int
	        

ida_idp.IDP_Hooks.ev_can_have_type():
	
	        ev_can_have_type(self, op) -> int
	        

ida_idp.IDP_Hooks.ev_clean_tbit():
	
	        ev_clean_tbit(self, ea, getreg, regvalues) -> int
	        

ida_idp.IDP_Hooks.ev_cmp_operands():
	
	        ev_cmp_operands(self, op1, op2) -> int
	        

ida_idp.IDP_Hooks.ev_coagulate():
	
	        ev_coagulate(self, start_ea) -> int
	        

ida_idp.IDP_Hooks.ev_coagulate_dref():
	
	        ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
	        

ida_idp.IDP_Hooks.ev_create_flat_group():
	
	        ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
	        

ida_idp.IDP_Hooks.ev_create_func_frame():
	
	        ev_create_func_frame(self, pfn) -> int
	        

ida_idp.IDP_Hooks.ev_create_switch_xrefs():
	
	        ev_create_switch_xrefs(self, jumpea, si) -> int
	        

ida_idp.IDP_Hooks.ev_creating_segm():
	
	        ev_creating_segm(self, seg) -> int
	        

ida_idp.IDP_Hooks.ev_decorate_name():
	
	        ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_del_cref():
	
	        ev_del_cref(self, _from, to, expand) -> int
	        

ida_idp.IDP_Hooks.ev_del_dref():
	
	        ev_del_dref(self, _from, to) -> int
	        

ida_idp.IDP_Hooks.ev_delay_slot_insn():
	
	        ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_demangle_name():
	
	        ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_emu_insn():
	
	        ev_emu_insn(self, insn) -> bool
	
	
	        Emulate instruction, create cross-references, plan to analyze
	        subsequent instructions, modify flags etc. Upon entrance to this function
	        all information about the instruction is in 'insn' structure.
	        
	        @return: Boolean (whether this instruction has been emulated or not)
	        

ida_idp.IDP_Hooks.ev_endbinary():
	
	        ev_endbinary(self, ok) -> int
	        

ida_idp.IDP_Hooks.ev_equal_reglocs():
	
	        ev_equal_reglocs(self, a1, a2) -> int
	        

ida_idp.IDP_Hooks.ev_extract_address():
	
	        ev_extract_address(self, out_ea, screen_ea, string, position) -> int
	        

ida_idp.IDP_Hooks.ev_find_op_value():
	
	        ev_find_op_value(self, pinsn, opn) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_find_reg_value():
	
	        ev_find_reg_value(self, pinsn, reg) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_func_bounds():
	
	        ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea)
	        

ida_idp.IDP_Hooks.ev_gen_asm_or_lst():
	
	        ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline)
	        

ida_idp.IDP_Hooks.ev_gen_map_file():
	
	        ev_gen_map_file(self, nlines, fp) -> int
	        

ida_idp.IDP_Hooks.ev_gen_regvar_def():
	
	        ev_gen_regvar_def(self, outctx, v) -> int
	        

ida_idp.IDP_Hooks.ev_gen_src_file_lnnum():
	
	        ev_gen_src_file_lnnum(self) -> int
	        

ida_idp.IDP_Hooks.ev_gen_stkvar_def():
	
	        ev_gen_stkvar_def(self, outctx, mptr, v) -> int
	        

ida_idp.IDP_Hooks.ev_get_abi_info():
	
	        ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
	        

ida_idp.IDP_Hooks.ev_get_autocmt():
	
	        ev_get_autocmt(self, insn) -> int
	        

ida_idp.IDP_Hooks.ev_get_bg_color():
	
	        ev_get_bg_color(self, ea) -> int or None
	        

ida_idp.IDP_Hooks.ev_get_cc_regs():
	
	        ev_get_cc_regs(self, regs, cc) -> int
	        

ida_idp.IDP_Hooks.ev_get_dbr_opnum():
	
	        ev_get_dbr_opnum(self, opnum, insn) -> int
	        

ida_idp.IDP_Hooks.ev_get_default_enum_size():
	
	        ev_get_default_enum_size(self, cm) -> int
	        

ida_idp.IDP_Hooks.ev_get_frame_retsize():
	
	        ev_get_frame_retsize(self, frsize, pfn) -> int
	        

ida_idp.IDP_Hooks.ev_get_macro_insn_head():
	
	        ev_get_macro_insn_head(self, head, ip) -> int
	        

ida_idp.IDP_Hooks.ev_get_operand_string():
	
	        ev_get_operand_string(self, insn, opnum) -> int
	        

ida_idp.IDP_Hooks.ev_get_reg_info():
	
	        ev_get_reg_info(self, main_regname, bitrange, regname) -> int
	        

ida_idp.IDP_Hooks.ev_get_reg_name():
	
	        ev_get_reg_name(self, reg, width, reghi) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_get_simd_types():
	
	        ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
	        

ida_idp.IDP_Hooks.ev_get_stkarg_offset():
	
	        ev_get_stkarg_offset(self) -> int
	        

ida_idp.IDP_Hooks.ev_get_stkvar_scale_factor():
	
	        ev_get_stkvar_scale_factor(self) -> int
	        

ida_idp.IDP_Hooks.ev_getreg():
	
	        ev_getreg(self, regval, regnum) -> int
	        

ida_idp.IDP_Hooks.ev_init():
	
	        ev_init(self, idp_modname) -> int
	        

ida_idp.IDP_Hooks.ev_insn_reads_tbit():
	
	        ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
	        

ida_idp.IDP_Hooks.ev_is_align_insn():
	
	        ev_is_align_insn(self, ea) -> int
	        

ida_idp.IDP_Hooks.ev_is_alloca_probe():
	
	        ev_is_alloca_probe(self, ea) -> int
	        

ida_idp.IDP_Hooks.ev_is_basic_block_end():
	
	        ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
	        

ida_idp.IDP_Hooks.ev_is_call_insn():
	
	        ev_is_call_insn(self, insn) -> int
	
	
	        Is the instruction a "call"?
	        
	        @param insn: instruction
	        @return: 0-unknown, 1-yes, -1-no
	        

ida_idp.IDP_Hooks.ev_is_cond_insn():
	
	        ev_is_cond_insn(self, insn) -> int
	        

ida_idp.IDP_Hooks.ev_is_far_jump():
	
	        ev_is_far_jump(self, icode) -> int
	        

ida_idp.IDP_Hooks.ev_is_indirect_jump():
	
	        ev_is_indirect_jump(self, insn) -> int
	        

ida_idp.IDP_Hooks.ev_is_insn_table_jump():
	
	        ev_is_insn_table_jump(self, insn) -> int
	        

ida_idp.IDP_Hooks.ev_is_jump_func():
	
	        ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
	        

ida_idp.IDP_Hooks.ev_is_ret_insn():
	
	        ev_is_ret_insn(self, insn, strict) -> int
	
	
	        Is the instruction a "return"?
	        
	        @param insn: instruction
	        @param strict: - True: report only ret instructions
	                         False: include instructions like "leave" which begins the function epilog
	        @return: 0-unknown, 1-yes, -1-no
	        

ida_idp.IDP_Hooks.ev_is_sane_insn():
	
	        ev_is_sane_insn(self, insn, no_crefs) -> int
	
	
	        is the instruction sane for the current file type?
	        @param insn: the instruction
	        @param no_crefs:
	              - 1: the instruction has no code refs to it.
	                   ida just tries to convert unexplored bytes
	                   to an instruction (but there is no other
	                   reason to convert them into an instruction)
	              - 0: the instruction is created because
	                   of some coderef, user request or another
	                   weighty reason.
	        @return: >=0-ok, <0-no, the instruction isn't likely to appear in the program
	        

ida_idp.IDP_Hooks.ev_is_sp_based():
	
	        ev_is_sp_based(self, mode, insn, op) -> int
	        

ida_idp.IDP_Hooks.ev_is_switch():
	
	        ev_is_switch(self, si, insn) -> int
	        

ida_idp.IDP_Hooks.ev_loader():
	
	        ev_loader(self) -> int
	        

ida_idp.IDP_Hooks.ev_lower_func_type():
	
	        ev_lower_func_type(self, argnums, fti) -> int
	        

ida_idp.IDP_Hooks.ev_max_ptr_size():
	
	        ev_max_ptr_size(self) -> int
	        

ida_idp.IDP_Hooks.ev_may_be_func():
	
	        ev_may_be_func(self, insn, state) -> int
	
	
	        Can a function start here?
	        @param insn: the instruction
	        @param state: autoanalysis phase
	              0: creating functions
	              1: creating chunks
	        
	        @return: integer (probability 0..100)
	        

ida_idp.IDP_Hooks.ev_may_show_sreg():
	
	        ev_may_show_sreg(self, current_ea) -> int
	        

ida_idp.IDP_Hooks.ev_moving_segm():
	
	        ev_moving_segm(self, seg, to, flags) -> int
	        

ida_idp.IDP_Hooks.ev_newasm():
	
	        ev_newasm(self, asmnum) -> int
	        

ida_idp.IDP_Hooks.ev_newbinary():
	
	        ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
	        

ida_idp.IDP_Hooks.ev_newfile():
	
	        ev_newfile(self, fname) -> int
	        

ida_idp.IDP_Hooks.ev_newprc():
	
	        ev_newprc(self, pnum, keep_cfg) -> int
	        

ida_idp.IDP_Hooks.ev_next_exec_insn():
	
	        ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
	        

ida_idp.IDP_Hooks.ev_oldfile():
	
	        ev_oldfile(self, fname) -> int
	        

ida_idp.IDP_Hooks.ev_out_assumes():
	
	        ev_out_assumes(self, outctx) -> int
	        

ida_idp.IDP_Hooks.ev_out_data():
	
	        ev_out_data(self, outctx, analyze_only) -> int
	        

ida_idp.IDP_Hooks.ev_out_footer():
	
	        ev_out_footer(self, outctx)
	        

ida_idp.IDP_Hooks.ev_out_header():
	
	        ev_out_header(self, outctx)
	        

ida_idp.IDP_Hooks.ev_out_insn():
	
	        ev_out_insn(self, outctx) -> bool
	
	
	        Outputs the instruction defined in 'ctx.insn'
	        
	        @return: Boolean (whether this instruction can be outputted or not)
	        

ida_idp.IDP_Hooks.ev_out_label():
	
	        ev_out_label(self, outctx, colored_name) -> int
	        

ida_idp.IDP_Hooks.ev_out_mnem():
	
	        ev_out_mnem(self, outctx) -> int
	        

ida_idp.IDP_Hooks.ev_out_operand():
	
	        ev_out_operand(self, outctx, op) -> bool
	
	
	        Notification to generate operand text.
	        If False was returned, then the standard operand output function will be called.
	        
	        this notification may use out_...() functions to form the operand text
	        
	        @return: Boolean (whether the operand has been outputted or not)
	        

ida_idp.IDP_Hooks.ev_out_segend():
	
	        ev_out_segend(self, outctx, seg) -> int
	        

ida_idp.IDP_Hooks.ev_out_segstart():
	
	        ev_out_segstart(self, outctx, seg) -> int
	        

ida_idp.IDP_Hooks.ev_out_special_item():
	
	        ev_out_special_item(self, outctx, segtype) -> int
	        

ida_idp.IDP_Hooks.ev_realcvt():
	
	        ev_realcvt(self, m, e, swt) -> int
	        

ida_idp.IDP_Hooks.ev_rename():
	
	        ev_rename(self, ea, new_name) -> int
	
	
	        The kernel is going to rename a byte.
	        
	        @param ea: Address
	        @param new_name: The new name
	        
	        @return:
	            - If returns value <0, then the kernel should
	              not rename it. See also the 'renamed' event
	        

ida_idp.IDP_Hooks.ev_set_idp_options():
	
	        ev_set_idp_options(self, keyword, value_type, value, errbuf) -> int
	        

ida_idp.IDP_Hooks.ev_set_proc_options():
	
	        ev_set_proc_options(self, options, confidence) -> int
	        

ida_idp.IDP_Hooks.ev_setup_til():
	
	        ev_setup_til(self)
	        

ida_idp.IDP_Hooks.ev_shadow_args_size():
	
	        ev_shadow_args_size(self, shadow_args_size, pfn) -> int
	        

ida_idp.IDP_Hooks.ev_str2reg():
	
	        ev_str2reg(self, regname) -> int
	        

ida_idp.IDP_Hooks.ev_term():
	
	        ev_term(self) -> int
	        

ida_idp.IDP_Hooks.ev_treat_hindering_item():
	
	        ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
	        

ida_idp.IDP_Hooks.ev_undefine():
	
	        ev_undefine(self, ea) -> int
	
	
	        An item in the database (insn or data) is being deleted
	        @param ea: Address
	        @return:
	            - 1 - do not delete srranges at the item end
	            - 0 - srranges can be deleted
	        

ida_idp.IDP_Hooks.ev_use_arg_types():
	
	        ev_use_arg_types(self, ea, fti, rargs) -> int
	        

ida_idp.IDP_Hooks.ev_use_regarg_type():
	
	        ev_use_regarg_type(self, ea, rargs) -> PyObject *
	        

ida_idp.IDP_Hooks.ev_use_stkarg_type():
	
	        ev_use_stkarg_type(self, ea, arg) -> int
	        

ida_idp.IDP_Hooks.ev_validate_flirt_func():
	
	        ev_validate_flirt_func(self, start_ea, funcname) -> int
	        

ida_idp.IDP_Hooks.ev_verify_noreturn():
	
	        ev_verify_noreturn(self, pfn) -> int
	        

ida_idp.IDP_Hooks.ev_verify_sp():
	
	        ev_verify_sp(self, pfn) -> int
	        

ida_idp.IDP_Hooks.hook():
	
	        hook(self) -> bool
	
	
	        Creates an IDP hook
	        
	        @return: Boolean true on success
	        

ida_idp.IDP_Hooks.unhook():
	
	        unhook(self) -> bool
	
	
	        Removes the IDP hook
	        @return: Boolean true on success
	        

class ida_idp.asm_t():
	
	    Proxy of C++ asm_t class
	    

ida_idp.asm_t.a_align:
	asm_t_a_align_get(self) -> char const *

ida_idp.asm_t.a_ascii:
	asm_t_a_ascii_get(self) -> char const *

ida_idp.asm_t.a_band:
	asm_t_a_band_get(self) -> char const *

ida_idp.asm_t.a_bnot:
	asm_t_a_bnot_get(self) -> char const *

ida_idp.asm_t.a_bor:
	asm_t_a_bor_get(self) -> char const *

ida_idp.asm_t.a_bss:
	asm_t_a_bss_get(self) -> char const *

ida_idp.asm_t.a_byte:
	asm_t_a_byte_get(self) -> char const *

ida_idp.asm_t.a_comdef:
	asm_t_a_comdef_get(self) -> char const *

ida_idp.asm_t.a_curip:
	asm_t_a_curip_get(self) -> char const *

ida_idp.asm_t.a_double:
	asm_t_a_double_get(self) -> char const *

ida_idp.asm_t.a_dups:
	asm_t_a_dups_get(self) -> char const *

ida_idp.asm_t.a_dword:
	asm_t_a_dword_get(self) -> char const *

ida_idp.asm_t.a_equ:
	asm_t_a_equ_get(self) -> char const *

ida_idp.asm_t.a_extrn:
	asm_t_a_extrn_get(self) -> char const *

ida_idp.asm_t.a_float:
	asm_t_a_float_get(self) -> char const *

ida_idp.asm_t.a_include_fmt:
	asm_t_a_include_fmt_get(self) -> char const *

ida_idp.asm_t.a_mod:
	asm_t_a_mod_get(self) -> char const *

ida_idp.asm_t.a_oword:
	asm_t_a_oword_get(self) -> char const *

ida_idp.asm_t.a_packreal:
	asm_t_a_packreal_get(self) -> char const *

ida_idp.asm_t.a_public:
	asm_t_a_public_get(self) -> char const *

ida_idp.asm_t.a_qword:
	asm_t_a_qword_get(self) -> char const *

ida_idp.asm_t.a_rva:
	asm_t_a_rva_get(self) -> char const *

ida_idp.asm_t.a_seg:
	asm_t_a_seg_get(self) -> char const *

ida_idp.asm_t.a_shl:
	asm_t_a_shl_get(self) -> char const *

ida_idp.asm_t.a_shr:
	asm_t_a_shr_get(self) -> char const *

ida_idp.asm_t.a_sizeof_fmt:
	asm_t_a_sizeof_fmt_get(self) -> char const *

ida_idp.asm_t.a_tbyte:
	asm_t_a_tbyte_get(self) -> char const *

ida_idp.asm_t.a_vstruc_fmt:
	asm_t_a_vstruc_fmt_get(self) -> char const *

ida_idp.asm_t.a_weak:
	asm_t_a_weak_get(self) -> char const *

ida_idp.asm_t.a_word:
	asm_t_a_word_get(self) -> char const *

ida_idp.asm_t.a_xor:
	asm_t_a_xor_get(self) -> char const *

ida_idp.asm_t.a_yword:
	asm_t_a_yword_get(self) -> char const *

ida_idp.asm_t.accsep:
	asm_t_accsep_get(self) -> char

ida_idp.asm_t.ascsep:
	asm_t_ascsep_get(self) -> char

ida_idp.asm_t.cmnt:
	asm_t_cmnt_get(self) -> char const *

ida_idp.asm_t.cmnt2:
	asm_t_cmnt2_get(self) -> char const *

ida_idp.asm_t.end:
	asm_t_end_get(self) -> char const *

ida_idp.asm_t.esccodes:
	asm_t_esccodes_get(self) -> char const *

ida_idp.asm_t.flag:
	asm_t_flag_get(self) -> uint32

ida_idp.asm_t.flag2:
	asm_t_flag2_get(self) -> uint32

ida_idp.asm_t.header:
	asm_t_header_get(self) -> char const *const *

ida_idp.asm_t.help:
	asm_t_help_get(self) -> help_t

ida_idp.asm_t.high16:
	asm_t_high16_get(self) -> char const *

ida_idp.asm_t.high8:
	asm_t_high8_get(self) -> char const *

ida_idp.asm_t.lbrace:
	asm_t_lbrace_get(self) -> char

ida_idp.asm_t.low16:
	asm_t_low16_get(self) -> char const *

ida_idp.asm_t.low8:
	asm_t_low8_get(self) -> char const *

ida_idp.asm_t.name:
	asm_t_name_get(self) -> char const *

ida_idp.asm_t.origin:
	asm_t_origin_get(self) -> char const *

ida_idp.asm_t.rbrace:
	asm_t_rbrace_get(self) -> char

ida_idp.asm_t.uflag:
	asm_t_uflag_get(self) -> uint16

ida_idp.assemble():
	
	  assemble(ea, cs, ip, use32, line) -> bool
	
	
	  Assemble an instruction into the database (display a warning if an error is found)
	  @param ea: linear address of instruction
	  @param cs: cs of instruction
	  @param ip: ip of instruction
	  @param use32: is 32bit segment?
	  @param line: line to assemble
	  
	  @return: Boolean. True on success.
	  

ida_idp.cfg_get_cc_header_path():
	
	  cfg_get_cc_header_path(compid) -> char const *
	  

ida_idp.cfg_get_cc_parm():
	
	  cfg_get_cc_parm(compid, name) -> char const *
	  

ida_idp.cfg_get_cc_predefined_macros():
	
	  cfg_get_cc_predefined_macros(compid) -> char const *
	  

ida_idp.compare():
	
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    

ida_idp.delay_slot_insn():
	
	  delay_slot_insn(ea, bexec, fexec) -> bool
	
	
	  Helper function to get the delay slot instruction.
	  
	  
	  @param ea (C++: ea_t *)
	  @param bexec (C++: bool *)
	  @param fexec (C++: bool *)
	  

ida_idp.gen_idb_event():
	
	  gen_idb_event(code)
	
	
	  the kernel will use this function to generate idb_events
	  
	  
	  @param code (C++: idb_event::event_code_t)
	  

ida_idp.get_idp_name():
	
	  get_idp_name() -> char *
	
	
	  Get name of the current processor module. The name is derived from the
	  file name. For example, for IBM PC the module is named "pc.w32"
	  (windows version), then the module name is "PC" (uppercase). If no
	  processor module is loaded, this function will return NULL
	  

ida_idp.get_reg_info():
	
	  get_reg_info(regname, bitrange) -> char const *
	
	
	  Get register information - useful for registers like al, ah, dil, etc.
	  
	  @param regname (C++: const char *)
	  @param bitrange (C++: bitrange_t  *)
	  @return: NULL no such register
	  

ida_idp.get_reg_name():
	
	  get_reg_name(reg, width, reghi=-1) -> ssize_t
	
	
	  Get text representation of a register. For most processors this
	  function will just return {reg_names}[reg]. If the processor module
	  has implemented processor_t::get_reg_name, it will be used instead
	  
	  @param reg: internal register number as defined in the processor
	              module (C++: int)
	  @param width: register width in bytes (C++: size_t)
	  @param reghi: if specified, then this function will return the
	                register pair (C++: int)
	  @return: length of register name in bytes or -1 if failure
	  

ida_idp.has_cf_chg():
	
	  has_cf_chg(feature, opnum) -> bool
	
	
	  Does an instruction with the specified feature modify the i-th
	  operand?
	  
	  
	  @param feature (C++: uint32)
	  @param opnum (C++: uint)
	  

ida_idp.has_cf_use():
	
	  has_cf_use(feature, opnum) -> bool
	
	
	  Does an instruction with the specified feature use a value of the i-th
	  operand?
	  
	  
	  @param feature (C++: uint32)
	  @param opnum (C++: uint)
	  

ida_idp.has_insn_feature():
	
	  has_insn_feature(icode, bit) -> bool
	
	
	  Does the specified instruction have the specified feature?
	  
	  
	  @param icode (C++: int)
	  @param bit (C++: uint32)
	  

ida_idp.is_align_insn():
	
	  is_align_insn(ea) -> int
	
	
	  If the instruction at 'ea' looks like an alignment instruction, return
	  its length in bytes. Otherwise return 0.
	  
	  @param ea (C++: ea_t)
	  

ida_idp.is_basic_block_end():
	
	  is_basic_block_end(insn, call_insn_stops_block) -> bool
	
	
	  Is the instruction the end of a basic block?
	  
	  
	  @param insn (C++: const  insn_t  &)
	  @param call_insn_stops_block (C++: bool)
	  

ida_idp.is_call_insn():
	
	  is_call_insn(insn) -> bool
	
	
	  Is the instruction a "call"?
	  
	  
	  @param insn (C++: const  insn_t  &)
	  

ida_idp.is_indirect_jump_insn():
	
	  is_indirect_jump_insn(insn) -> bool
	
	
	  Is the instruction an indirect jump?
	  
	  
	  @param insn (C++: const  insn_t  &)
	  

ida_idp.is_ret_insn():
	
	  is_ret_insn(insn, strict=True) -> bool
	
	
	  Is the instruction a "return"?
	  
	  
	  @param insn (C++: const  insn_t  &)
	  @param strict (C++: bool)
	  

ida_idp.parse_reg_name():
	
	  parse_reg_name(ri, regname) -> bool
	
	
	  Get register info by name.
	  
	  @param ri: result (C++: reg_info_t  *)
	  @param regname: name of register (C++: const char *)
	  @return: success
	  

ida_idp.ph_calcrel():
	
	  ph_calcrel(ea)
	  

ida_idp.ph_find_op_value():
	
	  ph_find_op_value(insn, op) -> ssize_t
	  

ida_idp.ph_find_reg_value():
	
	  ph_find_reg_value(insn, reg) -> ssize_t
	  

ida_idp.ph_get_cnbits():
	
	  ph_get_cnbits() -> size_t
	
	
	  Returns the 'ph.cnbits'
	  

ida_idp.ph_get_dnbits():
	
	  ph_get_dnbits() -> size_t
	
	
	  Returns the 'ph.dnbits'
	  

ida_idp.ph_get_flag():
	
	  ph_get_flag() -> size_t
	
	
	  Returns the 'ph.flag'
	  

ida_idp.ph_get_icode_return():
	
	  ph_get_icode_return() -> size_t
	
	
	  Returns the 'ph.icode_return'
	  

ida_idp.ph_get_id():
	
	  ph_get_id() -> size_t
	
	
	  Returns the 'ph.id' field
	  

ida_idp.ph_get_instruc():
	
	  ph_get_instruc() -> PyObject *
	
	
	  Returns a list of tuples (instruction_name, instruction_feature) containing the
	  instructions list as defined in he processor module
	  

ida_idp.ph_get_instruc_end():
	
	  ph_get_instruc_end() -> size_t
	
	
	  Returns the 'ph.instruc_end'
	  

ida_idp.ph_get_instruc_start():
	
	  ph_get_instruc_start() -> size_t
	
	
	  Returns the 'ph.instruc_start'
	  

ida_idp.ph_get_operand_info():
	
	  ph_get_operand_info(ea, n) -> PyObject *
	
	
	  Returns the operand information given an ea and operand number.
	  
	  @param ea: address
	  @param n: operand number
	  
	  @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
	           Please refer to idd_opinfo_t structure in the SDK.
	  

ida_idp.ph_get_reg_code_sreg():
	
	  ph_get_reg_code_sreg() -> size_t
	
	
	  Returns the 'ph.reg_code_sreg'
	  

ida_idp.ph_get_reg_data_sreg():
	
	  ph_get_reg_data_sreg() -> size_t
	
	
	  Returns the 'ph.reg_data_sreg'
	  

ida_idp.ph_get_reg_first_sreg():
	
	  ph_get_reg_first_sreg() -> size_t
	
	
	  Returns the 'ph.reg_first_sreg'
	  

ida_idp.ph_get_reg_last_sreg():
	
	  ph_get_reg_last_sreg() -> size_t
	
	
	  Returns the 'ph.reg_last_sreg'
	  

ida_idp.ph_get_regnames():
	
	  ph_get_regnames() -> PyObject *
	
	
	  Returns the list of register names as defined in the processor module
	  

ida_idp.ph_get_segreg_size():
	
	  ph_get_segreg_size() -> size_t
	
	
	  Returns the 'ph.segreg_size'
	  

ida_idp.ph_get_tbyte_size():
	
	  ph_get_tbyte_size() -> size_t
	
	
	  Returns the 'ph.tbyte_size' field as defined in he processor module
	  

ida_idp.ph_get_version():
	
	  ph_get_version() -> size_t
	
	
	  Returns the 'ph.version'
	  

class ida_idp.processor_t():
	
	    Base class for all processor module scripts
	    

ida_idp.processor_t.get_auxpref():
	
	        This function returns insn.auxpref value
	        

ida_idp.processor_t.get_idpdesc():
	
	        This function must be present and should return the list of
	        short processor names similar to the one in ph.psnames.
	        This method can be overridden to return to the kernel a different IDP description.
	        

ida_idp.processor_t.get_uFlag():
	
	        Use this utility function to retrieve the 'uFlag' global variable
	        

class ida_idp.reg_info_t():
	
	    Proxy of C++ reg_info_t class
	    

ida_idp.reg_info_t.compare():
	
	        compare(self, r) -> int
	        

ida_idp.reg_info_t.reg:
	reg_info_t_reg_get(self) -> int

ida_idp.reg_info_t.size:
	reg_info_t_size_get(self) -> int

ida_idp.set_processor_type():
	
	  set_processor_type(procname, level) -> bool
	
	
	  Set target processor type. Once a processor module is loaded, it can
	  not be replaced until we close the idb.
	  
	  @param procname: name of processor type (one of names present in
	                   {psnames}) (C++: const char *)
	  @param level: SETPROC_ (C++: setproc_level_t)
	  @return: success
	  

ida_idp.set_target_assembler():
	
	  set_target_assembler(asmnum) -> bool
	
	
	  Set target assembler.
	  
	  @param asmnum: number of assembler in the current processor module
	                 (C++: int)
	  @return: success
	  

ida_idp.sizeof_ldbl():
	
	  sizeof_ldbl() -> size_t
	
	
	  Get size of long double.
	  

ida_idp.str2reg():
	
	  str2reg(p) -> int
	
	
	  Get any reg number (-1 on error)
	  
	  
	  @param p (C++: const char *)
	  


=== ida_idp EPYDOC INJECTIONS ===
ida_idp.AS2_BRACE
"""
Use braces for all expressions.
"""

ida_idp.AS2_BYTE1CHAR
"""
Meaningful only for wide byte processors.

One symbol per processor byte
"""

ida_idp.AS2_COLONSUF
"""
addresses may have ":xx" suffix this suffix must be ignored when
extracting the address under the cursor
"""

ida_idp.AS2_IDEALDSCR
"""
Description of struc/union is in the 'reverse' form (keyword before
name) the same as in borland tasm ideal
"""

ida_idp.AS2_STRINV
"""
(For processors with bytes bigger than 8 bits)

Invert meaning of {wide_high_byte_first} for text strings
"""

ida_idp.AS2_TERSESTR
"""
NAME<fld,fld,...> is supported.

'terse' structure initialization form
"""

ida_idp.AS2_YWORD
"""
a_yword field is present and valid
"""

ida_idp.ASB_BINF0
"""
010101b
"""

ida_idp.ASB_BINF1
"""
^B010101
"""

ida_idp.ASB_BINF2
"""
%010101
"""

ida_idp.ASB_BINF3
"""
0b1010101
"""

ida_idp.ASB_BINF4
"""
b'1010101
"""

ida_idp.ASB_BINF5
"""
b'1010101'
"""

ida_idp.ASD_DECF0
"""
34
"""

ida_idp.ASD_DECF1
"""
#34
"""

ida_idp.ASD_DECF3
"""
.34
"""

ida_idp.ASH_HEXF0
"""
34h
"""

ida_idp.ASH_HEXF1
"""
h'34
"""

ida_idp.ASH_HEXF2
"""
34
"""

ida_idp.ASH_HEXF3
"""
0x34
"""

ida_idp.ASH_HEXF4
"""
$34
"""

ida_idp.ASH_HEXF5
"""
<^R > (radix)
"""

ida_idp.ASO_OCTF0
"""
123o
"""

ida_idp.ASO_OCTF1
"""
0123
"""

ida_idp.ASO_OCTF2
"""
123
"""

ida_idp.ASO_OCTF3
"""
@123
"""

ida_idp.ASO_OCTF4
"""
o'123
"""

ida_idp.ASO_OCTF5
"""
123q
"""

ida_idp.ASO_OCTF6
"""
~123
"""

ida_idp.ASO_OCTF7
"""
q'123
"""

ida_idp.AS_1TEXT
"""
1 text per line, no bytes
"""

ida_idp.AS_2CHRE
"""
double char constants are: "xy
"""

ida_idp.AS_ALIGN2
"""
(.align 5 means to align at 32byte boundary)

.align directive expects an exponent rather than a power of 2
"""

ida_idp.AS_ASCIIC
"""
(\n,\x01 and similar)

ascii directive accepts C-like escape sequences
"""

ida_idp.AS_ASCIIZ
"""
ascii directive inserts implicit zero byte at the end
"""

ida_idp.AS_BINFM
"""
mask - binary number format
"""

ida_idp.AS_COLON
"""
create colons after data names ?
"""

ida_idp.AS_DECFM
"""
mask - decimal number format
"""

ida_idp.AS_HEXFM
"""
mask - hex number format
"""

ida_idp.AS_LALIGN
"""
Labels at "align" keyword are supported.
"""

ida_idp.AS_N2CHR
"""
can't have 2 byte char consts
"""

ida_idp.AS_NCHRE
"""
char constants are: 'x
"""

ida_idp.AS_NCMAS
"""
no commas in ascii directives
"""

ida_idp.AS_NHIAS
"""
no characters with high bit
"""

ida_idp.AS_NOCODECLN
"""
don't create colons after code names
"""

ida_idp.AS_NOSPACE
"""
No spaces in expressions.
"""

ida_idp.AS_NOXRF
"""
Disable xrefs during the output file generation.
"""

ida_idp.AS_OCTFM
"""
mask - octal number format
"""

ida_idp.AS_OFFST
"""
offsets are 'offset xxx' ?
"""

ida_idp.AS_ONEDUP
"""
One array definition per line.
"""

ida_idp.AS_RELSUP
"""
Checkarg: 'and','or','xor' operations with addresses are possible.
"""

ida_idp.AS_UDATA
"""
can use '?' in data directives
"""

ida_idp.AS_UNEQU
"""
replace undefined data items with EQU (for ANTA's A80)
"""

ida_idp.AS_XTRNTYPE
"""
Assembler understands type of extern symbols as ":type" suffix.
"""

ida_idp.CF_CALL
"""
CALL instruction (should make a procedure here)
"""

ida_idp.CF_CHG1
"""
The instruction modifies the first operand.
"""

ida_idp.CF_CHG2
"""
The instruction modifies the second operand.
"""

ida_idp.CF_CHG3
"""
The instruction modifies the third operand.
"""

ida_idp.CF_CHG4
"""
The instruction modifies 4 operand.
"""

ida_idp.CF_CHG5
"""
The instruction modifies 5 operand.
"""

ida_idp.CF_CHG6
"""
The instruction modifies 6 operand.
"""

ida_idp.CF_HLL
"""
language function.

Instruction may be present in a high level
"""

ida_idp.CF_JUMP
"""
jump or call (thus needs additional analysis)

The instruction passes execution using indirect
"""

ida_idp.CF_SHFT
"""
Bit-shift instruction (shl,shr...)
"""

ida_idp.CF_STOP
"""
next instruction

Instruction doesn't pass execution to the
"""

ida_idp.CF_USE1
"""
The instruction uses value of the first operand.
"""

ida_idp.CF_USE2
"""
The instruction uses value of the second operand.
"""

ida_idp.CF_USE3
"""
The instruction uses value of the third operand.
"""

ida_idp.CF_USE4
"""
The instruction uses value of the 4 operand.
"""

ida_idp.CF_USE5
"""
The instruction uses value of the 5 operand.
"""

ida_idp.CF_USE6
"""
The instruction uses value of the 6 operand.
"""

ida_idp.CUSTOM_INSN_ITYPE
"""
Custom instruction codes defined by processor extension plugins must
be greater than or equal to this
"""

ida_idp.IDP_INTERFACE_VERSION
"""
The interface version number.see also 'IDA_SDK_VERSION' from 'pro.h'
"""

ida_idp.OP_FP_BASED
"""
operand is FP based
"""

ida_idp.OP_SP_ADD
"""
operand value is added to the pointer
"""

ida_idp.OP_SP_BASED
"""
operand is SP based
"""

ida_idp.OP_SP_SUB
"""
operand value is subtracted from the pointer
"""

ida_idp.PLFM_386
"""
Intel 80x86.
"""

ida_idp.PLFM_6502
"""
6502
"""

ida_idp.PLFM_65C816
"""
65802/65816
"""

ida_idp.PLFM_6800
"""
Motorola 68xx.
"""

ida_idp.PLFM_68K
"""
Motorola 680x0.
"""

ida_idp.PLFM_80196
"""
Intel 80196.
"""

ida_idp.PLFM_8051
"""
8051
"""

ida_idp.PLFM_AD2106X
"""
Analog Devices ADSP 2106X.
"""

ida_idp.PLFM_AD218X
"""
Analog Devices ADSP 218X.
"""

ida_idp.PLFM_ALPHA
"""
DEC Alpha.
"""

ida_idp.PLFM_ARC
"""
Argonaut RISC Core.
"""

ida_idp.PLFM_ARM
"""
Advanced RISC Machines.
"""

ida_idp.PLFM_AVR
"""
Atmel 8-bit RISC processor(s)
"""

ida_idp.PLFM_C166
"""
Siemens C166 family.
"""

ida_idp.PLFM_C39
"""
Rockwell C39.
"""

ida_idp.PLFM_CR16
"""
NSC CR16.
"""

ida_idp.PLFM_DALVIK
"""
Android Dalvik Virtual Machine.
"""

ida_idp.PLFM_DSP56K
"""
Motorola DSP5600x.
"""

ida_idp.PLFM_DSP96K
"""
Motorola DSP96000.
"""

ida_idp.PLFM_EBC
"""
EFI Bytecode.
"""

ida_idp.PLFM_F2MC
"""
Fujistu F2MC-16.
"""

ida_idp.PLFM_FR
"""
Fujitsu FR Family.
"""

ida_idp.PLFM_H8
"""
Hitachi H8/300, H8/2000.
"""

ida_idp.PLFM_H8500
"""
Hitachi H8/500.
"""

ida_idp.PLFM_HPPA
"""
Hewlett-Packard PA-RISC.
"""

ida_idp.PLFM_I860
"""
Intel 860.
"""

ida_idp.PLFM_I960
"""
Intel 960.
"""

ida_idp.PLFM_IA64
"""
Intel Itanium IA64.
"""

ida_idp.PLFM_JAVA
"""
Java.
"""

ida_idp.PLFM_KR1878
"""
Angstrem KR1878.
"""

ida_idp.PLFM_M16C
"""
Renesas M16C.
"""

ida_idp.PLFM_M32R
"""
Mitsubishi 32bit RISC.
"""

ida_idp.PLFM_M740
"""
Mitsubishi 8bit.
"""

ida_idp.PLFM_M7700
"""
Mitsubishi 16bit.
"""

ida_idp.PLFM_M7900
"""
Mitsubishi 7900.
"""

ida_idp.PLFM_MC6812
"""
Motorola 68HC12.
"""

ida_idp.PLFM_MC6816
"""
Motorola 68HC16.
"""

ida_idp.PLFM_MIPS
"""
MIPS.
"""

ida_idp.PLFM_MN102L00
"""
Panasonic MN10200.
"""

ida_idp.PLFM_MSP430
"""
Texas Instruments MSP430.
"""

ida_idp.PLFM_NEC_78K0
"""
NEC 78K0.
"""

ida_idp.PLFM_NEC_78K0S
"""
NEC 78K0S.
"""

ida_idp.PLFM_NEC_V850X
"""
NEC V850 and V850ES/E1/E2.
"""

ida_idp.PLFM_NET
"""
Microsoft Visual Studio.Net.
"""

ida_idp.PLFM_OAKDSP
"""
Atmel OAK DSP.
"""

ida_idp.PLFM_PDP
"""
PDP11.
"""

ida_idp.PLFM_PIC
"""
Microchip's PIC.
"""

ida_idp.PLFM_PIC16
"""
Microchip's 16-bit PIC.
"""

ida_idp.PLFM_PPC
"""
PowerPC.
"""

ida_idp.PLFM_SCR_ADPT
"""
Processor module adapter for processor modules written in scripting
languages.
"""

ida_idp.PLFM_SH
"""
Renesas (formerly Hitachi) SuperH.
"""

ida_idp.PLFM_SPARC
"""
SPARC.
"""

ida_idp.PLFM_SPC700
"""
Sony SPC700.
"""

ida_idp.PLFM_SPU
"""
Cell Broadband Engine Synergistic Processor Unit.
"""

ida_idp.PLFM_ST20
"""
SGS-Thomson ST20.
"""

ida_idp.PLFM_ST7
"""
SGS-Thomson ST7.
"""

ida_idp.PLFM_ST9
"""
ST9+.
"""

ida_idp.PLFM_TLCS900
"""
Toshiba TLCS-900.
"""

ida_idp.PLFM_TMS
"""
Texas Instruments TMS320C5x.
"""

ida_idp.PLFM_TMS320C1X
"""
Texas Instruments TMS320C1x.
"""

ida_idp.PLFM_TMS320C28
"""
Texas Instruments TMS320C28x.
"""

ida_idp.PLFM_TMS320C3
"""
Texas Instruments TMS320C3.
"""

ida_idp.PLFM_TMS320C54
"""
Texas Instruments TMS320C54xx.
"""

ida_idp.PLFM_TMS320C55
"""
Texas Instruments TMS320C55xx.
"""

ida_idp.PLFM_TMSC6
"""
Texas Instruments TMS320C6x.
"""

ida_idp.PLFM_TRICORE
"""
Tasking Tricore.
"""

ida_idp.PLFM_TRIMEDIA
"""
Trimedia.
"""

ida_idp.PLFM_UNSP
"""
SunPlus unSP.
"""

ida_idp.PLFM_Z8
"""
Z8.
"""

ida_idp.PLFM_Z80
"""
8085, Z80
"""

ida_idp.PRN_BIN
"""
binary
"""

ida_idp.PRN_DEC
"""
decimal
"""

ida_idp.PRN_HEX
"""
hex
"""

ida_idp.PRN_OCT
"""
octal
"""

ida_idp.PR_ADJSEGS
"""
IDA may adjust segments' starting/ending addresses.
"""

ida_idp.PR_ALIGN
"""
All data items should be aligned properly.
"""

ida_idp.PR_ALIGN_INSN
"""
allow ida to create alignment instructions arbitrarily. Since these
instructions might lead to other wrong instructions and spoil the
listing, IDA does not create them by default anymore
"""

ida_idp.PR_ASSEMBLE
"""
Module has a built-in assembler and will react to ev_assemble.
"""

ida_idp.PR_BINMEM
"""
the processor module provides correct segmentation for binary files
(i.e. it creates additional segments) The kernel will not ask the user
to specify the RAM/ROM sizes
"""

ida_idp.PR_CHK_XREF
"""
don't allow near xrefs between segments with different bases
"""

ida_idp.PR_CNDINSNS
"""
has conditional instructions
"""

ida_idp.PR_DEFNUM
"""
mask - default number representation
"""

ida_idp.PR_DEFSEG32
"""
segments are 32-bit by default
"""

ida_idp.PR_DEFSEG64
"""
segments are 64-bit by default
"""

ida_idp.PR_DELAYED
"""
has delayed jumps and calls if this flag is set, {is_basic_block_end},
{has_delay_slot} should be implemented
"""

ida_idp.PR_NOCHANGE
"""
(display only)

The user can't change segments and code/data attributes
"""

ida_idp.PR_NO_SEGMOVE
"""
(i.e. the user can't move segments)

the processor module doesn't support 'move_segm()'
"""

ida_idp.PR_PURGING
"""
there are calling conventions which may purge bytes from the stack
"""

ida_idp.PR_RNAMESOK
"""
allow user register names for location names
"""

ida_idp.PR_SCALE_STKVARS
"""
use {get_stkvar_scale} callback
"""

ida_idp.PR_SEGS
"""
has segment registers?
"""

ida_idp.PR_SEGTRANS
"""
the processor module supports the segment translation feature (meaning
it calculates the code addresses using the 'map_code_ea()' function)
"""

ida_idp.PR_SGROTHER
"""
the segment registers don't contain the segment selectors.
"""

ida_idp.PR_STACK_UP
"""
the stack grows up
"""

ida_idp.PR_TYPEINFO
"""
ALL OF THEM SHOULD BE IMPLEMENTED!

the processor module supports type information callbacks
"""

ida_idp.PR_USE32
"""
supports 32-bit addressing?
"""

ida_idp.PR_USE64
"""
supports 64-bit addressing?
"""

ida_idp.PR_USE_ARG_TYPES
"""
use {use_arg_types} callback
"""

ida_idp.PR_USE_TBYTE
"""
 'BTMT_SPECFLT' means _TBYTE type
"""

ida_idp.PR_WORD_INS
"""
instruction codes are grouped 2bytes in binary line prefix
"""

ida_idp.REG_SPOIL
"""
processor_t::use_regarg_type uses this bit in the return value to
indicate that the register value has been spoiled
"""
=== ida_idp EPYDOC INJECTIONS END ===
class ida_kernwin.Choose():
	
	    Chooser wrapper class.
	
	    Some constants are defined in this class.
	    Please refer to kernwin.hpp for more information.
	    

ida_kernwin.Choose.Activate():
	
	        Activates a visible chooser
	        

ida_kernwin.Choose.Close():
	
	        Closes the chooser
	        

ida_kernwin.Choose.Embedded():
	
	        Creates an embedded chooser (as opposed to Show())
	        @return: Returns 0 on success or NO_ATTR
	        

ida_kernwin.Choose.GetEmbSelection():
	
	        Deprecated. For embedded choosers, the selection is
	        available through 'Form.EmbeddedChooserControl.selection'
	        

ida_kernwin.Choose.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_kernwin.Choose.Refresh():
	
	        Causes the refresh callback to trigger
	        

ida_kernwin.Choose.Show():
	
	        Activates or creates a chooser window
	        @param modal: Display as modal dialog
	        @return: For all choosers it will return NO_ATTR if some mandatory
	                 attribute is missing. The mandatory attributes are: flags,
	                 title, cols, OnGetSize(), OnGetLine();
	                 For modal choosers it will return the selected item index (0-based),
	                 or NO_SELECTION if no selection,
	                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
	                 For non-modal choosers it will return 0
	                 or ALREADY_EXISTS if the chooser was already open and is active now;
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.create_desktop_widget():
	
	        create_desktop_widget(self, title, cfg) -> PyObject *
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.current_widget_changed():
	
	        current_widget_changed(self, widget, prev_widget)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.database_inited():
	
	        database_inited(self, is_new_database, idc_script)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.debugger_menu_change():
	
	        debugger_menu_change(self, enable) -> int
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.finish_populating_widget_popup():
	
	        finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
	
	
	        The UI is about to be done populating the TWidget's popup menu.
	        Now is a good time to call idaapi.attach_action_to_popup()
	        
	        @param widget: The widget
	        @param popup: The popup menu.
	        @return: Ignored
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.get_chooser_item_attrs():
	
	        get_chooser_item_attrs(self, chooser, n, attrs)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.get_custom_viewer_hint():
	
	        get_custom_viewer_hint(self, viewer, place) -> PyObject *
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.get_ea_hint():
	
	        get_ea_hint(self, ea) -> PyObject *
	
	
	        The UI wants to display a simple hint for an address in the navigation band
	        
	        @param ea: The address
	        @return: String with the hint or None
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.get_item_hint():
	
	        get_item_hint(self, ea, max_lines) -> PyObject *
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.hook():
	
	        hook(self) -> bool
	
	
	        Creates an UI hook
	        
	        @return: Boolean true on success
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.idcstart():
	
	        idcstart(self)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.idcstop():
	
	        idcstop(self)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.plugin_loaded():
	
	        plugin_loaded(self, plugin_info)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.plugin_unloading():
	
	        plugin_unloading(self, plugin_info)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.postprocess_action():
	
	        postprocess_action(self)
	
	
	        An ida ui action has been handled
	        
	        @return: Ignored
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.preprocess_action():
	
	        preprocess_action(self, name)
	
	
	        IDA ui is about to handle a user action
	        
	        @param name: ui action name
	                     (these names can be looked up in ida[tg]ui.cfg)
	        @return: 0-ok, nonzero - a plugin has handled the action
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.range():
	
	        range(self)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.ready_to_run():
	
	        ready_to_run(self)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.resume():
	
	        resume(self)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.saved():
	
	        saved(self)
	
	
	        The kernel has saved the database.
	        
	        @return: Ignored
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.saving():
	
	        saving(self)
	
	
	        The kernel is saving the database.
	        
	        @return: Ignored
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.screen_ea_changed():
	
	        screen_ea_changed(self, ea, prev_ea)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.suspend():
	
	        suspend(self)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.term():
	
	        term(self)
	
	
	        IDA is terminated and the database is already closed.
	        The UI may close its windows in this callback.
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.unhook():
	
	        unhook(self) -> bool
	
	
	        Removes the UI hook
	        @return: Boolean true on success
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.updated_actions():
	
	        updated_actions(self)
	
	
	        The UI is done updating actions.
	        
	        @return: Ignored
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.updating_actions():
	
	        updating_actions(self, ctx)
	
	
	        The UI is about to batch-update some actions.
	        
	        @param ctx: The action_update_ctx_t instance
	        @return: Ignored
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.widget_closing():
	
	        widget_closing(self, widget)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.widget_invisible():
	
	        widget_invisible(self, widget)
	        

ida_kernwin.Choose.UI_Hooks_Trampoline.widget_visible():
	
	        widget_visible(self, widget)
	        

ida_kernwin.Choose.adjust_last_item():
	
	        Helper for OnDeleteLine() and OnRefresh() callbacks.
	        They can be finished by the following line:
	        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
	        @param: line number of the remaining select item
	        @return: list of selected lines numbers (one element or empty)
	        

ida_kernwin.CustomIDAMemo.CreateGroups():
	
	        Send a request to modify the graph by creating a
	        (set of) group(s), and perform an animation.
	
	        Each object in the 'groups_infos' list must be of the format:
	        {
	          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
	          "text" : <string>                    # The synthetic text for that group
	        }
	
	        @param groups_infos: A list of objects that describe those groups.
	        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
	        

ida_kernwin.CustomIDAMemo.DelNodesInfos():
	
	        Delete the properties for the given node(s).
	
	        @param nodes: A list of node IDs
	        

ida_kernwin.CustomIDAMemo.DeleteGroups():
	
	        Send a request to delete the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param new_current: A node to focus on after the groups have been deleted
	        @return: True on success, False otherwise.
	        

ida_kernwin.CustomIDAMemo.GetNodeInfo():
	
	        Get the properties for the given node.
	
	        @param node: The index of the node.
	        @return: A tuple (bg_color, frame_color, ea, text), or None.
	        

ida_kernwin.CustomIDAMemo.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_kernwin.CustomIDAMemo.Refresh():
	
	        Refreshes the view. This causes the OnRefresh() to be called
	        

ida_kernwin.CustomIDAMemo.SetCurrentRendererType():
	
	        Set the current view's renderer.
	
	        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
	        

ida_kernwin.CustomIDAMemo.SetGroupsVisibility():
	
	        Send a request to expand/collapse the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param expand: True to expand the group, False otherwise.
	        @param new_current: A node to focus on after the groups have been expanded/collapsed.
	        @return: True on success, False otherwise.
	        

ida_kernwin.CustomIDAMemo.SetNodeInfo():
	
	        Set the properties for the given node.
	
	        Example usage (set second nodes's bg color to red):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff0000
	          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
	
	        @param node_index: The node index.
	        @param node_info: An idaapi.node_info_t instance.
	        @param flags: An OR'ed value of NIF_* values.
	        

ida_kernwin.CustomIDAMemo.SetNodesInfos():
	
	        Set the properties for the given nodes.
	
	        Example usage (set first three nodes's bg color to purple):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff00ff
	          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
	
	        @param values: A dictionary of 'int -> node_info_t' objects.
	        

ida_kernwin.CustomIDAMemo.hook():
	
	        hook(self) -> bool
	        

ida_kernwin.CustomIDAMemo.unhook():
	
	        unhook(self) -> bool
	        

ida_kernwin.CustomIDAMemo.view_created():
	
	        view_created(self, view)
	        

ida_kernwin.Form.Add():
	
	        Low level function. Prefer AddControls() to this function.
	        This function adds one control to the form.
	
	        @param name: Control name
	        @param ctrl: Control object
	        @param mkattr: Create control name / control object as a form attribute
	        

ida_kernwin.Form.AddControls():
	
	        Adds controls from a dictionary.
	        The dictionary key is the control name and the value is a Form.Control object
	        @param controls: The control dictionary
	        

class ida_kernwin.Form.ButtonInput():
	
	        Button control.
	        A handler along with a 'code' (numeric value) can be associated with the button.
	        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
	        

ida_kernwin.Form.ButtonInput.free():
	
	            Free the control
	            

ida_kernwin.Form.ButtonInput.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

class ida_kernwin.Form.ChkGroupControl():
	
	        Checkbox group control class.
	        It holds a set of checkbox controls
	        

ida_kernwin.Form.ChkGroupControl.free():
	
	            Free the control
	            

ida_kernwin.Form.ChkGroupControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.ChkGroupControl.is_input_field():
	
	            Return True if this field acts as an input
	            

class ida_kernwin.Form.ChkGroupItemControl():
	
	        Checkbox group item control
	        

ida_kernwin.Form.ChkGroupItemControl.free():
	
	            Free the control
	            

ida_kernwin.Form.ChkGroupItemControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.Close():
	
	        Close the form
	        @param close_normally:
	                   1: form is closed normally as if the user pressed Enter
	                   0: form is closed abnormally as if the user pressed Esc
	        @return: None
	        

class ida_kernwin.Form.ColorInput():
	
	        Color button input control
	        

ida_kernwin.Form.ColorInput.free():
	
	            Free the control
	            

ida_kernwin.Form.ColorInput.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.Compile():
	
	        Compiles a form and returns the form object (self) and the argument list.
	        The form object will contain object names corresponding to the form elements
	
	        @return: It will raise an exception on failure. Otherwise the return value is ignored
	        

ida_kernwin.Form.CompileEx():
	
	        Low level function.
	        Compiles (parses the form syntax and adds the control) the form string and
	        returns the argument list to be passed the argument list to ask_form().
	
	        The form controls are wrapped inside curly braces: {ControlName}.
	
	        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
	        This is useful when you use the STARTITEM form keyword to set the initially focused control.
	        (note that, technically, the index is not the same as the ID; that's because STARTITEM
	        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
	
	        @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
	        

ida_kernwin.Form.Compiled():
	
	        Checks if the form has already been compiled
	
	        @return: Boolean
	        

ida_kernwin.Form.Control.free():
	
	            Free the control
	            

ida_kernwin.Form.Control.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.Control.get_tag():
	
	            Control tag character. One of Form.FT_XXXX.
	            The form class will expand the {} notation and replace them with the tags
	            

ida_kernwin.Form.Control.is_input_field():
	
	            Return True if this field acts as an input
	            

ida_kernwin.Form.ControlToFieldTypeIdAndSize():
	
	        Converts a control object to a tuple containing the field id
	        and the associated buffer size
	        

class ida_kernwin.Form.DirInput():
	
	        Directory browsing control
	        

ida_kernwin.Form.DirInput.free():
	
	            Free the control
	            

ida_kernwin.Form.DirInput.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

class ida_kernwin.Form.DropdownListControl():
	
	        Dropdown control
	        This control allows manipulating a dropdown control
	        

ida_kernwin.Form.DropdownListControl._free():
	
	        Explicitly delete the link (only if not static)
	        

ida_kernwin.Form.DropdownListControl.add():
	
	        Add a string to the vector
	        

ida_kernwin.Form.DropdownListControl.addressof():
	
	        Returns the address (as number) of the qstring at the given index
	        

ida_kernwin.Form.DropdownListControl.assign():
	
	        Copies the contents of 'other' to 'self'
	        

ida_kernwin.Form.DropdownListControl.clear():
	
	        Clears all strings from the vector.
	        @param qclear: Just reset the size but do not actually free the memory
	        

ida_kernwin.Form.DropdownListControl.copy():
	
	        Returns a new copy of this class
	        

ida_kernwin.Form.DropdownListControl.from_list():
	
	        Populates the vector from a Python string list
	        

ida_kernwin.Form.DropdownListControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.DropdownListControl.insert():
	
	        Insert a string into the vector
	        

ida_kernwin.Form.DropdownListControl.remove():
	
	        Removes a string from the vector
	        

ida_kernwin.Form.DropdownListControl.set_items():
	
	            Sets the dropdown list items
	            

class ida_kernwin.Form.EmbeddedChooserControl():
	
	        Embedded chooser control.
	        This control links to a Chooser2 control created with the 'embedded=True'
	        

ida_kernwin.Form.EmbeddedChooserControl.free():
	
	            Frees the embedded chooser data
	            

ida_kernwin.Form.EmbeddedChooserControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.EnableField():
	
	        Enable or disable an input field
	        @return: False - no such control
	        

ida_kernwin.Form.Execute():
	
	        Displays a modal dialog containing the compiled form.
	        @return: 1 - ok ; 0 - cancel
	        

class ida_kernwin.Form.FileInput():
	
	        File Open/Save input control
	        

ida_kernwin.Form.FileInput.free():
	
	            Free the control
	            

ida_kernwin.Form.FileInput.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.FindControlById():
	
	        Finds a control instance given its id
	        

class ida_kernwin.Form.FormChangeCb():
	
	        Form change handler.
	        This can be thought of like a dialog procedure.
	        Everytime a form action occurs, this handler will be called along with the control id.
	        The programmer can then call various form actions accordingly:
	          - EnableField
	          - ShowField
	          - MoveField
	          - GetFieldValue
	          - etc...
	
	        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)
	
	        

ida_kernwin.Form.FormChangeCb.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.FormChangeCb.is_input_field():
	
	            Return True if this field acts as an input
	            

ida_kernwin.Form.Free():
	
	        Frees all resources associated with a compiled form.
	        Make sure you call this function when you finish using the form.
	        

ida_kernwin.Form.GetControlValue():
	
	        Returns the control's value depending on its type
	        @param ctrl: Form control instance
	        @return:
	            - color button, radio controls: integer
	            - file/dir input, string input and string label: string
	            - embedded chooser control (0-based indices of selected items): integer list
	            - for multilinetext control: textctrl_info_t
	            - dropdown list controls: string (when editable) or index (when readonly)
	            - None: on failure
	        

ida_kernwin.Form.GetFocusedField():
	
	        Get currently focused input field.
	        @return: None if no field is selected otherwise the control ID
	        

class ida_kernwin.Form.GroupControl():
	
	        Base class for group controls
	        

ida_kernwin.Form.GroupControl.free():
	
	            Free the control
	            

ida_kernwin.Form.GroupControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.GroupControl.is_input_field():
	
	            Return True if this field acts as an input
	            

class ida_kernwin.Form.GroupItemControl():
	
	        Base class for group control items
	        

ida_kernwin.Form.GroupItemControl.free():
	
	            Free the control
	            

ida_kernwin.Form.GroupItemControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

class ida_kernwin.Form.InputControl():
	
	        Generic form input control.
	        It could be numeric control, string control, directory/file browsing, etc...
	        

ida_kernwin.Form.InputControl.free():
	
	            Free the control
	            

ida_kernwin.Form.InputControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

class ida_kernwin.Form.LabelControl():
	
	        Base class for static label control
	        

ida_kernwin.Form.LabelControl.free():
	
	            Free the control
	            

ida_kernwin.Form.LabelControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.LabelControl.is_input_field():
	
	            Return True if this field acts as an input
	            

ida_kernwin.Form.MoveField():
	
	        Move/resize an input field
	
	        @return: False - no such fiel
	        

class ida_kernwin.Form.MultiLineTextControl():
	
	        Multi line text control.
	        This class inherits from textctrl_info_t. Thus the attributes are also inherited
	        This control allows manipulating a multilinetext control
	        

ida_kernwin.Form.MultiLineTextControl._free():
	
	        Explicitly delete the link (only if not static)
	        

ida_kernwin.Form.MultiLineTextControl.assign():
	
	        Copies the contents of 'other' to 'self'
	        

ida_kernwin.Form.MultiLineTextControl.copy():
	
	        Returns a new copy of this class
	        

ida_kernwin.Form.MultiLineTextControl.flags:
	
	        Returns the flags value
	        

ida_kernwin.Form.MultiLineTextControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.MultiLineTextControl.tabsize:
	
	        Returns the tabsize value
	        

ida_kernwin.Form.MultiLineTextControl.text:
	
	        Sets the text value
	        

ida_kernwin.Form.MultiLineTextControl.value:
	
	        Sets the text value
	        

class ida_kernwin.Form.NumericArgument():
	
	        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
	        @param tp: One of Form.FT_XXX
	        

class ida_kernwin.Form.NumericInput():
	
	        A composite class serving as a base numeric input control class
	        

ida_kernwin.Form.NumericInput.free():
	
	            Free the control
	            

ida_kernwin.Form.NumericInput.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

class ida_kernwin.Form.NumericLabel():
	
	        Numeric label control
	        

ida_kernwin.Form.NumericLabel.free():
	
	            Free the control
	            

ida_kernwin.Form.NumericLabel.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.NumericLabel.is_input_field():
	
	            Return True if this field acts as an input
	            

ida_kernwin.Form.Open():
	
	        Opens a widget containing the compiled form.
	        

class ida_kernwin.Form.RadGroupControl():
	
	        Radiobox group control class.
	        It holds a set of radiobox controls
	        

ida_kernwin.Form.RadGroupControl.free():
	
	            Free the control
	            

ida_kernwin.Form.RadGroupControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.RadGroupControl.is_input_field():
	
	            Return True if this field acts as an input
	            

class ida_kernwin.Form.RadGroupItemControl():
	
	        Radiobox group item control
	        

ida_kernwin.Form.RadGroupItemControl.free():
	
	            Free the control
	            

ida_kernwin.Form.RadGroupItemControl.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.RefreshField():
	
	        Refresh a field
	        @return: False - no such control
	        

ida_kernwin.Form.SetControlValue():
	
	        Set the control's value depending on its type
	        @param ctrl: Form control instance
	        @param value:
	            - embedded chooser: a 0-base indices list to select embedded chooser items
	            - multilinetext: a textctrl_info_t
	            - dropdown list: an integer designating the selection index if readonly
	                             a string designating the edit control value if not readonly
	        @return: Boolean true on success
	        

ida_kernwin.Form.SetFocusedField():
	
	        Set currently focused input field
	        @return: False - no such control
	        

ida_kernwin.Form.ShowField():
	
	        Show or hide an input field
	        @return: False - no such control
	        

class ida_kernwin.Form.StringArgument():
	
	        Argument representing a character buffer
	        

class ida_kernwin.Form.StringInput():
	
	        Base string input control class.
	        This class also constructs a StringArgument
	        

ida_kernwin.Form.StringInput.free():
	
	            Free the control
	            

ida_kernwin.Form.StringInput.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

class ida_kernwin.Form.StringLabel():
	
	        String label control
	        

ida_kernwin.Form.StringLabel.free():
	
	            Free the control
	            

ida_kernwin.Form.StringLabel.get_arg():
	
	            Control returns the parameter to be pushed on the stack
	            (Of ask_form())
	            

ida_kernwin.Form.StringLabel.is_input_field():
	
	            Return True if this field acts as an input
	            

ida_kernwin.Form.fieldtype_to_ctype():
	
	        Factory method returning a ctype class corresponding to the field type string
	        

class ida_kernwin.IDAViewWrapper():
	
	    Deprecated. Use View_Hooks instead.
	
	    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
	    might close, then re-open the same disassembly view), this wrapper doesn't
	    bring anything superior to the View_Hooks: quite the contrary, as the
	    latter is much more generic (and better maps IDA's internal model.)
	    

ida_kernwin.IDAViewWrapper.CreateGroups():
	
	        Send a request to modify the graph by creating a
	        (set of) group(s), and perform an animation.
	
	        Each object in the 'groups_infos' list must be of the format:
	        {
	          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
	          "text" : <string>                    # The synthetic text for that group
	        }
	
	        @param groups_infos: A list of objects that describe those groups.
	        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
	        

ida_kernwin.IDAViewWrapper.DelNodesInfos():
	
	        Delete the properties for the given node(s).
	
	        @param nodes: A list of node IDs
	        

ida_kernwin.IDAViewWrapper.DeleteGroups():
	
	        Send a request to delete the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param new_current: A node to focus on after the groups have been deleted
	        @return: True on success, False otherwise.
	        

ida_kernwin.IDAViewWrapper.GetNodeInfo():
	
	        Get the properties for the given node.
	
	        @param node: The index of the node.
	        @return: A tuple (bg_color, frame_color, ea, text), or None.
	        

ida_kernwin.IDAViewWrapper.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_kernwin.IDAViewWrapper.Refresh():
	
	        Refreshes the view. This causes the OnRefresh() to be called
	        

ida_kernwin.IDAViewWrapper.SetCurrentRendererType():
	
	        Set the current view's renderer.
	
	        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
	        

ida_kernwin.IDAViewWrapper.SetGroupsVisibility():
	
	        Send a request to expand/collapse the specified groups in the graph,
	        and perform an animation.
	
	        @param groups: A list of group node numbers.
	        @param expand: True to expand the group, False otherwise.
	        @param new_current: A node to focus on after the groups have been expanded/collapsed.
	        @return: True on success, False otherwise.
	        

ida_kernwin.IDAViewWrapper.SetNodeInfo():
	
	        Set the properties for the given node.
	
	        Example usage (set second nodes's bg color to red):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff0000
	          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
	
	        @param node_index: The node index.
	        @param node_info: An idaapi.node_info_t instance.
	        @param flags: An OR'ed value of NIF_* values.
	        

ida_kernwin.IDAViewWrapper.SetNodesInfos():
	
	        Set the properties for the given nodes.
	
	        Example usage (set first three nodes's bg color to purple):
	          inst = ...
	          p = idaapi.node_info_t()
	          p.bg_color = 0x00ff00ff
	          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
	
	        @param values: A dictionary of 'int -> node_info_t' objects.
	        

ida_kernwin.IDAViewWrapper.hook():
	
	        hook(self) -> bool
	        

ida_kernwin.IDAViewWrapper.unhook():
	
	        unhook(self) -> bool
	        

ida_kernwin.IDAViewWrapper.view_created():
	
	        view_created(self, view)
	        

class ida_kernwin.PluginForm():
	
	    PluginForm class.
	
	    This form can be used to host additional controls. Please check the PyQt example.
	    

ida_kernwin.PluginForm.Close():
	
	        Closes the form.
	
	        @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
	
	        @return: None
	        

ida_kernwin.PluginForm.FormToPyQtWidget():
	
	        Convert a TWidget* to a QWidget to be used by PyQt
	
	        @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
	        

ida_kernwin.PluginForm.FormToPySideWidget():
	
	        Use this method to convert a TWidget* to a QWidget to be used by PySide
	
	        @param ctx: Context. Reference to a module that already imported QtWidgets module
	        

ida_kernwin.PluginForm.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_kernwin.PluginForm.OnClose():
	
	        Called when the plugin form is closed
	
	        @return: None
	        

ida_kernwin.PluginForm.OnCreate():
	
	        This event is called when the plugin form is created.
	        The programmer should populate the form when this event is triggered.
	
	        @return: None
	        

ida_kernwin.PluginForm.QtWidgetToTWidget():
	
	        Convert a QWidget to a TWidget* to be used by IDA
	
	        @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
	        

ida_kernwin.PluginForm.Show():
	
	        Creates the form if not was not created or brings to front if it was already created
	
	        @param caption: The form caption
	        @param options: One of PluginForm.WOPN_ constants
	        

ida_kernwin.PluginForm.TWidgetToPyQtWidget():
	
	        Convert a TWidget* to a QWidget to be used by PyQt
	
	        @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
	        

ida_kernwin.PluginForm.TWidgetToPySideWidget():
	
	        Use this method to convert a TWidget* to a QWidget to be used by PySide
	
	        @param ctx: Context. Reference to a module that already imported QtWidgets module
	        

ida_kernwin.TWidget__from_ptrval__():
	
	  TWidget__from_ptrval__(ptrval) -> TWidget *
	  

class ida_kernwin.UI_Hooks():
	
	    Proxy of C++ UI_Hooks class
	    

ida_kernwin.UI_Hooks.create_desktop_widget():
	
	        create_desktop_widget(self, title, cfg) -> PyObject *
	        

ida_kernwin.UI_Hooks.current_widget_changed():
	
	        current_widget_changed(self, widget, prev_widget)
	        

ida_kernwin.UI_Hooks.database_inited():
	
	        database_inited(self, is_new_database, idc_script)
	        

ida_kernwin.UI_Hooks.debugger_menu_change():
	
	        debugger_menu_change(self, enable) -> int
	        

ida_kernwin.UI_Hooks.finish_populating_widget_popup():
	
	        finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
	
	
	        The UI is about to be done populating the TWidget's popup menu.
	        Now is a good time to call idaapi.attach_action_to_popup()
	        
	        @param widget: The widget
	        @param popup: The popup menu.
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.get_chooser_item_attrs():
	
	        get_chooser_item_attrs(self, chooser, n, attrs)
	        

ida_kernwin.UI_Hooks.get_custom_viewer_hint():
	
	        get_custom_viewer_hint(self, viewer, place) -> PyObject *
	        

ida_kernwin.UI_Hooks.get_ea_hint():
	
	        get_ea_hint(self, ea) -> PyObject *
	
	
	        The UI wants to display a simple hint for an address in the navigation band
	        
	        @param ea: The address
	        @return: String with the hint or None
	        

ida_kernwin.UI_Hooks.get_item_hint():
	
	        get_item_hint(self, ea, max_lines) -> PyObject *
	        

ida_kernwin.UI_Hooks.hook():
	
	        hook(self) -> bool
	
	
	        Creates an UI hook
	        
	        @return: Boolean true on success
	        

ida_kernwin.UI_Hooks.idcstart():
	
	        idcstart(self)
	        

ida_kernwin.UI_Hooks.idcstop():
	
	        idcstop(self)
	        

ida_kernwin.UI_Hooks.plugin_loaded():
	
	        plugin_loaded(self, plugin_info)
	        

ida_kernwin.UI_Hooks.plugin_unloading():
	
	        plugin_unloading(self, plugin_info)
	        

ida_kernwin.UI_Hooks.populating_widget_popup():
	
	        populating_widget_popup(self, widget, popup_handle, ctx=None)
	
	
	        The UI is populating the TWidget's popup menu.
	        Now is a good time to call idaapi.attach_action_to_popup()
	        
	        @param widget: The widget
	        @param popup: The popup menu.
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.postprocess_action():
	
	        postprocess_action(self)
	
	
	        An ida ui action has been handled
	        
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.preprocess_action():
	
	        preprocess_action(self, name)
	
	
	        IDA ui is about to handle a user action
	        
	        @param name: ui action name
	                     (these names can be looked up in ida[tg]ui.cfg)
	        @return: 0-ok, nonzero - a plugin has handled the action
	        

ida_kernwin.UI_Hooks.range():
	
	        range(self)
	        

ida_kernwin.UI_Hooks.ready_to_run():
	
	        ready_to_run(self)
	        

ida_kernwin.UI_Hooks.resume():
	
	        resume(self)
	        

ida_kernwin.UI_Hooks.saved():
	
	        saved(self)
	
	
	        The kernel has saved the database.
	        
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.saving():
	
	        saving(self)
	
	
	        The kernel is saving the database.
	        
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.screen_ea_changed():
	
	        screen_ea_changed(self, ea, prev_ea)
	        

ida_kernwin.UI_Hooks.suspend():
	
	        suspend(self)
	        

ida_kernwin.UI_Hooks.term():
	
	        term(self)
	
	
	        IDA is terminated and the database is already closed.
	        The UI may close its windows in this callback.
	        

ida_kernwin.UI_Hooks.unhook():
	
	        unhook(self) -> bool
	
	
	        Removes the UI hook
	        @return: Boolean true on success
	        

ida_kernwin.UI_Hooks.updated_actions():
	
	        updated_actions(self)
	
	
	        The UI is done updating actions.
	        
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.updating_actions():
	
	        updating_actions(self, ctx)
	
	
	        The UI is about to batch-update some actions.
	        
	        @param ctx: The action_update_ctx_t instance
	        @return: Ignored
	        

ida_kernwin.UI_Hooks.widget_closing():
	
	        widget_closing(self, widget)
	        

ida_kernwin.UI_Hooks.widget_invisible():
	
	        widget_invisible(self, widget)
	        

ida_kernwin.UI_Hooks.widget_visible():
	
	        widget_visible(self, widget)
	        

class ida_kernwin.View_Hooks():
	
	    Proxy of C++ View_Hooks class
	    

ida_kernwin.View_Hooks.hook():
	
	        hook(self) -> bool
	        

ida_kernwin.View_Hooks.unhook():
	
	        unhook(self) -> bool
	        

ida_kernwin.View_Hooks.view_activated():
	
	        view_activated(self, view)
	        

ida_kernwin.View_Hooks.view_click():
	
	        view_click(self, view, event)
	        

ida_kernwin.View_Hooks.view_close():
	
	        view_close(self, view)
	        

ida_kernwin.View_Hooks.view_created():
	
	        view_created(self, view)
	        

ida_kernwin.View_Hooks.view_curpos():
	
	        view_curpos(self, view)
	        

ida_kernwin.View_Hooks.view_dblclick():
	
	        view_dblclick(self, view, event)
	        

ida_kernwin.View_Hooks.view_deactivated():
	
	        view_deactivated(self, view)
	        

ida_kernwin.View_Hooks.view_keydown():
	
	        view_keydown(self, view, key, state)
	        

ida_kernwin.View_Hooks.view_loc_changed():
	
	        view_loc_changed(self, view, now, was)
	        

ida_kernwin.View_Hooks.view_mouse_moved():
	
	        view_mouse_moved(self, view, event)
	        

ida_kernwin.View_Hooks.view_mouse_over():
	
	        view_mouse_over(self, view, event)
	        

ida_kernwin.View_Hooks.view_switched():
	
	        view_switched(self, view, rt)
	        

class ida_kernwin.action_ctx_base_t():
	
	    Proxy of C++ action_ctx_base_t class
	    

ida_kernwin.action_ctx_base_t.action:
	action_ctx_base_t_action_get(self) -> char const *

ida_kernwin.action_ctx_base_t.chooser_selection:
	action_ctx_base_t_chooser_selection_get(self) -> sizevec_t *

ida_kernwin.action_ctx_base_t.cur_ea:
	action_ctx_base_t_cur_ea_get(self) -> ea_t

ida_kernwin.action_ctx_base_t.cur_enum:
	action_ctx_base_t_cur_enum_get(self) -> enum_t

ida_kernwin.action_ctx_base_t.cur_extracted_ea:
	action_ctx_base_t_cur_extracted_ea_get(self) -> ea_t

ida_kernwin.action_ctx_base_t.cur_fchunk:
	action_ctx_base_t_cur_fchunk_get(self) -> func_t *

ida_kernwin.action_ctx_base_t.cur_flags:
	action_ctx_base_t_cur_flags_get(self) -> uint32

ida_kernwin.action_ctx_base_t.cur_func:
	action_ctx_base_t_cur_func_get(self) -> func_t *

ida_kernwin.action_ctx_base_t.cur_seg:
	action_ctx_base_t_cur_seg_get(self) -> segment_t *

ida_kernwin.action_ctx_base_t.cur_strmem:
	action_ctx_base_t_cur_strmem_get(self) -> member_t *

ida_kernwin.action_ctx_base_t.cur_struc:
	action_ctx_base_t_cur_struc_get(self) -> struc_t *

ida_kernwin.action_ctx_base_t.focus:
	action_ctx_base_t_focus_get(self) -> TWidget *

ida_kernwin.action_ctx_base_t.form:
	
	        _get_form(self) -> TWidget *
	        

ida_kernwin.action_ctx_base_t.form_title:
	
	        _get_form_title(self) -> qstring
	        

ida_kernwin.action_ctx_base_t.form_type:
	
	        _get_form_type(self) -> twidget_type_t
	        

ida_kernwin.action_ctx_base_t.has_flag():
	
	        has_flag(self, flag) -> bool
	        

ida_kernwin.action_ctx_base_t.regname:
	action_ctx_base_t_regname_get(self) -> char const *

ida_kernwin.action_ctx_base_t.reserved:
	action_ctx_base_t_reserved_get(self) -> void *

ida_kernwin.action_ctx_base_t.reset():
	
	        reset(self)
	        

ida_kernwin.action_ctx_base_t.widget:
	action_ctx_base_t_widget_get(self) -> TWidget *

ida_kernwin.action_ctx_base_t.widget_title:
	action_ctx_base_t_widget_title_get(self) -> qstring *

ida_kernwin.action_ctx_base_t.widget_type:
	action_ctx_base_t_widget_type_get(self) -> twidget_type_t

class ida_kernwin.action_desc_t():
	
	    Proxy of C++ action_desc_t class
	    

ida_kernwin.action_desc_t.cb:
	action_desc_t_cb_get(self) -> int

ida_kernwin.action_desc_t.flags:
	action_desc_t_flags_get(self) -> int

ida_kernwin.action_desc_t.icon:
	action_desc_t_icon_get(self) -> int

ida_kernwin.action_desc_t.label:
	action_desc_t_label_get(self) -> char const *

ida_kernwin.action_desc_t.name:
	action_desc_t_name_get(self) -> char const *

ida_kernwin.action_desc_t.owner:
	action_desc_t_owner_get(self) -> plugin_t const *

ida_kernwin.action_desc_t.shortcut:
	action_desc_t_shortcut_get(self) -> char const *

ida_kernwin.action_desc_t.tooltip:
	action_desc_t_tooltip_get(self) -> char const *

ida_kernwin.activate_widget():
	
	  activate_widget(widget, take_focus)
	
	
	  Activate widget (only gui version) ( 'ui_activate_widget' ).
	  
	  @param widget: existing widget to display (C++: TWidget *)
	  @param take_focus: give focus to given widget (C++: bool)
	  

ida_kernwin.add_hotkey():
	
	  add_hotkey(hotkey, pyfunc) -> PyObject *
	
	
	  Associates a function call with a hotkey.
	  Callable pyfunc will be called each time the hotkey is pressed
	  
	  @param hotkey: The hotkey
	  @param pyfunc: Callable
	  
	  @return: Context object on success or None on failure.
	  

ida_kernwin.add_idc_hotkey():
	
	  add_idc_hotkey(hotkey, idcfunc) -> int
	
	
	  Add hotkey for IDC function ( 'ui_add_idckey' ).
	  
	  @param hotkey: hotkey name (C++: const char *)
	  @param idcfunc: IDC function name (C++: const char *)
	  @return: IDC hotkey error codes
	  

ida_kernwin.add_spaces():
	
	  add_spaces(str, bufsize, len) -> char *
	
	
	  Add space characters to the colored string so that its length will be
	  at least 'len' characters. Don't trim the string if it is longer than
	  'len'.
	  
	  @param str: pointer to colored string to modify (may not be NULL)
	              (C++: char *)
	  @param bufsize: size of the buffer with the string (C++: size_t)
	  @param len: the desired length of the string (C++: ssize_t)
	  @return: pointer to the end of input string
	  

ida_kernwin.addon_count():
	
	  addon_count() -> int
	
	
	  Get number of installed addons.
	  

class ida_kernwin.addon_info_t():
	
	    Proxy of C++ addon_info_t class
	    

ida_kernwin.addon_info_t.cb:
	addon_info_t_cb_get(self) -> size_t

ida_kernwin.addon_info_t.custom_data:
	addon_info_t_custom_data_get(self) -> void const *

ida_kernwin.addon_info_t.custom_size:
	addon_info_t_custom_size_get(self) -> size_t

ida_kernwin.addon_info_t.freeform:
	addon_info_t_freeform_get(self) -> char const *

ida_kernwin.addon_info_t.id:
	addon_info_t_id_get(self) -> char const *

ida_kernwin.addon_info_t.name:
	addon_info_t_name_get(self) -> char const *

ida_kernwin.addon_info_t.producer:
	addon_info_t_producer_get(self) -> char const *

ida_kernwin.addon_info_t.url:
	addon_info_t_url_get(self) -> char const *

ida_kernwin.addon_info_t.version:
	addon_info_t_version_get(self) -> char const *

ida_kernwin.analyzer_options():
	
	  analyzer_options()
	
	
	  Allow the user to set analyzer options. (show a dialog box) (
	  'ui_analyzer_options' )
	  

ida_kernwin.ask_buttons():
	
	  ask_buttons(Yes, No, Cancel, deflt, format) -> int
	
	
	  Display a dialog box and get choice from maximum three possibilities (
	  'ui_ask_buttons' ).for all buttons:use "" or NULL to take the default
	  name for the button.use 'format' to hide the cancel button
	  
	  @param Yes: text for the first button (C++: const char *)
	  @param No: text for the second button (C++: const char *)
	  @param Cancel: text for the third button (C++: const char *)
	  @param deflt: default choice: one of  Button IDs (C++: int)
	  @param format: printf-style format string for question. It may have
	                 some prefixes, see below. (C++: const char *)
	  @return: one of  Button IDs  specifying the selected button (Esc key
	           returns Cancel/3rd button value)
	  

ida_kernwin.ask_file():
	
	  ask_file(for_saving, defval, format) -> char *
	  

ida_kernwin.ask_for_feedback():
	
	  ask_for_feedback(format)
	
	
	  Show a message box asking to send the input file tosupport@hex-
	  rays.com.
	  
	  @param format: the reason why the input file is bad (C++: const char
	                 *)
	  

ida_kernwin.ask_str():
	
	  ask_str(defval, hist, prompt) -> PyObject *
	
	
	  Asks for a long text
	  
	  @param hist:   history id
	  @param defval: The default value
	  @param prompt: The prompt value
	  @return: None or the entered string
	  

ida_kernwin.ask_text():
	
	  ask_text(max_size, defval, prompt) -> PyObject *
	
	
	  Asks for a long text
	  
	  @param max_size: Maximum text length, 0 for unlimited
	  @param defval: The default value
	  @param prompt: The prompt value
	  @return: None or the entered string
	  

ida_kernwin.ask_yn():
	
	  ask_yn(deflt, format) -> int
	
	
	  Display a dialog box and get choice from "Yes", "No", "Cancel".
	  
	  @param deflt: default choice: one of  Button IDs (C++: int)
	  @param format: The question in printf() style format (C++: const char
	                 *)
	  @return: the selected button (one of  Button IDs ). Esc key returns
	           ASKBTN_CANCEL .
	  

ida_kernwin.attach_action_to_menu():
	
	  attach_action_to_menu(menupath, name, flags) -> bool
	
	
	  Attach a previously-registered action to the menu (
	  'ui_attach_action_to_menu' ).You should not change top level menu, or
	  the Edit,Plugins submenus If you want to modify the debugger menu, do
	  it at the ui_debugger_menu_change event (ida might destroy your menu
	  item if you do it elsewhere).
	  
	  @param menupath: path to the menu item after or before which the
	                   insertion will take place.      Example:
	                   Debug/StartProcess Whitespace, punctuation are
	                   ignored. It is allowed to specify only the prefix of
	                   the menu item. Comparison is case insensitive.
	                   menupath may start with the following prefixes: [S] -
	                   modify the main menu of the structure window [E] -
	                   modify the main menu of the enum window (C++: const
	                   char *)
	  @param name: the action name (C++: const char *)
	  @param flags: a combination of  Set menu flags , to determine menu
	                item position (C++: int)
	  @return: success
	  

ida_kernwin.attach_action_to_popup():
	
	  attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
	
	
	  Insert a previously-registered action into the widget's popup menu (
	  'ui_attach_action_to_popup' ). This function has two "modes": 'single-
	  shot', and 'permanent'.
	  
	  @param widget: target widget (C++: TWidget *)
	  @param popup_handle: target popup menu   if non-NULL, the action is
	                       added to this popup menu invocation (i.e.,
	                       'single-shot') if NULL, the action is added to a
	                       list of actions that should always be present in
	                       context menus for this widget (i.e.,
	                       'permanent'.) (C++: TPopupMenu *)
	  @param name: action name (C++: const char *)
	  @param popuppath: can be NULL (C++: const char *)
	  @param flags: a combination of SETMENU_ flags (see  Set menu flags )
	                (C++: int)
	  @return: success
	  

ida_kernwin.attach_action_to_toolbar():
	
	  attach_action_to_toolbar(toolbar_name, name) -> bool
	
	
	  Attach an action to an existing toolbar (
	  'ui_attach_action_to_toolbar' ).
	  
	  @param toolbar_name: the name of the toolbar (C++: const char *)
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.attach_dynamic_action_to_popup():
	
	  attach_dynamic_action_to_popup(widget, popup_handle, desc, popuppath=None, flags=0) -> bool
	
	
	  Create & insert an action into the widget's popup menu (
	  'ui_attach_dynamic_action_to_popup' ). 'action_desc_t::handler' for
	  'desc' must be instantiated using 'new', as it will be 'delete'd when
	  the action is unregistered.
	  
	  @param widget: target widget (C++: TWidget *)
	  @param popup_handle: target popup (C++: TPopupMenu *)
	  @param desc: created with  DYNACTION_DESC_LITERAL (C++: const
	               action_desc_t  &)
	  @param popuppath: can be NULL (C++: const char *)
	  @param flags: a combination of SETMENU_ constants (see  Set menu flags
	                ) (C++: int)
	  @return: success
	  

ida_kernwin.banner():
	
	  banner(wait) -> bool
	
	
	  Show a banner dialog box ( 'ui_banner' ).
	  
	  @param wait: time to wait before closing (C++: int)
	  

ida_kernwin.beep():
	
	  beep(beep_type=beep_default)
	
	
	  Issue a beeping sound ( 'ui_beep' ).
	  
	  @param beep_type: beep_t (C++: beep_t)
	  

ida_kernwin.call_nav_colorizer():
	
	  call_nav_colorizer(col, ea, nbytes) -> uint32
	
	
	  To be used with the IDA-provided colorizer, that is
	  returned as result of the first call to set_nav_colorizer().
	  
	  This is a trivial trampoline, so that SWIG can generate a
	  wrapper that will do the types checking.
	  

ida_kernwin.cancel_exec_request():
	
	  cancel_exec_request(req_id) -> bool
	
	
	  Try to cancel an asynchronous exec request ( 'ui_cancel_exec_request'
	  ).
	  
	  @param req_id: request id (C++: int)
	  

ida_kernwin.choose_activate():
	
	  choose_activate(self)
	  

ida_kernwin.choose_close():
	
	  choose_close(self)
	  

ida_kernwin.choose_create():
	
	  choose_create(self) -> int
	  

ida_kernwin.choose_entry():
	
	  choose_entry(title) -> ea_t
	
	
	  Choose an entry point ( 'ui_choose' , 'chtype_entry' ).
	  
	  @param title: chooser title (C++: const char *)
	  @return: ea of selected entry point,  BADADDR  if none selected
	  

ida_kernwin.choose_enum():
	
	  choose_enum(title, default_id) -> enum_t
	
	
	  Choose an enum ( 'ui_choose' , 'chtype_enum' ).
	  
	  @param title: chooser title (C++: const char *)
	  @param default_id: id of enum to select by default (C++: enum_t)
	  @return: enum id of selected enum,  BADNODE  if none selected
	  

ida_kernwin.choose_enum_by_value():
	
	  choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
	
	
	  Choose an enum, restricted by value & size ( 'ui_choose' ,
	  'chtype_enum_by_value_and_size' ). If the given value cannot be found
	  initially, this function will ask if the user would like to import a
	  standard enum.
	  
	  @param title: chooser title (C++: const char *)
	  @param default_id: id of enum to select by default (C++: enum_t)
	  @param value: value to search for (C++: uval_t)
	  @param nbytes: size of value (C++: int)
	  @return: enum id of selected (or imported) enum,  BADNODE  if none was
	           found
	  

ida_kernwin.choose_find():
	
	  choose_find(title) -> PyObject *
	  

ida_kernwin.choose_func():
	
	  choose_func(title, default_ea) -> func_t *
	
	
	  Choose a function ( 'ui_choose' , 'chtype_func' ).
	  
	  @param title: chooser title (C++: const char *)
	  @param default_ea: ea of function to select by default (C++: ea_t)
	  @return: pointer to function that was selected, NULL if none selected
	  

ida_kernwin.choose_get_widget():
	
	  choose_get_widget(self) -> TWidget *
	  

ida_kernwin.choose_idasgn():
	
	  choose_idasgn() -> PyObject *
	
	
	  Opens the signature chooser
	  
	  @return: None or the selected signature name
	  

ida_kernwin.choose_name():
	
	  choose_name(title) -> ea_t
	
	
	  Choose a name ( 'ui_choose' , 'chtype_name' ).
	  
	  @param title: chooser title (C++: const char *)
	  @return: ea of selected name,  BADADDR  if none selected
	  

ida_kernwin.choose_refresh():
	
	  choose_refresh(self)
	  

ida_kernwin.choose_segm():
	
	  choose_segm(title, default_ea) -> segment_t *
	
	
	  Choose a segment ( 'ui_choose' , 'chtype_segm' ).
	  
	  @param title: chooser title (C++: const char *)
	  @param default_ea: ea of segment to select by default (C++: ea_t)
	  @return: pointer to segment that was selected, NULL if none selected
	  

ida_kernwin.choose_srcp():
	
	  choose_srcp(title) -> sreg_range_t *
	
	
	  Choose a segment register change point ( 'ui_choose' , 'chtype_srcp'
	  ).
	  
	  @param title: chooser title (C++: const char *)
	  @return: pointer to segment register range of selected change point,
	           NULL if none selected
	  

ida_kernwin.choose_stkvar_xref():
	
	  choose_stkvar_xref(pfn, mptr) -> ea_t
	
	
	  Choose an xref to a stack variable ( 'ui_choose' , 'chtype_name' ).
	  
	  @param pfn: function (C++: func_t  *)
	  @param mptr: variable (C++: member_t  *)
	  @return: ea of the selected xref, BADADDR if none selected
	  

ida_kernwin.choose_struc():
	
	  choose_struc(title) -> struc_t *
	
	
	  Choose a structure ( 'ui_choose' , 'chtype_segm' ).
	  
	  @param title: chooser title; (C++: const char *)
	  @return: pointer to structure that was selected, NULL if none selected
	  

ida_kernwin.choose_til():
	
	  choose_til() -> bool
	
	
	  Choose a type library ( 'ui_choose' , 'chtype_idatil' ).
	  

ida_kernwin.choose_xref():
	
	  choose_xref(to) -> ea_t
	
	
	  Choose an xref to an address ( 'ui_choose' , 'chtype_xref' ).
	  
	  @param to: referenced address (C++: ea_t)
	  @return: ea of selected xref, BADADDR if none selected
	  

class ida_kernwin.chooser_item_attrs_t():
	
	    Proxy of C++ chooser_item_attrs_t class
	    

ida_kernwin.chooser_item_attrs_t.color:
	chooser_item_attrs_t_color_get(self) -> bgcolor_t

ida_kernwin.chooser_item_attrs_t.flags:
	chooser_item_attrs_t_flags_get(self) -> int

ida_kernwin.chooser_item_attrs_t.reset():
	
	        reset(self)
	        

ida_kernwin.clear_refresh_request():
	
	  clear_refresh_request(mask)
	  

class ida_kernwin.cli_t():
	
	    cli_t wrapper class.
	
	    This class allows you to implement your own command line interface handlers.
	    

ida_kernwin.cli_t.register():
	
	        Registers the CLI.
	
	        @param flags: Feature bits. No bits are defined yet, must be 0
	        @param sname: Short name (displayed on the button)
	        @param lname: Long name (displayed in the menu)
	        @param hint:  Hint for the input line
	
	        @return Boolean: True-Success, False-Failed
	        

ida_kernwin.cli_t.unregister():
	
	        Unregisters the CLI (if it was registered)
	        

ida_kernwin.close_chooser():
	
	  close_chooser(title) -> bool
	
	
	  Close a non-modal chooser ( 'ui_close_chooser' ).
	  
	  @param title: window title of chooser to close (C++: const char *)
	  @return: success
	  

ida_kernwin.close_widget():
	
	  close_widget(widget, options)
	
	
	  Close widget ( 'ui_close_widget' , only gui version).
	  
	  @param widget: pointer to the widget to close (C++: TWidget *)
	  @param options: Form close flags (C++: int)
	  

ida_kernwin.clr_cancelled():
	
	  clr_cancelled()
	
	
	  Clear "Cancelled" flag ( 'ui_clr_cancelled' )
	  

ida_kernwin.create_code_viewer():
	
	  create_code_viewer(custview, flags=0, parent=None) -> TWidget *
	
	
	  Create a code viewer ( 'ui_create_code_viewer' ). A code viewer
	  contains on the left side a widget representing the line numbers, and
	  on the right side, the child widget passed as parameter. It will
	  inherit its title from the child widget.
	  
	  @param custview: the custom view to be added (C++: TWidget *)
	  @param flags: Code viewer flags (C++: int)
	  @param parent: widget to contain the new code viewer (C++: TWidget *)
	  

ida_kernwin.create_empty_widget():
	
	  create_empty_widget(title, icon=-1) -> TWidget *
	
	
	  Create an empty widget, serving as a container for custom user widgets
	  
	  @param title (C++: const char *)
	  @param icon (C++: int)
	  

ida_kernwin.create_menu():
	
	  create_menu(name, label, before=None) -> bool
	
	
	  Create a menu with the given name, label and optional position
	  
	  @param name: name of menu (must be unique) (C++: const char *)
	  @param label: label of menu (C++: const char *)
	  @param before: if non-NULL, the menu before which the new menu will be
	                 inserted (C++: const char *)
	  @return: success
	  

ida_kernwin.create_toolbar():
	
	  create_toolbar(name, label, before=None, flags=0) -> bool
	
	
	  Create a toolbar with the given name, label and optional position
	  
	  @param name: name of toolbar (must be unique) (C++: const char *)
	  @param label: label of toolbar (C++: const char *)
	  @param before: if non-NULL, the toolbar before which the new toolbar
	                 will be inserted (C++: const char *)
	  @param flags: a combination of  create toolbar flags , to determine
	                toolbar position (C++: int)
	  @return: success
	  

ida_kernwin.custom_viewer_jump():
	
	  custom_viewer_jump(v, loc, flags) -> bool
	
	
	  Append 'loc' to the viewer's history, and cause the viewer to display
	  it.
	  
	  @param v: (TWidget *) (C++: TWidget *)
	  @param loc: (const  lochist_entry_t  &) (C++: const  lochist_entry_t
	              &)
	  @param flags: (uint32) or'ed combination of CVNF_* values (C++:
	                uint32)
	  @return: success
	  

ida_kernwin.del_hotkey():
	
	  del_hotkey(pyctx) -> bool
	
	
	  Deletes a previously registered function hotkey
	  
	  @param ctx: Hotkey context previously returned by add_hotkey()
	  
	  @return: Boolean.
	  

ida_kernwin.del_idc_hotkey():
	
	  del_idc_hotkey(hotkey) -> bool
	
	
	  Delete IDC function hotkey ( 'ui_del_idckey' ).
	  
	  @param hotkey: hotkey name (C++: const char *)
	  

ida_kernwin.delete_menu():
	
	  delete_menu(name) -> bool
	
	
	  Delete an existing menu
	  
	  @param name: name of menu (C++: const char *)
	  @return: success
	  

ida_kernwin.delete_toolbar():
	
	  delete_toolbar(name) -> bool
	
	
	  Delete an existing toolbar
	  
	  @param name: name of toolbar (C++: const char *)
	  @return: success
	  

ida_kernwin.detach_action_from_menu():
	
	  detach_action_from_menu(menupath, name) -> bool
	
	
	  Detach an action from the menu ( 'ui_detach_action_from_menu' ).
	  
	  @param menupath: path to the menu item (C++: const char *)
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.detach_action_from_popup():
	
	  detach_action_from_popup(widget, name) -> bool
	
	
	  Remove a previously-registered action, from the list of 'permanent'
	  context menu actions for this widget ( 'ui_detach_action_from_popup'
	  ). This only makes sense if the action has been added to 'widget's
	  list of permanent popup actions by calling attach_action_to_popup in
	  'permanent' mode.
	  
	  @param widget: target widget (C++: TWidget *)
	  @param name: action name (C++: const char *)
	  

ida_kernwin.detach_action_from_toolbar():
	
	  detach_action_from_toolbar(toolbar_name, name) -> bool
	
	
	  Detach an action from the toolbar ( 'ui_detach_action_from_toolbar' ).
	  
	  @param toolbar_name: the name of the toolbar (C++: const char *)
	  @param name: the action name (C++: const char *)
	  @return: success
	  

class ida_kernwin.disasm_line_t():
	
	    Proxy of C++ disasm_line_t class
	    

ida_kernwin.disasm_line_t.at:
	disasm_line_t_at_get(self) -> place_t

ida_kernwin.disasm_line_t.bg_color:
	disasm_line_t_bg_color_get(self) -> bgcolor_t

ida_kernwin.disasm_line_t.is_default:
	disasm_line_t_is_default_get(self) -> bool

ida_kernwin.disasm_line_t.line:
	disasm_line_t_line_get(self) -> qstring *

ida_kernwin.disasm_line_t.prefix_color:
	disasm_line_t_prefix_color_get(self) -> color_t

class ida_kernwin.disasm_text_t():
	
	    Proxy of C++ qvector<(disasm_line_t)> class
	    

ida_kernwin.disasm_text_t.at():
	
	        at(self, _idx) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.begin():
	
	        begin(self) -> disasm_line_t
	        begin(self) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_kernwin.disasm_text_t.clear():
	
	        clear(self)
	        

ida_kernwin.disasm_text_t.empty():
	
	        empty(self) -> bool
	        

ida_kernwin.disasm_text_t.end():
	
	        end(self) -> disasm_line_t
	        end(self) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.erase():
	
	        erase(self, it) -> disasm_line_t
	        erase(self, first, last) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.extract():
	
	        extract(self) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.grow():
	
	        grow(self, x=disasm_line_t())
	        

ida_kernwin.disasm_text_t.inject():
	
	        inject(self, s, len)
	        

ida_kernwin.disasm_text_t.insert():
	
	        insert(self, it, x) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.pop_back():
	
	        pop_back(self)
	        

ida_kernwin.disasm_text_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> disasm_line_t
	        

ida_kernwin.disasm_text_t.qclear():
	
	        qclear(self)
	        

ida_kernwin.disasm_text_t.reserve():
	
	        reserve(self, cnt)
	        

ida_kernwin.disasm_text_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_kernwin.disasm_text_t.size():
	
	        size(self) -> size_t
	        

ida_kernwin.disasm_text_t.swap():
	
	        swap(self, r)
	        

ida_kernwin.disasm_text_t.truncate():
	
	        truncate(self)
	        

ida_kernwin.display_copyright_warning():
	
	  display_copyright_warning() -> bool
	
	
	  Display copyright warning ( 'ui_copywarn' ).
	  
	  @return: yes/no
	  

ida_kernwin.display_widget():
	
	  display_widget(widget, options)
	
	
	  Display a widget
	  
	  @param widget: widget to display (C++: TWidget *)
	  @param options: Widget open flags (C++: int)
	  

ida_kernwin.ea2str():
	
	  ea2str(ea) -> size_t
	
	
	  Convert linear address to UTF-8 string.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_kernwin.ea_viewer_history_push_and_jump():
	
	  ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
	
	
	  Push current location in the history and jump to the given location (
	  'ui_ea_viewer_history_push_and_jump' ). This will jump in the given ea
	  viewer and also in other synchronized views.
	  
	  @param v: ea viewer (C++: TWidget *)
	  @param ea: jump destination (C++: ea_t)
	  @param x: coords on screen (C++: int)
	  @param y: coords on screen (C++: int)
	  @param lnnum: desired line number of given address (C++: int)
	  

ida_kernwin.enable_chooser_item_attrs():
	
	  enable_chooser_item_attrs(chooser_caption, enable) -> bool
	
	
	  Enable item-specific attributes for chooser items (
	  'ui_enable_chooser_item_attrs' ). For example: color list items
	  differently depending on a criterium.If enabled, the chooser will
	  generate ui_get_chooser_item_attrsevents that can be intercepted by a
	  plugin to modify the item attributes.This event is generated only in
	  the GUI version of IDA.Specifying 'CH_ATTRS' bit at the chooser
	  creation time has the same effect.
	  
	  @param chooser_caption (C++: const char *)
	  @param enable (C++: bool)
	  @return: success
	  

class ida_kernwin.enumplace_t():
	
	    Proxy of C++ enumplace_t class
	    

ida_kernwin.enumplace_t._print():
	
	        _print(self, out_buf, ud)
	        

ida_kernwin.enumplace_t.adjust():
	
	        adjust(self, ud)
	        

ida_kernwin.enumplace_t.as_enumplace_t():
	
	        as_enumplace_t(p) -> enumplace_t
	        

ida_kernwin.enumplace_t.as_idaplace_t():
	
	        as_idaplace_t(p) -> idaplace_t
	        

ida_kernwin.enumplace_t.as_simpleline_place_t():
	
	        as_simpleline_place_t(p) -> simpleline_place_t
	        

ida_kernwin.enumplace_t.as_structplace_t():
	
	        as_structplace_t(p) -> structplace_t
	        

ida_kernwin.enumplace_t.beginning():
	
	        beginning(self, ud) -> bool
	        

ida_kernwin.enumplace_t.bmask:
	enumplace_t_bmask_get(self) -> bmask_t

ida_kernwin.enumplace_t.clone():
	
	        clone(self) -> place_t
	        

ida_kernwin.enumplace_t.compare():
	
	        compare(self, t2) -> int
	        

ida_kernwin.enumplace_t.copyfrom():
	
	        copyfrom(self, _from)
	        

ida_kernwin.enumplace_t.ending():
	
	        ending(self, ud) -> bool
	        

ida_kernwin.enumplace_t.enter():
	
	        enter(self, arg2) -> place_t
	        

ida_kernwin.enumplace_t.generate():
	
	        generate(self, ud, maxsize) -> PyObject *
	        

ida_kernwin.enumplace_t.id():
	
	        id(self) -> int
	        

ida_kernwin.enumplace_t.idx:
	enumplace_t_idx_get(self) -> size_t

ida_kernwin.enumplace_t.leave():
	
	        leave(self, arg2)
	        

ida_kernwin.enumplace_t.lnnum:
	place_t_lnnum_get(self) -> int

ida_kernwin.enumplace_t.makeplace():
	
	        makeplace(self, ud, x, lnnum) -> place_t
	        

ida_kernwin.enumplace_t.name():
	
	        name(self) -> char const *
	        

ida_kernwin.enumplace_t.next():
	
	        next(self, ud) -> bool
	        

ida_kernwin.enumplace_t.prev():
	
	        prev(self, ud) -> bool
	        

ida_kernwin.enumplace_t.rebase():
	
	        rebase(self, arg2) -> bool
	        

ida_kernwin.enumplace_t.serial:
	enumplace_t_serial_get(self) -> uchar

ida_kernwin.enumplace_t.toea():
	
	        toea(self) -> ea_t
	        

ida_kernwin.enumplace_t.touval():
	
	        touval(self, ud) -> uval_t
	        

ida_kernwin.enumplace_t.value:
	enumplace_t_value_get(self) -> uval_t

ida_kernwin.error():
	
	  error(format)
	
	
	  Display a fatal message in a message box and quit IDA
	  
	  @param format: message to print
	  

ida_kernwin.execute_sync():
	
	  execute_sync(py_callable, reqf) -> int
	
	
	  Executes a function in the context of the main thread.
	  If the current thread not the main thread, then the call is queued and
	  executed afterwards.
	  
	  @param callable: A python callable object, must return an integer value
	  @param reqf: one of MFF_ flags
	  @return: -1 or the return value of the callable
	  

ida_kernwin.execute_ui_requests():
	
	  execute_ui_requests(py_list) -> bool
	
	
	  Inserts a list of callables into the UI message processing queue.
	  When the UI is ready it will call one callable.
	  A callable can request to be called more than once if it returns True.
	  
	  @param callable_list: A list of python callable objects.
	  @note: A callable should return True if it wants to be called more than once.
	  @return: Boolean. False if the list contains a non callabale item
	  

ida_kernwin.find_widget():
	
	  find_widget(caption) -> TWidget *
	
	
	  Find widget with the specified caption (only gui version) (
	  'ui_find_widget' ). NB: this callback works only with the tabbed
	  widgets!
	  
	  @param caption: title of tab, or window title if widget is not tabbed
	                  (C++: const char *)
	  @return: pointer to the TWidget, NULL if none is found
	  

ida_kernwin.formchgcbfa_close():
	
	  formchgcbfa_close(p_fa, close_normally)
	  

ida_kernwin.formchgcbfa_enable_field():
	
	  formchgcbfa_enable_field(p_fa, fid, enable) -> bool
	  

ida_kernwin.formchgcbfa_get_field_value():
	
	  formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *
	  

ida_kernwin.formchgcbfa_get_focused_field():
	
	  formchgcbfa_get_focused_field(p_fa) -> int
	  

ida_kernwin.formchgcbfa_move_field():
	
	  formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool
	  

ida_kernwin.formchgcbfa_refresh_field():
	
	  formchgcbfa_refresh_field(p_fa, fid)
	  

ida_kernwin.formchgcbfa_set_field_value():
	
	  formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool
	  

ida_kernwin.formchgcbfa_set_focused_field():
	
	  formchgcbfa_set_focused_field(p_fa, fid) -> bool
	  

ida_kernwin.formchgcbfa_show_field():
	
	  formchgcbfa_show_field(p_fa, fid, show) -> bool
	  

ida_kernwin.free_custom_icon():
	
	  free_custom_icon(icon_id)
	
	
	  Frees an icon loaded with load_custom_icon()
	  

ida_kernwin.gen_disasm_text():
	
	  gen_disasm_text(text, ea1, ea2, truncate_lines)
	
	
	  Generate disassembly text for a range.
	  
	  @param text: result (C++: text_t  &)
	  @param ea1: start address (C++: ea_t)
	  @param ea2: end address (C++: ea_t)
	  @param truncate_lines: (on  idainfo::margin ) (C++: bool)
	  

ida_kernwin.get_action_checkable():
	
	  get_action_checkable(name) -> bool
	
	
	  Get an action's checkability ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_checked():
	
	  get_action_checked(name) -> bool
	
	
	  Get an action's checked state ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_icon():
	
	  get_action_icon(name) -> bool
	
	
	  Get an action's icon ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_label():
	
	  get_action_label(name) -> bool
	
	
	  Get an action's label ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_shortcut():
	
	  get_action_shortcut(name) -> bool
	
	
	  Get an action's shortcut ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_state():
	
	  get_action_state(name) -> bool
	
	
	  Get an action's state ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_tooltip():
	
	  get_action_tooltip(name) -> bool
	
	
	  Get an action's tooltip ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_action_visibility():
	
	  get_action_visibility(name) -> bool
	
	
	  Get an action's visibility ( 'ui_get_action_attr' ).
	  
	  @param name: the action name (C++: const char *)
	  @return: success
	  

ida_kernwin.get_active_modal_widget():
	
	  get_active_modal_widget() -> TWidget *
	
	
	  Get the current, active modal TWidget instance. Note that in this
	  context, the "wait dialog" is not considered: this function will
	  return NULL even if it is currently shown.
	  
	  @return: TWidget * the active modal widget, or NULL
	  

ida_kernwin.get_addon_info():
	
	  get_addon_info(id, info) -> bool
	
	
	  Get info about a registered addon with a given product code. info->cb
	  must be valid! NB: all pointers are invalidated by next call to
	  register_addon or get_addon_info
	  
	  @param id (C++: const char *)
	  @param info (C++: addon_info_t  *)
	  @return: false if not found
	  

ida_kernwin.get_addon_info_idx():
	
	  get_addon_info_idx(index, info) -> bool
	
	
	  Get info about a registered addon with specific index. info->cb must
	  be valid! NB: all pointers are invalidated by next call to
	  register_addon or get_addon_info
	  
	  @param index (C++: int)
	  @param info (C++: addon_info_t  *)
	  @return: false if index is out of range
	  

ida_kernwin.get_chooser_data():
	
	  get_chooser_data(chooser_caption, n) -> PyObject *
	
	
	  Get the text corresponding to the index N in the chooser data. Use -1
	  to get the header.
	  
	  @param chooser_caption (C++: const char *)
	  @param n (C++: int)
	  

ida_kernwin.get_chooser_obj():
	
	  get_chooser_obj(chooser_caption) -> void *
	
	
	  Get the underlying object of the specified chooser (
	  'ui_get_chooser_obj' ).This is object is chooser-specific.
	  
	  @param chooser_caption (C++: const char *)
	  @return: the object that was used to create the chooser
	  

ida_kernwin.get_curline():
	
	  get_curline() -> char const *
	
	
	  Get current line from the disassemble window ( 'ui_get_curline' ).
	  
	  @return: cptr current line with the color codes (use  tag_remove()  to
	           remove the color codes)
	  

ida_kernwin.get_current_viewer():
	
	  get_current_viewer() -> TWidget *
	
	
	  Get current ida viewer (idaview or custom viewer) (
	  'ui_get_current_viewer' )
	  

ida_kernwin.get_current_widget():
	
	  get_current_widget() -> TWidget *
	
	
	  Get a pointer to the current widget ( 'ui_get_current_widget' ).
	  

ida_kernwin.get_cursor():
	
	  get_cursor() -> bool
	
	
	  Get the cursor position on the screen ( 'ui_get_cursor' ).coordinates
	  are 0-based
	  

ida_kernwin.get_custom_viewer_curline():
	
	  get_custom_viewer_curline(custom_viewer, mouse) -> char const *
	
	
	  Get current line of custom viewer ( 'ui_get_custom_viewer_curline' ).
	  The returned line contains color codes
	  
	  @param custom_viewer: view (C++: TWidget *)
	  @param mouse: mouse position (otherwise cursor position) (C++: bool)
	  @return: pointer to contents of current line
	  

ida_kernwin.get_custom_viewer_place():
	
	  get_custom_viewer_place(custom_viewer, mouse) -> place_t
	
	
	  Get current place in a custom viewer ( 'ui_get_curplace' ).
	  
	  @param custom_viewer: view (C++: TWidget *)
	  @param mouse: mouse position (otherwise cursor position) (C++: bool)
	  

ida_kernwin.get_ea_viewer_history_info():
	
	  get_ea_viewer_history_info(nback, nfwd, v) -> bool
	
	
	  Get information about what's in the history (
	  'ui_ea_viewer_history_info' ).
	  
	  @param nback: number of available back steps (C++: int *)
	  @param nfwd: number of available forward steps (C++: int *)
	  @param v: ea viewer (C++: TWidget *)
	  

ida_kernwin.get_hexdump_ea():
	
	  get_hexdump_ea(hexdump_num) -> ea_t
	
	
	  Get the current address in a hex view.
	  
	  @param hexdump_num: number of hexview window (C++: int)
	  

ida_kernwin.get_highlight():
	
	  get_highlight(v) -> PyObject *
	
	
	  Returns the currently highlighted identifier and flags
	  
	  @return: a tuple (text, flags), or None if nothing
	           is highlighted or in case of error.
	  

ida_kernwin.get_kernel_version():
	
	  get_kernel_version() -> ssize_t
	
	
	  Get IDA kernel version (in a string like "5.1").
	  

ida_kernwin.get_key_code():
	
	  get_key_code(keyname) -> ushort
	
	
	  Get keyboard key code by its name ( 'ui_get_key_code' )
	  
	  
	  @param keyname (C++: const char *)
	  

ida_kernwin.get_navband_ea():
	
	  get_navband_ea(pixel) -> ea_t
	
	
	  Translate the pixel position on the navigation band, into an address.
	  
	  
	  @param pixel (C++: int)
	  

ida_kernwin.get_navband_pixel():
	
	  get_navband_pixel(ea) -> int
	
	
	  Maps an address, onto a pixel coordinate within the navband
	  
	  @param ea: The address to map
	  @return: a list [pixel, is_vertical]
	  

ida_kernwin.get_opnum():
	
	  get_opnum() -> int
	
	
	  Get current operand number, -1 means no operand ( 'ui_get_opnum' )
	  

ida_kernwin.get_output_curline():
	
	  get_output_curline(mouse) -> bool
	
	
	  Get current line of output window ( 'ui_get_output_curline' ).
	  
	  @param mouse: current for mouse pointer? (C++: bool)
	  @return: false if output contains no text
	  

ida_kernwin.get_output_cursor():
	
	  get_output_cursor() -> bool
	
	
	  Get coordinates of the output window's cursor ( 'ui_get_output_cursor'
	  ).coordinates are 0-basedthis function will succeed even if the output
	  window is not visible
	  

ida_kernwin.get_output_selected_text():
	
	  get_output_selected_text() -> bool
	
	
	  Returns selected text from output window (
	  'ui_get_output_selected_text' ).
	  
	  @return: true if there is a selection
	  

ida_kernwin.get_place_class():
	
	  get_place_class(out_flags, out_sdk_version, id) -> place_t
	
	
	  Get information about a previously-registered 'place_t' class. See
	  also 'register_place_class()' .
	  
	  @param out_flags: output flags (can be NULL) (C++: int *)
	  @param out_sdk_version: sdk version the place was created with (can be
	                          NULL) (C++: int *)
	  @param id: place class ID (C++: int)
	  @return: the  place_t  template, or NULL if not found
	  

ida_kernwin.get_place_class_id():
	
	  get_place_class_id(name) -> int
	
	
	  Get the place class ID for the place that has been registered as
	  'name'.
	  
	  @param name: the class name (C++: const char *)
	  @return: the place class ID, or -1 if not found
	  

ida_kernwin.get_place_class_template():
	
	  get_place_class_template(id) -> place_t
	
	
	  See 'get_place_class()'
	  
	  
	  @param id (C++: int)
	  

ida_kernwin.get_registered_actions():
	
	  get_registered_actions() -> PyObject *
	
	
	  Get a list of all currently-registered actions
	  

ida_kernwin.get_screen_ea():
	
	  get_screen_ea() -> ea_t
	
	
	  Get the address at the screen cursor ( 'ui_screenea' )
	  

ida_kernwin.get_tab_size():
	
	  get_tab_size(path) -> int
	
	
	  Get the size of a tab in spaces ( 'ui_get_tab_size' ).
	  
	  @param path: the path of the source view for which the tab size is
	               requested.   if NULL, the default size is returned. (C++:
	               const char *)
	  

ida_kernwin.get_user_strlist_options():
	
	  get_user_strlist_options(out)
	  

ida_kernwin.get_view_renderer_type():
	
	  get_view_renderer_type(v) -> tcc_renderer_type_t
	
	
	  Get the type of renderer currently in use in the given view (
	  'ui_get_renderer_type' )
	  
	  
	  @param v (C++: TWidget *)
	  

ida_kernwin.get_viewer_place_type():
	
	  get_viewer_place_type(viewer) -> tcc_place_type_t
	
	
	  Get the type of 'place_t' instances a viewer uses & creates (
	  'ui_get_viewer_place_type' ).
	  
	  
	  @param viewer (C++: TWidget *)
	  

ida_kernwin.get_viewer_user_data():
	
	  get_viewer_user_data(viewer) -> void *
	
	
	  Get the user data from a custom viewer ( 'ui_get_viewer_user_data' )
	  
	  
	  @param viewer (C++: TWidget *)
	  

ida_kernwin.get_widget_title():
	
	  get_widget_title(widget) -> bool
	
	
	  Get the TWidget's title ( 'ui_get_widget_title' ).
	  
	  
	  @param widget (C++: TWidget *)
	  

ida_kernwin.get_widget_type():
	
	  get_widget_type(widget) -> twidget_type_t
	
	
	  Get the type of the TWidget * ( 'ui_get_widget_type' ).
	  
	  
	  @param widget (C++: TWidget *)
	  

ida_kernwin.get_window_id():
	
	  get_window_id(name=None) -> void *
	
	
	  Get the system-specific window ID (GUI version only)
	  
	  @param name (C++: const char *)
	  @return: the low-level window ID
	  

ida_kernwin.hide_wait_box():
	
	  hide_wait_box()
	
	
	  Hide the "Please wait dialog box".
	  

class ida_kernwin.idaplace_t():
	
	    Proxy of C++ idaplace_t class
	    

ida_kernwin.idaplace_t._print():
	
	        _print(self, out_buf, ud)
	        

ida_kernwin.idaplace_t.adjust():
	
	        adjust(self, ud)
	        

ida_kernwin.idaplace_t.as_enumplace_t():
	
	        as_enumplace_t(p) -> enumplace_t
	        

ida_kernwin.idaplace_t.as_idaplace_t():
	
	        as_idaplace_t(p) -> idaplace_t
	        

ida_kernwin.idaplace_t.as_simpleline_place_t():
	
	        as_simpleline_place_t(p) -> simpleline_place_t
	        

ida_kernwin.idaplace_t.as_structplace_t():
	
	        as_structplace_t(p) -> structplace_t
	        

ida_kernwin.idaplace_t.beginning():
	
	        beginning(self, ud) -> bool
	        

ida_kernwin.idaplace_t.clone():
	
	        clone(self) -> place_t
	        

ida_kernwin.idaplace_t.compare():
	
	        compare(self, t2) -> int
	        

ida_kernwin.idaplace_t.copyfrom():
	
	        copyfrom(self, _from)
	        

ida_kernwin.idaplace_t.ea:
	idaplace_t_ea_get(self) -> ea_t

ida_kernwin.idaplace_t.ending():
	
	        ending(self, ud) -> bool
	        

ida_kernwin.idaplace_t.enter():
	
	        enter(self, arg2) -> place_t
	        

ida_kernwin.idaplace_t.generate():
	
	        generate(self, ud, maxsize) -> PyObject *
	        

ida_kernwin.idaplace_t.id():
	
	        id(self) -> int
	        

ida_kernwin.idaplace_t.leave():
	
	        leave(self, arg2)
	        

ida_kernwin.idaplace_t.lnnum:
	place_t_lnnum_get(self) -> int

ida_kernwin.idaplace_t.makeplace():
	
	        makeplace(self, ud, x, lnnum) -> place_t
	        

ida_kernwin.idaplace_t.name():
	
	        name(self) -> char const *
	        

ida_kernwin.idaplace_t.next():
	
	        next(self, ud) -> bool
	        

ida_kernwin.idaplace_t.prev():
	
	        prev(self, ud) -> bool
	        

ida_kernwin.idaplace_t.rebase():
	
	        rebase(self, arg2) -> bool
	        

ida_kernwin.idaplace_t.toea():
	
	        toea(self) -> ea_t
	        

ida_kernwin.idaplace_t.touval():
	
	        touval(self, ud) -> uval_t
	        

ida_kernwin.info():
	
	  info(format)
	  

ida_kernwin.install_command_interpreter():
	
	  install_command_interpreter(py_obj) -> int
	
	
	  Install command line interpreter ( 'ui_install_cli' )
	  

ida_kernwin.internal_register_place_class():
	
	  internal_register_place_class(tmplate, flags, owner, sdk_version) -> int
	  

ida_kernwin.is_action_enabled():
	
	  is_action_enabled(s) -> bool
	
	
	  Check if the given action state is one of AST_ENABLE*.
	  
	  
	  @param s (C++: action_state_t)
	  

ida_kernwin.is_chooser_widget():
	
	  is_chooser_widget(t) -> bool
	
	
	  Does the given widget type specify a chooser widget?
	  
	  
	  @param t (C++: twidget_type_t)
	  

ida_kernwin.is_idaq():
	
	  is_idaq() -> bool
	
	
	  Returns True or False depending if IDAPython is hosted by IDAQ
	  

ida_kernwin.is_msg_inited():
	
	  is_msg_inited() -> bool
	
	
	  Can we use msg() functions?
	  

ida_kernwin.is_place_class_ea_capable():
	
	  is_place_class_ea_capable(id) -> bool
	
	
	  See 'get_place_class()'
	  
	  
	  @param id (C++: int)
	  

ida_kernwin.is_refresh_requested():
	
	  is_refresh_requested(mask) -> bool
	
	
	  Get a refresh request state
	  
	  @param mask: Window refresh flags (C++: uint64)
	  @return: the state (set or cleared)
	  

class ida_kernwin.jobj_wrapper_t():
	
	    Proxy of C++ jobj_wrapper_t class
	    

ida_kernwin.jobj_wrapper_t.get_dict():
	
	        get_dict(self) -> PyObject *
	        

ida_kernwin.jumpto():
	
	    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
	    jumpto(custom_viewer, place, x, y) -> bool
	
	
	  Jump to the specified address ( 'ui_jumpto' ).
	  
	  @param ea: destination (C++: ea_t)
	  @param opnum: -1: don't change x coord (C++: int)
	  @param uijmp_flags: Jump flags (C++: int)
	  @return: success
	    

ida_kernwin.load_custom_icon():
	
	    Loads a custom icon and returns an identifier that can be used with other APIs
	
	    If file_name is passed then the other two arguments are ignored.
	
	    @param file_name: The icon file name
	    @param data: The icon data
	    @param format: The icon data format
	
	    @return: Icon id or 0 on failure.
	             Use free_custom_icon() to free it
	
	
	    Load an icon from a file ( 'ui_load_custom_icon_file' ). Also see
	    'load_custom_icon(const void *, unsigned int, const char *)'
	    
	    @return: icon id
	    

ida_kernwin.load_dbg_dbginfo():
	
	  load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
	
	
	  Load debugging information from a file.
	  
	  @param path: path to file (C++: const char *)
	  @param li: loader input. if NULL, check DBG_NAME_KEY (C++: linput_t *)
	  @param base: loading address (C++: ea_t)
	  @param verbose: dump status to message window (C++: bool)
	  

class ida_kernwin.locchange_md_t():
	
	    Proxy of C++ locchange_md_t class
	    

ida_kernwin.locchange_md_t.is_sync():
	
	        is_sync(self) -> bool
	        

ida_kernwin.locchange_md_t.reason():
	
	        reason(self) -> locchange_reason_t
	        

ida_kernwin.lookup_key_code():
	
	  lookup_key_code(key, shift, is_qt) -> ushort
	
	
	  Get shortcut code previously created by 'ui_get_key_code' .
	  
	  @param key: key constant (C++: int)
	  @param shift: modifiers (C++: int)
	  @param is_qt: are we using gui version? (C++: bool)
	  

ida_kernwin.msg():
	
	  msg(o) -> PyObject *
	
	
	  Display an UTF-8 string in the message window
	  
	  The result of the stringification of the arguments
	  will be treated as an UTF-8 string.
	  
	  @param message: message to print (formatting is done in Python)
	  
	  This function can be used to debug IDAPython scripts
	  

ida_kernwin.msg_clear():
	
	  msg_clear()
	
	
	  Clear the "Output window".
	  

ida_kernwin.msg_get_lines():
	
	  msg_get_lines(count=-1) -> PyObject *
	
	
	  Retrieve the last 'count' lines from the output window, in reverse
	  order (from most recent, to least recent)
	  
	  @param count: The number of lines to retrieve. -1 means: all (C++:
	                int)
	  

ida_kernwin.msg_save():
	
	  msg_save(path) -> bool
	
	
	  Save the "Output window" contents into a file
	  
	  @param path: The path of the file to save the contents into. An empty
	               path means that the user will be prompted for the
	               destination and, if the file already exists, the user
	               will be asked to confirm before overriding its contents.
	               Upon return, 'path' will contain the path that the user
	               chose. (C++: qstring  &)
	  @return: success
	  

ida_kernwin.nomem():
	
	  nomem(format)
	  

ida_kernwin.open_bpts_window():
	
	  open_bpts_window(ea) -> TWidget *
	
	
	  Open the breakpoints window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_calls_window():
	
	  open_calls_window(ea) -> TWidget *
	
	
	  Open the function calls window ( 'ui_open_builtin' ).
	  
	  @param ea (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_disasm_window():
	
	  open_disasm_window(window_title, ranges=None) -> TWidget *
	
	
	  Open a disassembly view ( 'ui_open_builtin' ).
	  
	  @param window_title: title of view to open (C++: const char *)
	  @param ranges: if != NULL, then display a flow chart with the
	                 specified ranges (C++: const  rangevec_t  *)
	  @return: pointer to resulting window
	  

ida_kernwin.open_enums_window():
	
	  open_enums_window(const_id=BADADDR) -> TWidget *
	
	
	  Open the enums window ( 'ui_open_builtin' ).
	  
	  @param const_id: index of entry to select by default (C++: tid_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_exports_window():
	
	  open_exports_window(ea) -> TWidget *
	
	
	  Open the exports window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_frame_window():
	
	  open_frame_window(pfn, offset) -> TWidget *
	
	
	  Open the frame window for the given function ( 'ui_open_builtin' ).
	  
	  @param pfn: function to analyze (C++: func_t  *)
	  @param offset: offset where the cursor is placed (C++: uval_t)
	  @return: pointer to resulting window if 'pfn' is a valid function and
	           the window was displayed,    NULL otherwise
	  

ida_kernwin.open_funcs_window():
	
	  open_funcs_window(ea) -> TWidget *
	
	
	  Open the functions window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_hexdump_window():
	
	  open_hexdump_window(window_title) -> TWidget *
	
	
	  Open a hexdump view ( 'ui_open_builtin' ).
	  
	  @param window_title: title of view to open (C++: const char *)
	  @return: pointer to resulting window
	  

ida_kernwin.open_imports_window():
	
	  open_imports_window(ea) -> TWidget *
	
	
	  Open the exports window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_loctypes_window():
	
	  open_loctypes_window(ordinal) -> TWidget *
	
	
	  Open the local types window ( 'ui_open_builtin' ).
	  
	  @param ordinal: ordinal of type to select by default (C++: int)
	  @return: pointer to resulting window
	  

ida_kernwin.open_modules_window():
	
	  open_modules_window() -> TWidget *
	
	
	  Open the modules window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_names_window():
	
	  open_names_window(ea) -> TWidget *
	
	
	  Open the names window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_navband_window():
	
	  open_navband_window(ea, zoom) -> TWidget *
	
	
	  Open the navigation band window ( 'ui_open_builtin' ).
	  
	  @param ea: sets the address of the navband arrow (C++: ea_t)
	  @param zoom: sets the navband zoom level (C++: int)
	  @return: pointer to resulting window
	  

ida_kernwin.open_notepad_window():
	
	  open_notepad_window() -> TWidget *
	
	
	  Open the notepad window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_problems_window():
	
	  open_problems_window(ea) -> TWidget *
	
	
	  Open the problems window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_segments_window():
	
	  open_segments_window(ea) -> TWidget *
	
	
	  Open the segments window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_segregs_window():
	
	  open_segregs_window(ea) -> TWidget *
	
	
	  Open the segment registers window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_selectors_window():
	
	  open_selectors_window() -> TWidget *
	
	
	  Open the selectors window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_signatures_window():
	
	  open_signatures_window() -> TWidget *
	
	
	  Open the signatures window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_stack_window():
	
	  open_stack_window() -> TWidget *
	
	
	  Open the call stack window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_strings_window():
	
	  open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
	
	
	  Open the strings window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @param selstart: only display strings that occur within this range
	                   (C++: ea_t)
	  @param selend: only display strings that occur within this range (C++:
	                 ea_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_structs_window():
	
	  open_structs_window(id=BADADDR, offset=0) -> TWidget *
	
	
	  Open the structs window ( 'ui_open_builtin' ).
	  
	  @param id: index of entry to select by default (C++: tid_t)
	  @param offset: offset where the cursor is placed (C++: uval_t)
	  @return: pointer to resulting window
	  

ida_kernwin.open_threads_window():
	
	  open_threads_window() -> TWidget *
	
	
	  Open the threads window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_tils_window():
	
	  open_tils_window() -> TWidget *
	
	
	  Open the type libraries window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_trace_window():
	
	  open_trace_window() -> TWidget *
	
	
	  Open the trace window ( 'ui_open_builtin' ).
	  
	  @return: pointer to resulting window
	  

ida_kernwin.open_url():
	
	  open_url(url)
	
	
	  Open the given url ( 'ui_open_url' )
	  
	  
	  @param url (C++: const char *)
	  

ida_kernwin.open_xrefs_window():
	
	  open_xrefs_window(ea) -> TWidget *
	
	
	  Open the cross references window ( 'ui_open_builtin' ).
	  
	  @param ea: index of entry to select by default (C++: ea_t)
	  @return: pointer to resulting window
	  

class ida_kernwin.place_t():
	
	    Proxy of C++ place_t class
	    

ida_kernwin.place_t._print():
	
	        _print(self, out_buf, ud)
	        

ida_kernwin.place_t.adjust():
	
	        adjust(self, ud)
	        

ida_kernwin.place_t.as_enumplace_t():
	
	        as_enumplace_t(p) -> enumplace_t
	        

ida_kernwin.place_t.as_idaplace_t():
	
	        as_idaplace_t(p) -> idaplace_t
	        

ida_kernwin.place_t.as_simpleline_place_t():
	
	        as_simpleline_place_t(p) -> simpleline_place_t
	        

ida_kernwin.place_t.as_structplace_t():
	
	        as_structplace_t(p) -> structplace_t
	        

ida_kernwin.place_t.beginning():
	
	        beginning(self, ud) -> bool
	        

ida_kernwin.place_t.clone():
	
	        clone(self) -> place_t
	        

ida_kernwin.place_t.compare():
	
	        compare(self, t2) -> int
	        

ida_kernwin.place_t.copyfrom():
	
	        copyfrom(self, _from)
	        

ida_kernwin.place_t.ending():
	
	        ending(self, ud) -> bool
	        

ida_kernwin.place_t.enter():
	
	        enter(self, arg2) -> place_t
	        

ida_kernwin.place_t.generate():
	
	        generate(self, ud, maxsize) -> PyObject *
	        

ida_kernwin.place_t.id():
	
	        id(self) -> int
	        

ida_kernwin.place_t.leave():
	
	        leave(self, arg2)
	        

ida_kernwin.place_t.lnnum:
	place_t_lnnum_get(self) -> int

ida_kernwin.place_t.makeplace():
	
	        makeplace(self, ud, x, lnnum) -> place_t
	        

ida_kernwin.place_t.name():
	
	        name(self) -> char const *
	        

ida_kernwin.place_t.next():
	
	        next(self, ud) -> bool
	        

ida_kernwin.place_t.prev():
	
	        prev(self, ud) -> bool
	        

ida_kernwin.place_t.rebase():
	
	        rebase(self, arg2) -> bool
	        

ida_kernwin.place_t.toea():
	
	        toea(self) -> ea_t
	        

ida_kernwin.place_t.touval():
	
	        touval(self, ud) -> uval_t
	        

ida_kernwin.place_t_as_enumplace_t():
	
	  place_t_as_enumplace_t(p) -> enumplace_t
	  

ida_kernwin.place_t_as_idaplace_t():
	
	  place_t_as_idaplace_t(p) -> idaplace_t
	  

ida_kernwin.place_t_as_simpleline_place_t():
	
	  place_t_as_simpleline_place_t(p) -> simpleline_place_t
	  

ida_kernwin.place_t_as_structplace_t():
	
	  place_t_as_structplace_t(p) -> structplace_t
	  

ida_kernwin.plgform_close():
	
	  plgform_close(py_link, options)
	  

ida_kernwin.plgform_get_widget():
	
	  plgform_get_widget(py_link) -> TWidget *
	  

ida_kernwin.plgform_new():
	
	  plgform_new() -> PyObject *
	  

ida_kernwin.plgform_show():
	
	  plgform_show(py_link, py_obj, caption, options=WOPN_TAB|WOPN_RESTORE) -> bool
	  

ida_kernwin.process_ui_action():
	
	  process_ui_action(name, flags=0) -> bool
	
	
	  Invokes an IDA UI action by name
	  
	  @param name:  action name
	  @return: Boolean
	  

ida_kernwin.py_get_ask_form():
	
	  py_get_ask_form() -> size_t
	  

ida_kernwin.py_get_open_form():
	
	  py_get_open_form() -> size_t
	  

ida_kernwin.py_load_custom_icon_data():
	
	  py_load_custom_icon_data(data, format) -> int
	  

ida_kernwin.py_load_custom_icon_fn():
	
	  py_load_custom_icon_fn(filename) -> int
	  

ida_kernwin.py_register_compiled_form():
	
	  py_register_compiled_form(py_form)
	  

ida_kernwin.py_ss_restore_callback():
	
	  py_ss_restore_callback(err_msg, userdata)
	  

ida_kernwin.py_unregister_compiled_form():
	
	  py_unregister_compiled_form(py_form)
	  

ida_kernwin.pyidag_bind():
	
	  pyidag_bind(self) -> bool
	  

ida_kernwin.pyidag_unbind():
	
	  pyidag_unbind(self) -> bool
	  

ida_kernwin.pyscv_add_line():
	
	  pyscv_add_line(py_this, py_sl) -> bool
	  

ida_kernwin.pyscv_clear_lines():
	
	  pyscv_clear_lines(py_this) -> PyObject *
	  

ida_kernwin.pyscv_close():
	
	  pyscv_close(py_this)
	  

ida_kernwin.pyscv_count():
	
	  pyscv_count(py_this) -> size_t
	  

ida_kernwin.pyscv_del_line():
	
	  pyscv_del_line(py_this, nline) -> bool
	  

ida_kernwin.pyscv_delete():
	
	  pyscv_delete(py_this) -> bool
	  

ida_kernwin.pyscv_edit_line():
	
	  pyscv_edit_line(py_this, nline, py_sl) -> bool
	  

ida_kernwin.pyscv_get_current_line():
	
	  pyscv_get_current_line(py_this, mouse, notags) -> PyObject *
	  

ida_kernwin.pyscv_get_current_word():
	
	  pyscv_get_current_word(py_this, mouse) -> PyObject *
	  

ida_kernwin.pyscv_get_line():
	
	  pyscv_get_line(py_this, nline) -> PyObject *
	  

ida_kernwin.pyscv_get_pos():
	
	  pyscv_get_pos(py_this, mouse) -> PyObject *
	  

ida_kernwin.pyscv_get_selection():
	
	  pyscv_get_selection(py_this) -> PyObject *
	  

ida_kernwin.pyscv_get_widget():
	
	  pyscv_get_widget(py_this) -> TWidget *
	  

ida_kernwin.pyscv_init():
	
	  pyscv_init(py_link, title) -> PyObject *
	  

ida_kernwin.pyscv_insert_line():
	
	  pyscv_insert_line(py_this, nline, py_sl) -> bool
	  

ida_kernwin.pyscv_is_focused():
	
	  pyscv_is_focused(py_this) -> bool
	  

ida_kernwin.pyscv_jumpto():
	
	  pyscv_jumpto(py_this, ln, x, y) -> bool
	  

ida_kernwin.pyscv_patch_line():
	
	  pyscv_patch_line(py_this, nline, offs, value) -> bool
	  

ida_kernwin.pyscv_refresh():
	
	  pyscv_refresh(py_this) -> bool
	  

ida_kernwin.pyscv_refresh_current():
	
	  pyscv_refresh_current(py_this) -> bool
	  

ida_kernwin.pyscv_show():
	
	  pyscv_show(py_this) -> bool
	  

ida_kernwin.qcleanline():
	
	  qcleanline(cmt_char=' ', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> ssize_t
	
	
	  Performs some cleanup operations to a line.
	  
	  @param cmt_char: character that denotes the start of a comment:   the
	                   entire text is removed if the line begins with this
	                   character (ignoring leading spaces) all text after
	                   (and including) this character is removed if flag
	                   CLNL_FINDCMT is set (C++: char)
	  @param flags: a combination of  line cleanup flags . defaults to
	                CLNL_TRIM (C++: uint32)
	  @return: length of line
	  

ida_kernwin.read_range_selection():
	
	  read_range_selection(v) -> bool
	
	
	  Get the address range for the selected range boundaries, this is the
	  convenient function for 'read_selection()'
	  
	  @param v: view, NULL means the last active window containing addresses
	            (C++: TWidget *)
	  

ida_kernwin.read_selection():
	
	  read_selection(v, p1, p2) -> bool
	
	
	  Read the user selection, and store its information in p0 (from) and p1 (to).
	  
	  This can be used as follows:
	  
	  
	  >>> p0 = idaapi.twinpos_t()
	  p1 = idaapi.twinpos_t()
	  view = idaapi.get_current_viewer()
	  idaapi.read_selection(view, p0, p1)
	  
	  
	  At that point, p0 and p1 hold information for the selection.
	  But, the 'at' property of p0 and p1 is not properly typed.
	  To specialize it, call #place() on it, passing it the view
	  they were retrieved from. Like so:
	  
	  
	  >>> place0 = p0.place(view)
	  place1 = p1.place(view)
	  
	  
	  This will effectively "cast" the place into a specialized type,
	  holding proper information, depending on the view type (e.g.,
	  disassembly, structures, enums, ...)
	  
	  @param view: The view to retrieve the selection for.
	  @param p0: Storage for the "from" part of the selection.
	  @param p1: Storage for the "to" part of the selection.
	  @return: a bool value indicating success.
	  

ida_kernwin.refresh_chooser():
	
	  refresh_chooser(title) -> bool
	
	
	  Mark a non-modal custom chooser for a refresh ( 'ui_refresh_chooser'
	  ).
	  
	  @param title: title of chooser (C++: const char *)
	  @return: success
	  

ida_kernwin.refresh_choosers():
	
	  refresh_choosers()
	  

ida_kernwin.refresh_idaview():
	
	  refresh_idaview()
	
	
	  Refresh marked windows ( 'ui_refreshmarked' )
	  

ida_kernwin.refresh_idaview_anyway():
	
	  refresh_idaview_anyway()
	
	
	  Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
	  refresh. Please consider 'request_refresh()' instead
	  

ida_kernwin.refresh_navband():
	
	  refresh_navband(force)
	
	
	  Refresh navigation band if changed ( 'ui_refresh_navband' ).
	  
	  @param force: refresh regardless (C++: bool)
	  

ida_kernwin.register_action():
	
	  register_action(desc) -> bool
	
	
	  Create a new action ( 'ui_register_action' ). After an action has been
	  created, it is possible to attach it to menu items (
	  'attach_action_to_menu()' ), or to popup menus (
	  'attach_action_to_popup()' ).Because the actions will need to call the
	  handler's activate() and update() methods at any time, you shouldn't
	  build your action handler on the stack.Please see the SDK's "ht_view"
	  plugin for an example how to register actions.
	  
	  @param desc: action to register (C++: const  action_desc_t  &)
	  @return: success
	  

ida_kernwin.register_addon():
	
	  register_addon(info) -> int
	
	
	  Register an add-on. Show its info in the About box. For plugins,
	  should be called from init() function (repeated calls with the same
	  product code overwrite previous entries) returns: index of the add-on
	  in the list, or -1 on error
	  
	  @param info (C++: const  addon_info_t  *)
	  

ida_kernwin.register_and_attach_to_menu():
	
	  register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner) -> bool
	
	
	  Helper.You are not encouraged to use this, as it mixes flags for both
	  'register_action()' , and 'attach_action_to_menu()' .The only reason
	  for its existence is to make it simpler to port existing plugins to
	  the new actions API.
	  
	  @param menupath (C++: const char *)
	  @param name (C++: const char *)
	  @param label (C++: const char *)
	  @param shortcut (C++: const char *)
	  @param flags (C++: int)
	  @param handler (C++: action_handler_t  *)
	  @param owner (C++: const  plugin_t  *)
	  

ida_kernwin.register_timer():
	
	  register_timer(interval, py_callback) -> PyObject *
	
	
	  Register a timer
	  
	  @param interval: Interval in milliseconds
	  @param callback: A Python callable that takes no parameters and returns an integer.
	                   The callback may return:
	                   -1   : to unregister the timer
	                   >= 0 : the new or same timer interval
	  @return: None or a timer object
	  

ida_kernwin.remove_command_interpreter():
	
	  remove_command_interpreter(cli_idx)
	
	
	  Remove command line interpreter ( 'ui_install_cli' )
	  

class ida_kernwin.renderer_pos_info_t():
	
	    Proxy of C++ renderer_pos_info_t class
	    

ida_kernwin.renderer_pos_info_t.cx:
	renderer_pos_info_t_cx_get(self) -> short

ida_kernwin.renderer_pos_info_t.cy:
	renderer_pos_info_t_cy_get(self) -> short

ida_kernwin.renderer_pos_info_t.node:
	renderer_pos_info_t_node_get(self) -> int

ida_kernwin.renderer_pos_info_t.sx:
	renderer_pos_info_t_sx_get(self) -> short

ida_kernwin.repaint_custom_viewer():
	
	  repaint_custom_viewer(custom_viewer)
	
	
	  Repaint the given widget immediately ( 'ui_repaint_qwidget' )
	  
	  
	  @param custom_viewer (C++: TWidget *)
	  

ida_kernwin.replace_wait_box():
	
	  replace_wait_box(format)
	
	
	  Replace the label of "Please wait dialog box".
	  
	  
	  @param format (C++: const char *)
	  

ida_kernwin.request_refresh():
	
	  request_refresh(mask, cnd=True)
	
	
	  Request a refresh of a builtin window.
	  
	  @param mask: Window refresh flags (C++: uint64)
	  @param cnd: set if true or clear flag otherwise (C++: bool)
	  

ida_kernwin.restore_database_snapshot():
	
	  restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> PyObject *
	
	
	  Restore a database snapshot. Note: This call is asynchronous. When it
	  is completed, the callback will be triggered.
	  
	  @param ss: snapshot instance (see  build_snapshot_tree() ) (C++: const
	             snapshot_t  *)
	  @return: false if restoration could not be started (snapshot file was
	           not found).    If the returned value is True then check if
	           the operation succeeded from the callback.
	  

ida_kernwin.set_cancelled():
	
	  set_cancelled()
	
	
	  Set "Cancelled" flag ( 'ui_set_cancelled' )
	  

ida_kernwin.set_code_viewer_handler():
	
	  set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
	
	
	  Set a handler for a code viewer event ( 'ui_set_custom_viewer_handler'
	  ).
	  
	  @param code_viewer: the code viewer (C++: TWidget *)
	  @param handler_id: one of CDVH_ in  custom_viewer_handler_id_t (C++:
	                     custom_viewer_handler_id_t)
	  @param handler_or_data: can be a handler or data. see examples in
	                          Functions: custom viewer handlers (C++: void
	                          *)
	  @return: old value of the handler or data
	  

ida_kernwin.set_code_viewer_is_source():
	
	  set_code_viewer_is_source(code_viewer) -> bool
	
	
	  Specify that the given code viewer is used to display source code (
	  'ui_set_custom_viewer_handler' ).
	  
	  
	  @param code_viewer (C++: TWidget *)
	  

ida_kernwin.set_code_viewer_line_handlers():
	
	  set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
	
	
	  Set handlers for code viewer line events. Any of these handlers may be
	  NULL
	  
	  @param code_viewer (C++: TWidget *)
	  @param click_handler (C++: code_viewer_lines_click_t  *)
	  @param popup_handler (C++: code_viewer_lines_click_t  *)
	  @param dblclick_handler (C++: code_viewer_lines_click_t  *)
	  @param drawicon_handler (C++: code_viewer_lines_icon_t  *)
	  @param linenum_handler (C++: code_viewer_lines_linenum_t  *)
	  

ida_kernwin.set_code_viewer_lines_alignment():
	
	  set_code_viewer_lines_alignment(code_viewer, align) -> bool
	
	
	  Set alignment for lines in a code viewer (
	  'ui_set_custom_viewer_handler' ).
	  
	  
	  @param code_viewer (C++: TWidget *)
	  @param align (C++: int)
	  

ida_kernwin.set_code_viewer_lines_icon_margin():
	
	  set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
	
	
	  Set space allowed for icons in the margin of a code viewer (
	  'ui_set_custom_viewer_handler' ).
	  
	  
	  @param code_viewer (C++: TWidget *)
	  @param margin (C++: int)
	  

ida_kernwin.set_code_viewer_lines_radix():
	
	  set_code_viewer_lines_radix(code_viewer, radix) -> bool
	
	
	  Set radix for values displayed in a code viewer (
	  'ui_set_custom_viewer_handler' ).
	  
	  
	  @param code_viewer (C++: TWidget *)
	  @param radix (C++: int)
	  

ida_kernwin.set_code_viewer_user_data():
	
	  set_code_viewer_user_data(code_viewer, ud) -> bool
	
	
	  Set the user data on a code viewer ( 'ui_set_custom_viewer_handler' ).
	  
	  
	  @param code_viewer (C++: TWidget *)
	  @param ud (C++: void *)
	  

ida_kernwin.set_custom_viewer_qt_aware():
	
	  set_custom_viewer_qt_aware(custom_viewer) -> bool
	
	
	  Allow the given viewer to interpret Qt events (
	  'ui_set_custom_viewer_handler' )
	  
	  
	  @param custom_viewer (C++: TWidget *)
	  

ida_kernwin.set_dock_pos():
	
	  set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool
	
	
	  Sets the dock orientation of a window relatively to another window.
	  
	  @param src: Source docking control
	  @param dest: Destination docking control
	  @param orient: One of DOR_XXXX constants
	  @param left, top, right, bottom: These parameter if DOR_FLOATING is used, or if you want to specify the width of docked windows
	  @return: Boolean
	  
	  Example:
	      set_dock_pos('Structures', 'Enums', DOR_RIGHT) <- docks the Structures window to the right of Enums window
	  

ida_kernwin.set_highlight():
	
	  set_highlight(viewer, str, flags) -> bool
	
	
	  Set the highlighted identifier in the viewer ( 'ui_set_highlight' ).
	  
	  @param viewer: the viewer (C++: TWidget *)
	  @param str: the text to match, or NULL to remove current (C++: const
	              char *)
	  @param flags: combination of HIF_... bits (see  set_highlightr flags )
	                (C++: int)
	  @return: false if an error occurred
	  

ida_kernwin.set_nav_colorizer():
	
	  set_nav_colorizer(new_py_colorizer) -> nav_colorizer_t *
	
	
	  Set a new colorizer for the navigation band.
	  
	  The 'callback' is a function of 2 arguments:
	     - ea (the EA to colorize for)
	     - nbytes (the number of bytes at that EA)
	  and must return a 'long' value.
	  
	  The previous colorizer is returned, allowing
	  the new 'callback' to use 'call_nav_colorizer'
	  with it.
	  
	  Note that the previous colorizer is returned
	  only the first time set_nav_colorizer() is called:
	  due to the way the colorizers API is defined in C,
	  it is impossible to chain more than 2 colorizers
	  in IDAPython: the original, IDA-provided colorizer,
	  and a user-provided one.
	  
	  Example: colorizer inverting the color provided by the IDA colorizer:
	      def my_colorizer(ea, nbytes):
	          global ida_colorizer
	          orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
	          return long(~orig)
	  
	      ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)
	  

ida_kernwin.set_view_renderer_type():
	
	  set_view_renderer_type(v, rt)
	
	
	  Set the type of renderer to use in a view ( 'ui_set_renderer_type' )
	  
	  
	  @param v (C++: TWidget *)
	  @param rt (C++: tcc_renderer_type_t)
	  

ida_kernwin.show_wait_box():
	
	  show_wait_box(format)
	
	
	  Display a dialog box with "Please wait...". If the text message starts
	  with "HIDECANCEL
	", the cancel buttonwon't be displayed in the dialog
	  box and you don't need to checkfor cancellations with
	  'user_cancelled()' . Plugins must call 'hide_wait_box()' to close the
	  dialog box, otherwise the user interface will be disabled.Note that,
	  if the wait dialog is already visible, 'show_wait_box()' will1) push
	  the currently-displayed text on a stack2) display the new textThen,
	  when 'hide_wait_box()' is called, if that stack isn't empty its
	  toplabel will be popped and restored in the wait dialog.This implies
	  that a plugin should call 'hide_wait_box()' exactly as manytimes as it
	  called 'show_wait_box()' , or the wait dialog might remainvisible and
	  block the UI.Also, in case the plugin knows the wait dialog is
	  currently displayed,alternatively it can call 'replace_wait_box()' ,
	  to replace the text of thedialog without pushing the currently-
	  displayed text on the stack.
	  
	  @param format (C++: const char *)
	  

class ida_kernwin.simplecustviewer_t():
	
	    The base class for implementing simple custom viewers
	    

ida_kernwin.simplecustviewer_t.AddLine():
	
	        Adds a colored line to the view
	        @return: Boolean
	        

ida_kernwin.simplecustviewer_t.ClearLines():
	
	        Clears all the lines
	        

ida_kernwin.simplecustviewer_t.Close():
	
	        Destroys the view.
	        One has to call Create() afterwards.
	        Show() can be called and it will call Create() internally.
	        @return: Boolean
	        

ida_kernwin.simplecustviewer_t.Count():
	
	        Returns the number of lines in the view
	        

ida_kernwin.simplecustviewer_t.Create():
	
	        Creates the custom view. This should be the first method called after instantiation
	
	        @param title: The title of the view
	        @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
	                 In this case better close existing windows
	        

ida_kernwin.simplecustviewer_t.DelLine():
	
	        Deletes an existing line
	        @return: Boolean
	        

ida_kernwin.simplecustviewer_t.EditLine():
	
	        Edits an existing line.
	        @return: Boolean
	        

ida_kernwin.simplecustviewer_t.GetCurrentLine():
	
	        Returns the current line.
	        @param mouse: Current line at mouse pos
	        @param notags: If True then tag_remove() will be called before returning the line
	        @return: Returns the current line (colored or uncolored) or None on failure
	        

ida_kernwin.simplecustviewer_t.GetCurrentWord():
	
	        Returns the current word
	        @param mouse: Use mouse position or cursor position
	        @return: None if failed or a String containing the current word at mouse or cursor
	        

ida_kernwin.simplecustviewer_t.GetLine():
	
	        Returns a line
	        @param lineno: The line number
	        @return:
	            Returns a tuple (colored_line, fgcolor, bgcolor) or None
	        

ida_kernwin.simplecustviewer_t.GetLineNo():
	
	        Calls GetPos() and returns the current line number or -1 on failure
	        

ida_kernwin.simplecustviewer_t.GetPos():
	
	        Returns the current cursor or mouse position.
	        @param mouse: return mouse position
	        @return: Returns a tuple (lineno, x, y)
	        

ida_kernwin.simplecustviewer_t.GetSelection():
	
	        Returns the selected range or None
	        @return:
	            - tuple(x1, y1, x2, y2)
	            - None if no selection
	        

ida_kernwin.simplecustviewer_t.GetWidget():
	
	        Return the TWidget underlying this view.
	
	        @return: The TWidget underlying this view, or None.
	        

ida_kernwin.simplecustviewer_t.InsertLine():
	
	        Inserts a line in the given position
	        @return: Boolean
	        

ida_kernwin.simplecustviewer_t.IsFocused():
	
	        Returns True if the current view is the focused view
	        

ida_kernwin.simplecustviewer_t.OnPopup():
	
	        Context menu popup is about to be shown. Create items dynamically if you wish
	        @return: Boolean. True if you handled the event
	        

ida_kernwin.simplecustviewer_t.PatchLine():
	
	        Patches an existing line character at the given offset. This is a low level function. You must know what you're doing
	        

ida_kernwin.simplecustviewer_t.RefreshCurrent():
	
	        Refreshes the current line only
	        

ida_kernwin.simplecustviewer_t.Show():
	
	        Shows an already created view. It the view was close, then it will call Create() for you
	        @return: Boolean
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.create_desktop_widget():
	
	        create_desktop_widget(self, title, cfg) -> PyObject *
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.current_widget_changed():
	
	        current_widget_changed(self, widget, prev_widget)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.database_inited():
	
	        database_inited(self, is_new_database, idc_script)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.debugger_menu_change():
	
	        debugger_menu_change(self, enable) -> int
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.finish_populating_widget_popup():
	
	        finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
	
	
	        The UI is about to be done populating the TWidget's popup menu.
	        Now is a good time to call idaapi.attach_action_to_popup()
	        
	        @param widget: The widget
	        @param popup: The popup menu.
	        @return: Ignored
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.get_chooser_item_attrs():
	
	        get_chooser_item_attrs(self, chooser, n, attrs)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.get_custom_viewer_hint():
	
	        get_custom_viewer_hint(self, viewer, place) -> PyObject *
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.get_ea_hint():
	
	        get_ea_hint(self, ea) -> PyObject *
	
	
	        The UI wants to display a simple hint for an address in the navigation band
	        
	        @param ea: The address
	        @return: String with the hint or None
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.get_item_hint():
	
	        get_item_hint(self, ea, max_lines) -> PyObject *
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.hook():
	
	        hook(self) -> bool
	
	
	        Creates an UI hook
	        
	        @return: Boolean true on success
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.idcstart():
	
	        idcstart(self)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.idcstop():
	
	        idcstop(self)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.plugin_loaded():
	
	        plugin_loaded(self, plugin_info)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.plugin_unloading():
	
	        plugin_unloading(self, plugin_info)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.postprocess_action():
	
	        postprocess_action(self)
	
	
	        An ida ui action has been handled
	        
	        @return: Ignored
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.preprocess_action():
	
	        preprocess_action(self, name)
	
	
	        IDA ui is about to handle a user action
	        
	        @param name: ui action name
	                     (these names can be looked up in ida[tg]ui.cfg)
	        @return: 0-ok, nonzero - a plugin has handled the action
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.range():
	
	        range(self)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.ready_to_run():
	
	        ready_to_run(self)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.resume():
	
	        resume(self)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.saved():
	
	        saved(self)
	
	
	        The kernel has saved the database.
	        
	        @return: Ignored
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.saving():
	
	        saving(self)
	
	
	        The kernel is saving the database.
	        
	        @return: Ignored
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.screen_ea_changed():
	
	        screen_ea_changed(self, ea, prev_ea)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.suspend():
	
	        suspend(self)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.term():
	
	        term(self)
	
	
	        IDA is terminated and the database is already closed.
	        The UI may close its windows in this callback.
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.unhook():
	
	        unhook(self) -> bool
	
	
	        Removes the UI hook
	        @return: Boolean true on success
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.updated_actions():
	
	        updated_actions(self)
	
	
	        The UI is done updating actions.
	        
	        @return: Ignored
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.updating_actions():
	
	        updating_actions(self, ctx)
	
	
	        The UI is about to batch-update some actions.
	        
	        @param ctx: The action_update_ctx_t instance
	        @return: Ignored
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.widget_closing():
	
	        widget_closing(self, widget)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.widget_invisible():
	
	        widget_invisible(self, widget)
	        

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.widget_visible():
	
	        widget_visible(self, widget)
	        

class ida_kernwin.simpleline_place_t():
	
	    Proxy of C++ simpleline_place_t class
	    

ida_kernwin.simpleline_place_t._print():
	
	        _print(self, out_buf, ud)
	        

ida_kernwin.simpleline_place_t.adjust():
	
	        adjust(self, ud)
	        

ida_kernwin.simpleline_place_t.as_enumplace_t():
	
	        as_enumplace_t(p) -> enumplace_t
	        

ida_kernwin.simpleline_place_t.as_idaplace_t():
	
	        as_idaplace_t(p) -> idaplace_t
	        

ida_kernwin.simpleline_place_t.as_simpleline_place_t():
	
	        as_simpleline_place_t(p) -> simpleline_place_t
	        

ida_kernwin.simpleline_place_t.as_structplace_t():
	
	        as_structplace_t(p) -> structplace_t
	        

ida_kernwin.simpleline_place_t.beginning():
	
	        beginning(self, ud) -> bool
	        

ida_kernwin.simpleline_place_t.clone():
	
	        clone(self) -> place_t
	        

ida_kernwin.simpleline_place_t.compare():
	
	        compare(self, t2) -> int
	        

ida_kernwin.simpleline_place_t.copyfrom():
	
	        copyfrom(self, _from)
	        

ida_kernwin.simpleline_place_t.ending():
	
	        ending(self, ud) -> bool
	        

ida_kernwin.simpleline_place_t.enter():
	
	        enter(self, arg2) -> place_t
	        

ida_kernwin.simpleline_place_t.generate():
	
	        generate(self, ud, maxsize) -> PyObject *
	        

ida_kernwin.simpleline_place_t.id():
	
	        id(self) -> int
	        

ida_kernwin.simpleline_place_t.leave():
	
	        leave(self, arg2)
	        

ida_kernwin.simpleline_place_t.lnnum:
	place_t_lnnum_get(self) -> int

ida_kernwin.simpleline_place_t.makeplace():
	
	        makeplace(self, ud, x, lnnum) -> place_t
	        

ida_kernwin.simpleline_place_t.n:
	simpleline_place_t_n_get(self) -> uint32

ida_kernwin.simpleline_place_t.name():
	
	        name(self) -> char const *
	        

ida_kernwin.simpleline_place_t.next():
	
	        next(self, ud) -> bool
	        

ida_kernwin.simpleline_place_t.prev():
	
	        prev(self, ud) -> bool
	        

ida_kernwin.simpleline_place_t.rebase():
	
	        rebase(self, arg2) -> bool
	        

ida_kernwin.simpleline_place_t.toea():
	
	        toea(self) -> ea_t
	        

ida_kernwin.simpleline_place_t.touval():
	
	        touval(self, ud) -> uval_t
	        

class ida_kernwin.simpleline_t():
	
	    Proxy of C++ simpleline_t class
	    

ida_kernwin.simpleline_t.bgcolor:
	simpleline_t_bgcolor_get(self) -> bgcolor_t

ida_kernwin.simpleline_t.color:
	simpleline_t_color_get(self) -> color_t

ida_kernwin.simpleline_t.line:
	simpleline_t_line_get(self) -> qstring *

ida_kernwin.str2ea():
	
	  str2ea(str, screenEA=BADADDR) -> ea_t
	
	
	  Converts a string express to EA. The expression evaluator may be called as well.
	  
	  @return: BADADDR or address value
	  

ida_kernwin.str2user():
	
	  str2user(str) -> PyObject *
	
	
	  Insert C-style escape characters to string
	  
	  @return: new string with escape characters inserted
	  

ida_kernwin.strarray():
	
	  strarray(array, array_size, code) -> char const *
	
	
	  Find a line with the specified code in the 'strarray_t' array. If the
	  last element of the array has code==0 then it is considered as the
	  default entry.If no default entry exists and the code is not found,
	  'strarray()' returns "".
	  
	  @param array (C++: const  strarray_t  *)
	  @param array_size (C++: size_t)
	  @param code (C++: int)
	  

class ida_kernwin.strarray_t():
	
	    Proxy of C++ strarray_t class
	    

ida_kernwin.strarray_t.code:
	strarray_t_code_get(self) -> int

ida_kernwin.strarray_t.text:
	strarray_t_text_get(self) -> char const *

class ida_kernwin.structplace_t():
	
	    Proxy of C++ structplace_t class
	    

ida_kernwin.structplace_t._print():
	
	        _print(self, out_buf, ud)
	        

ida_kernwin.structplace_t.adjust():
	
	        adjust(self, ud)
	        

ida_kernwin.structplace_t.as_enumplace_t():
	
	        as_enumplace_t(p) -> enumplace_t
	        

ida_kernwin.structplace_t.as_idaplace_t():
	
	        as_idaplace_t(p) -> idaplace_t
	        

ida_kernwin.structplace_t.as_simpleline_place_t():
	
	        as_simpleline_place_t(p) -> simpleline_place_t
	        

ida_kernwin.structplace_t.as_structplace_t():
	
	        as_structplace_t(p) -> structplace_t
	        

ida_kernwin.structplace_t.beginning():
	
	        beginning(self, ud) -> bool
	        

ida_kernwin.structplace_t.clone():
	
	        clone(self) -> place_t
	        

ida_kernwin.structplace_t.compare():
	
	        compare(self, t2) -> int
	        

ida_kernwin.structplace_t.copyfrom():
	
	        copyfrom(self, _from)
	        

ida_kernwin.structplace_t.ending():
	
	        ending(self, ud) -> bool
	        

ida_kernwin.structplace_t.enter():
	
	        enter(self, arg2) -> place_t
	        

ida_kernwin.structplace_t.generate():
	
	        generate(self, ud, maxsize) -> PyObject *
	        

ida_kernwin.structplace_t.id():
	
	        id(self) -> int
	        

ida_kernwin.structplace_t.idx:
	structplace_t_idx_get(self) -> uval_t

ida_kernwin.structplace_t.leave():
	
	        leave(self, arg2)
	        

ida_kernwin.structplace_t.lnnum:
	place_t_lnnum_get(self) -> int

ida_kernwin.structplace_t.makeplace():
	
	        makeplace(self, ud, x, lnnum) -> place_t
	        

ida_kernwin.structplace_t.name():
	
	        name(self) -> char const *
	        

ida_kernwin.structplace_t.next():
	
	        next(self, ud) -> bool
	        

ida_kernwin.structplace_t.offset:
	structplace_t_offset_get(self) -> uval_t

ida_kernwin.structplace_t.prev():
	
	        prev(self, ud) -> bool
	        

ida_kernwin.structplace_t.rebase():
	
	        rebase(self, arg2) -> bool
	        

ida_kernwin.structplace_t.toea():
	
	        toea(self) -> ea_t
	        

ida_kernwin.structplace_t.touval():
	
	        touval(self, ud) -> uval_t
	        

ida_kernwin.take_database_snapshot():
	
	  take_database_snapshot(ss) -> PyObject *
	
	
	  Take a database snapshot ( 'ui_take_database_snapshot' ).
	  
	  @param ss: in/out parameter.   in: description, flags out: filename,
	             id (C++: snapshot_t  *)
	  @return: success
	  

class ida_kernwin.textctrl_info_t():
	
	    Class representing textctrl_info_t
	    

ida_kernwin.textctrl_info_t._free():
	
	        Explicitly delete the link (only if not static)
	        

ida_kernwin.textctrl_info_t.assign():
	
	        Copies the contents of 'other' to 'self'
	        

ida_kernwin.textctrl_info_t.copy():
	
	        Returns a new copy of this class
	        

ida_kernwin.textctrl_info_t.flags:
	
	        Returns the flags value
	        

ida_kernwin.textctrl_info_t.tabsize:
	
	        Returns the tabsize value
	        

ida_kernwin.textctrl_info_t.text:
	
	        Sets the text value
	        

ida_kernwin.textctrl_info_t.value:
	
	        Sets the text value
	        

ida_kernwin.textctrl_info_t_assign():
	
	  textctrl_info_t_assign(self, other) -> bool
	  

ida_kernwin.textctrl_info_t_create():
	
	  textctrl_info_t_create() -> PyObject *
	  

ida_kernwin.textctrl_info_t_destroy():
	
	  textctrl_info_t_destroy(py_obj) -> bool
	  

ida_kernwin.textctrl_info_t_get_clink():
	
	  textctrl_info_t_get_clink(self) -> textctrl_info_t *
	  

ida_kernwin.textctrl_info_t_get_clink_ptr():
	
	  textctrl_info_t_get_clink_ptr(self) -> PyObject *
	  

ida_kernwin.textctrl_info_t_get_flags():
	
	  textctrl_info_t_get_flags(self, flags) -> unsigned int
	  

ida_kernwin.textctrl_info_t_get_tabsize():
	
	  textctrl_info_t_get_tabsize(self, tabsize) -> unsigned int
	  

ida_kernwin.textctrl_info_t_get_text():
	
	  textctrl_info_t_get_text(self) -> char const *
	  

ida_kernwin.textctrl_info_t_set_flags():
	
	  textctrl_info_t_set_flags(self, flags) -> bool
	  

ida_kernwin.textctrl_info_t_set_tabsize():
	
	  textctrl_info_t_set_tabsize(self, tabsize) -> bool
	  

ida_kernwin.textctrl_info_t_set_text():
	
	  textctrl_info_t_set_text(self, s) -> bool
	  

class ida_kernwin.twinpos_t():
	
	    Proxy of C++ twinpos_t class
	    

ida_kernwin.twinpos_t.at:
	twinpos_t_at_get(self) -> place_t

ida_kernwin.twinpos_t.x:
	twinpos_t_x_get(self) -> int

ida_kernwin.ui_load_new_file():
	
	  ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
	
	
	  Display a load file dialog and load file ( 'ui_load_file' ).
	  
	  @param temp_file: name of the file with the extracted archive member.
	                    (C++: qstring  *)
	  @param filename: the name of input file as is, library or archive name
	                   (C++: qstring  *)
	  @param pli: loader input source, may be changed to point to temp_file
	              (C++: linput_t **)
	  @param neflags: combination of NEF_... bits (see  Load file flags )
	                  (C++: ushort)
	  @param ploaders: list of loaders which accept file, may be changed for
	                   loaders of temp_file (C++: load_info_t  **)
	  

class ida_kernwin.ui_requests_t():
	
	    Proxy of C++ ui_requests_t class
	    

ida_kernwin.ui_run_debugger():
	
	  ui_run_debugger(dbgopts, exename, argc, argv) -> bool
	
	
	  Load a debugger plugin and run the specified program ( 'ui_run_dbg' ).
	  
	  @param dbgopts: value of the -r command line switch (C++: const char
	                  *)
	  @param exename: name of the file to run (C++: const char *)
	  @param argc: number of arguments for the executable (C++: int)
	  @param argv: argument vector (C++: const char *const *)
	  @return: success
	  

ida_kernwin.unmark_selection():
	
	  unmark_selection()
	
	
	  Unmark selection ( 'ui_unmarksel' )
	  

ida_kernwin.unregister_action():
	
	  unregister_action(name) -> bool
	
	
	  Delete a previously-registered action ( 'ui_unregister_action' ).
	  
	  @param name: name of action (C++: const char *)
	  @return: success
	  

ida_kernwin.unregister_timer():
	
	  unregister_timer(py_timerctx) -> PyObject *
	
	
	  Unregister a timer
	  
	  @param timer_obj: a timer object previously returned by a register_timer()
	  @return: Boolean
	  @note: After the timer has been deleted, the timer_obj will become invalid.
	  

ida_kernwin.update_action_checkable():
	
	  update_action_checkable(name, checkable) -> bool
	
	
	  Update an action's checkability ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param checkable: new checkability (C++: bool)
	  @return: success
	  

ida_kernwin.update_action_checked():
	
	  update_action_checked(name, checked) -> bool
	
	
	  Update an action's checked state ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param checked: new checked state (C++: bool)
	  @return: success
	  

ida_kernwin.update_action_icon():
	
	  update_action_icon(name, icon) -> bool
	
	
	  Update an action's icon ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param icon: new icon id (C++: int)
	  @return: success
	  

ida_kernwin.update_action_label():
	
	  update_action_label(name, label) -> bool
	
	
	  Update an action's label ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param label: new label (C++: const char *)
	  @return: success
	  

ida_kernwin.update_action_shortcut():
	
	  update_action_shortcut(name, shortcut) -> bool
	
	
	  Update an action's shortcut ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param shortcut: new shortcut (C++: const char *)
	  @return: success
	  

ida_kernwin.update_action_state():
	
	  update_action_state(name, state) -> bool
	
	
	  Update an action's state ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param state: new state (C++: action_state_t)
	  @return: success
	  

ida_kernwin.update_action_tooltip():
	
	  update_action_tooltip(name, tooltip) -> bool
	
	
	  Update an action's tooltip ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param tooltip: new tooltip (C++: const char *)
	  @return: success
	  

ida_kernwin.update_action_visibility():
	
	  update_action_visibility(name, visible) -> bool
	
	
	  Update an action's visibility ( 'ui_update_action_attr' ).
	  
	  @param name: action name (C++: const char *)
	  @param visible: new visibility (C++: bool)
	  @return: success
	  

ida_kernwin.user_cancelled():
	
	  user_cancelled() -> bool
	
	
	  Test the ctrl-break flag ( 'ui_test_cancelled' ).
	  

class ida_kernwin.view_mouse_event_location_t():
	
	    Proxy of C++ view_mouse_event_location_t class
	    

ida_kernwin.view_mouse_event_location_t.ea:
	view_mouse_event_location_t_ea_get(self) -> ea_t

ida_kernwin.view_mouse_event_location_t.item:
	view_mouse_event_location_t_item_get(self) -> selection_item_t const *

class ida_kernwin.view_mouse_event_t():
	
	    Proxy of C++ view_mouse_event_t class
	    

ida_kernwin.view_mouse_event_t.button:
	view_mouse_event_t_button_get(self) -> vme_button_t

ida_kernwin.view_mouse_event_t.location:
	view_mouse_event_t_location_get(self) -> view_mouse_event_location_t

ida_kernwin.view_mouse_event_t.renderer_pos:
	view_mouse_event_t_renderer_pos_get(self) -> renderer_pos_info_t

ida_kernwin.view_mouse_event_t.rtype:
	view_mouse_event_t_rtype_get(self) -> tcc_renderer_type_t

ida_kernwin.view_mouse_event_t.state:
	view_mouse_event_t_state_get(self) -> view_event_state_t

ida_kernwin.view_mouse_event_t.x:
	view_mouse_event_t_x_get(self) -> uint32

ida_kernwin.view_mouse_event_t.y:
	view_mouse_event_t_y_get(self) -> uint32

ida_kernwin.warning():
	
	  warning(format)
	
	
	  Display a message in a message box
	  
	  @param message: message to print (formatting is done in Python)
	  
	  This function can be used to debug IDAPython scripts
	  The user will be able to hide messages if they appear twice in a row on
	  the screen
	  


=== ida_kernwin EPYDOC INJECTIONS ===
ida_kernwin.ACF_HAS_SELECTION
"""
there is currently a valid selection
"""

ida_kernwin.ACF_XTRN_EA
"""
cur_ea is in 'externs' segment
"""

ida_kernwin.ADF_OWN_HANDLER
"""
handler is owned by the action; it'll be destroyed when the action is
unregistered. You shouldn't have to use this.
"""

ida_kernwin.AHF_VERSION
"""
action handler version (used by 'action_handler_t::flags' )
"""

ida_kernwin.AHF_VERSION_MASK
"""
mask for 'action_handler_t::flags'
"""

ida_kernwin.ASKBTN_BTN1
"""
First (Yes) button.
"""

ida_kernwin.ASKBTN_BTN2
"""
Second (No) button.
"""

ida_kernwin.ASKBTN_BTN3
"""
Third (Cancel) button.
"""

ida_kernwin.ASKBTN_CANCEL
"""
Cancel button.
"""

ida_kernwin.ASKBTN_NO
"""
No button.
"""

ida_kernwin.ASKBTN_YES
"""
Yes button.
"""

ida_kernwin.BWN_ADDRWATCH
"""
the 'Watch List' window
"""

ida_kernwin.BWN_BPTS
"""
breakpoints
"""

ida_kernwin.BWN_CALLS
"""
function calls
"""

ida_kernwin.BWN_CALLS_CALLEES
"""
function calls, callees
"""

ida_kernwin.BWN_CALLS_CALLERS
"""
function calls, callers
"""

ida_kernwin.BWN_CALL_STACK
"""
call stack
"""

ida_kernwin.BWN_CHOOSER
"""
a non-builtin chooser
"""

ida_kernwin.BWN_CLI
"""
the command-line, in the output window
"""

ida_kernwin.BWN_CMDPALCSR
"""
the command palette chooser (Qt version only)
"""

ida_kernwin.BWN_CMDPALWIN
"""
the command palette window (Qt version only)
"""

ida_kernwin.BWN_CPUREGS
"""
one of the 'General registers', 'FPU register', ... debugger windows
"""

ida_kernwin.BWN_CUSTVIEW
"""
custom viewers
"""

ida_kernwin.BWN_DISASM
"""
disassembly views
"""

ida_kernwin.BWN_DISASMS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_DUMP
"""
hex dumps
"""

ida_kernwin.BWN_DUMPS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_ENUMS
"""
enumerations
"""

ida_kernwin.BWN_EXPORTS
"""
exports
"""

ida_kernwin.BWN_FRAME
"""
function frame
"""

ida_kernwin.BWN_FUNCS
"""
functions
"""

ida_kernwin.BWN_IMPORTS
"""
imports
"""

ida_kernwin.BWN_LOCALS
"""
the 'locals' debugger window
"""

ida_kernwin.BWN_LOCTYPS
"""
local types
"""

ida_kernwin.BWN_MDVIEWCSR
"""
lumina metadata view chooser
"""

ida_kernwin.BWN_MODULES
"""
modules
"""

ida_kernwin.BWN_NAMES
"""
names
"""

ida_kernwin.BWN_NAVBAND
"""
navigation band
"""

ida_kernwin.BWN_NOTEPAD
"""
notepad
"""

ida_kernwin.BWN_OUTPUT
"""
the text area, in the output window
"""

ida_kernwin.BWN_PROBS
"""
problems
"""

ida_kernwin.BWN_PSEUDOCODE
"""
hexrays decompiler views
"""

ida_kernwin.BWN_SEARCH
"""
search results
"""

ida_kernwin.BWN_SEARCHS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_SEGREGS
"""
segment registers
"""

ida_kernwin.BWN_SEGS
"""
segments
"""

ida_kernwin.BWN_SELS
"""
selectors
"""

ida_kernwin.BWN_SHORTCUTCSR
"""
the shortcuts chooser (Qt version only)
"""

ida_kernwin.BWN_SHORTCUTWIN
"""
the shortcuts window (Qt version only)
"""

ida_kernwin.BWN_SIGNS
"""
signatures
"""

ida_kernwin.BWN_SNIPPETS
"""
the 'Execute script' window
"""

ida_kernwin.BWN_SO_OFFSETS
"""
the 'Structure offsets' dialog's offset panel
"""

ida_kernwin.BWN_SO_STRUCTS
"""
the 'Structure offsets' dialog's 'Structures and Unions' panel
"""

ida_kernwin.BWN_STACK
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

ida_kernwin.BWN_STKVIEW
"""
the 'Stack view' debugger window
"""

ida_kernwin.BWN_STRINGS
"""
strings
"""

ida_kernwin.BWN_STRUCTS
"""
structures
"""

ida_kernwin.BWN_THREADS
"""
threads
"""

ida_kernwin.BWN_TILS
"""
type libraries
"""

ida_kernwin.BWN_TRACE
"""
trace view
"""

ida_kernwin.BWN_UNKNOWN
"""
unknown window
"""

ida_kernwin.BWN_WATCH
"""
the 'watches' debugger window
"""

ida_kernwin.BWN_XREFS
"""
xrefs
"""

ida_kernwin.CHITEM_BOLD
"""
display the item in bold
"""

ida_kernwin.CHITEM_GRAY
"""
gray out the item
"""

ida_kernwin.CHITEM_ITALIC
"""
display the item in italic
"""

ida_kernwin.CHITEM_STRIKE
"""
strikeout the item
"""

ida_kernwin.CHITEM_UNDER
"""
underline the item
"""

ida_kernwin.CHOOSER_MENU_EDIT
"""
Values of themenu_indexparameter.

Obsolete. Please don't use
"""

ida_kernwin.CHOOSER_MENU_JUMP
"""
Obsolete. Please don't use.
"""

ida_kernwin.CHOOSER_MENU_SEARCH
"""
Obsolete. Please don't use.
"""

ida_kernwin.CHOOSER_MULTI_SELECTION
"""
enable for multiple selections. A callback of
typechooser_multi_cb_twill be called for all selected items.
"""

ida_kernwin.CHOOSER_NO_SELECTION
"""
Flags.

enable even if there's no selected item.nwill be NO_SELECTION for a
callback.
"""

ida_kernwin.CHOOSER_POPUP_MENU
"""
Add command to the popup menu.
"""

ida_kernwin.CLNL_FINDCMT
"""
Search for the comment symbol everywhere in the line, not only at the
beginning.
"""

ida_kernwin.CLNL_LTRIM
"""
Remove leading space characters.
"""

ida_kernwin.CLNL_RTRIM
"""
Remove trailing space characters.
"""

ida_kernwin.CREATETB_ADV
"""
toolbar is for 'advanced mode' only
"""

ida_kernwin.DP_BEFORE
"""
used with 'DP_INSIDE' .

place src_form before dst_form in the tab bar instead of after
"""

ida_kernwin.DP_BOTTOM
"""
Dock src_form below dest_form.
"""

ida_kernwin.DP_FLOATING
"""
Make src_form floating.
"""

ida_kernwin.DP_INSIDE
"""
Create a new tab bar with both src_form and dest_form.
"""

ida_kernwin.DP_LEFT
"""
Dock src_form to the left of dest_form.
"""

ida_kernwin.DP_RIGHT
"""
Dock src_form to the right of dest_form.
"""

ida_kernwin.DP_TAB
"""
Place src_form into a tab next to dest_form, if dest_form is in a tab
bar (otherwise the same as 'DP_INSIDE' )
"""

ida_kernwin.DP_TOP
"""
Dock src_form above dest_form.
"""

ida_kernwin.HIF_IDENTIFIER
"""
text is an identifier (i.e., when searching for the current highlight,
SEARCH_IDENT will be used)
"""

ida_kernwin.HIF_LOCKED
"""
locked; clicking/moving the cursor around doesn't change the highlight
"""

ida_kernwin.HIF_REGISTER
"""
text represents a register (aliases/subregisters will be highlit as
well)
"""

ida_kernwin.HIST_CMD
"""
commands
"""

ida_kernwin.HIST_CMT
"""
comments
"""

ida_kernwin.HIST_DIR
"""
directory names (text version only)
"""

ida_kernwin.HIST_FILE
"""
file names
"""

ida_kernwin.HIST_IDENT
"""
names
"""

ida_kernwin.HIST_SEG
"""
segment names
"""

ida_kernwin.HIST_SRCH
"""
search substrings
"""

ida_kernwin.HIST_TYPE
"""
type declarations
"""

ida_kernwin.IWID_ADDRWATCH
"""
address watches (47)
"""

ida_kernwin.IWID_ALL
"""
mask
"""

ida_kernwin.IWID_BPTS
"""
breakpoints (13)
"""

ida_kernwin.IWID_CALLS
"""
function calls (11)
"""

ida_kernwin.IWID_CALLS_CALLEES
"""
funcalls, callees (50)
"""

ida_kernwin.IWID_CALLS_CALLERS
"""
funcalls, callers (49)
"""

ida_kernwin.IWID_CHOOSER
"""
chooser (37)
"""

ida_kernwin.IWID_CLI
"""
input line (33)
"""

ida_kernwin.IWID_CMDPALCSR
"""
command palette (43)
"""

ida_kernwin.IWID_CMDPALWIN
"""
command palette (44)
"""

ida_kernwin.IWID_CPUREGS
"""
registers (40)
"""

ida_kernwin.IWID_CUSTVIEW
"""
custom viewers (46)
"""

ida_kernwin.IWID_DISASMS
"""
disassembly views (29)
"""

ida_kernwin.IWID_DUMPS
"""
hex dumps (30)
"""

ida_kernwin.IWID_ENUMS
"""
enumerations (27)
"""

ida_kernwin.IWID_EXPORTS
"""
exports (0)
"""

ida_kernwin.IWID_FRAME
"""
function frame (25)
"""

ida_kernwin.IWID_FUNCS
"""
functions (3)
"""

ida_kernwin.IWID_IDAMEMOS
"""
disassembly + hex dump views
"""

ida_kernwin.IWID_IMPORTS
"""
imports (1)
"""

ida_kernwin.IWID_LOCALS
"""
locals (35)
"""

ida_kernwin.IWID_LOCTYPS
"""
local types (10)
"""

ida_kernwin.IWID_MDVIEWCSR
"""
lumina md view (51)
"""

ida_kernwin.IWID_MODULES
"""
modules (15)
"""

ida_kernwin.IWID_NAMES
"""
names (2)
"""

ida_kernwin.IWID_NAVBAND
"""
navigation band (26)
"""

ida_kernwin.IWID_NOTEPAD
"""
notepad (31)
"""

ida_kernwin.IWID_OUTPUT
"""
output (32)
"""

ida_kernwin.IWID_PROBS
"""
problems (12)
"""

ida_kernwin.IWID_PSEUDOCODE
"""
decompiler (48)
"""

ida_kernwin.IWID_SEARCHS
"""
search results (19)
"""

ida_kernwin.IWID_SEGREGS
"""
segment registers (6)
"""

ida_kernwin.IWID_SEGS
"""
segments (5)
"""

ida_kernwin.IWID_SELS
"""
selectors (7)
"""

ida_kernwin.IWID_SHORTCUTCSR
"""
shortcuts chooser (38)
"""

ida_kernwin.IWID_SHORTCUTWIN
"""
shortcuts window (39)
"""

ida_kernwin.IWID_SIGNS
"""
signatures (8)
"""

ida_kernwin.IWID_SNIPPETS
"""
snippets (45)
"""

ida_kernwin.IWID_SO_OFFSETS
"""
stroff (42)
"""

ida_kernwin.IWID_SO_STRUCTS
"""
stroff (41)
"""

ida_kernwin.IWID_STACK
"""
call stack (17)
"""

ida_kernwin.IWID_STKVIEW
"""
stack view (36)
"""

ida_kernwin.IWID_STRINGS
"""
strings (4)
"""

ida_kernwin.IWID_STRUCTS
"""
structures (28)
"""

ida_kernwin.IWID_THREADS
"""
threads (14)
"""

ida_kernwin.IWID_TILS
"""
type libraries (9)
"""

ida_kernwin.IWID_TRACE
"""
trace view (16)
"""

ida_kernwin.IWID_WATCH
"""
watches (34)
"""

ida_kernwin.IWID_XREFS
"""
xrefs (18)
"""

ida_kernwin.MFF_FAST
"""
Execute code as soon as possible. this mode is ok for calling ui
related functions that do not query the database.
"""

ida_kernwin.MFF_NOWAIT
"""
Do not wait for the request to be executed. the caller should ensure
that the request is not destroyed until the execution completes. if
not, the request will be ignored. 'execute_sync()' returns the request
id in this case. it can be used in 'cancel_exec_request()' . This flag
can be used to delay the code execution until the next UI loop run
even from the main thread.
"""

ida_kernwin.MFF_READ
"""
Execute code only when ida is idle and it is safe to query the
database. this mode is recommended only for code that does not modify
the database. (nb: ida may be in the middle of executing another user
request, for example it may be waiting for him to enter values into a
modal dialog box)
"""

ida_kernwin.MFF_WRITE
"""
Execute code only when ida is idle and it is safe to modify the
database. in particular, this flag will suspend execution if there is
a modal dialog box on the screen this mode can be used to call any ida
api function 'MFF_WRITE' implies 'MFF_READ'
"""

ida_kernwin.SETMENU_APP
"""
add menu item after the specified path
"""

ida_kernwin.SETMENU_FIRST
"""
add item to the beginning of menu
"""

ida_kernwin.SETMENU_INS
"""
add menu item before the specified path (default)
"""

ida_kernwin.UIJMP_ACTIVATE
"""
activate the new window
"""

ida_kernwin.UIJMP_DONTPUSH
"""
in the navigation history

do not remember the current address
"""

ida_kernwin.UIJMP_IDAVIEW
"""
jump in idaview (by default any eaview is good)
"""

ida_kernwin.VES_SHIFT
"""
state & 1 => Shift is pressedstate & 2 => Alt is pressedstate & 4 =>
Ctrl is pressedstate & 8 => Mouse left button is pressedstate & 16 =>
Mouse right button is pressedstate & 32 => Mouse middle button is
pressedstate & 128 => Meta is pressed (OSX only)
"""
=== ida_kernwin EPYDOC INJECTIONS END ===
ida_lines.COLSTR():
	
	    Utility function to create a colored line
	    @param str: The string
	    @param tag: Color tag constant. One of SCOLOR_XXXX
	    

ida_lines.add_extra_cmt():
	
	  add_extra_cmt(ea, isprev, format) -> bool
	
	
	  Add anterior/posterior comment line(s).
	  
	  @param ea: linear address (C++: ea_t)
	  @param isprev: do we add anterior lines? (0-no, posterior) (C++: bool)
	  @param format: printf() style format string. may contain 
	 to denote
	                 new lines. The resulting string should not contain
	                 comment characters (;), the kernel will add them
	                 automatically. (C++: const char *)
	  @return: true if success
	  

ida_lines.add_extra_line():
	
	  add_extra_line(ea, isprev, format) -> bool
	
	
	  Add anterior/posterior non-comment line(s).
	  
	  @param ea: linear address (C++: ea_t)
	  @param isprev: do we add anterior lines? (0-no, posterior) (C++: bool)
	  @param format: printf() style format string. may contain 
	 to denote
	                 new lines. (C++: const char *)
	  @return: true if success
	  

ida_lines.add_pgm_cmt():
	
	  add_pgm_cmt(format) -> bool
	
	
	  Add anterior comment line(s) at the start of program.
	  
	  @param format: printf() style format string. may contain 
	 to denote
	                 new lines. The resulting string should not contain
	                 comment characters (;), the kernel will add them
	                 automatically. (C++: const char *)
	  @return: true if success
	  

ida_lines.add_sourcefile():
	
	  add_sourcefile(ea1, ea2, filename) -> bool
	
	
	  Mark a range of address as belonging to a source file. An address
	  range may belong only to one source file. A source file may be
	  represented by several address ranges.
	  
	  @param ea1: linear address of start of the address range (C++: ea_t)
	  @param ea2: linear address of end of the address range (excluded)
	              (C++: ea_t)
	  @param filename: name of source file. (C++: const char *)
	  @return: success
	  

class ida_lines.bgcolors_t():
	
	    Proxy of C++ bgcolors_t class
	    

ida_lines.bgcolors_t.epilog_color:
	bgcolors_t_epilog_color_get(self) -> bgcolor_t

ida_lines.bgcolors_t.prolog_color:
	bgcolors_t_prolog_color_get(self) -> bgcolor_t

ida_lines.bgcolors_t.switch_color:
	bgcolors_t_switch_color_get(self) -> bgcolor_t

ida_lines.calc_bg_color():
	
	  calc_bg_color(ea) -> bgcolor_t
	
	
	  Get background color for line at 'ea'
	  
	  @param ea (C++: ea_t)
	  @return: RGB color
	  

ida_lines.calc_prefix_color():
	
	  calc_prefix_color(ea) -> color_t
	
	
	  Get prefix color for line at 'ea'
	  
	  @param ea (C++: ea_t)
	  @return: Line prefix colors
	  

ida_lines.create_encoding_helper():
	
	  create_encoding_helper(encidx=-1, nr=nr_once) -> encoder_t *
	  

ida_lines.del_extra_cmt():
	
	  del_extra_cmt(ea, what)
	  

ida_lines.del_sourcefile():
	
	  del_sourcefile(ea) -> bool
	
	
	  Delete information about the source file.
	  
	  @param ea: linear address (C++: ea_t)
	  @return: success
	  

ida_lines.delete_extra_cmts():
	
	  delete_extra_cmts(ea, what)
	  

ida_lines.generate_disasm_line():
	
	  generate_disasm_line(ea, flags=0) -> bool
	  

ida_lines.generate_disassembly():
	
	  generate_disassembly(ea, max_lines, as_stack, notags) -> PyObject *
	
	
	  Generate disassembly lines (many lines) and put them into a buffer
	  
	  @param ea: address to generate disassembly for
	  @param max_lines: how many lines max to generate
	  @param as_stack: Display undefined items as 2/4/8 bytes
	  @return:
	      - None on failure
	      - tuple(most_important_line_number, tuple(lines)) : Returns a tuple containing
	        the most important line number and a tuple of generated lines
	  

ida_lines.get_extra_cmt():
	
	  get_extra_cmt(ea, what) -> ssize_t
	  

ida_lines.get_first_free_extra_cmtidx():
	
	  get_first_free_extra_cmtidx(ea, start) -> int
	  

ida_lines.get_sourcefile():
	
	  get_sourcefile(ea, bounds=None) -> char const *
	
	
	  Get name of source file occupying the given address.
	  
	  @param ea: linear address (C++: ea_t)
	  @param bounds: pointer to the output buffer with the address range for
	                 the current file. May be NULL. (C++: range_t  *)
	  @return: NULL if source file information is not found, otherwise
	           returns pointer to file name
	  

ida_lines.requires_color_esc():
	
	    Checks if the given character requires escaping
	    @param c: character (string of one char)
	    @return: Boolean
	
	
	    Is the given char a color escape character?
	    

ida_lines.set_user_defined_prefix():
	
	  set_user_defined_prefix(width, pycb) -> PyObject *
	
	
	  User-defined line-prefixes are displayed just after the autogenerated
	  line prefixes. In order to use them, the plugin should call the
	  following function to specify its width and contents.
	  @param width: the width of the user-defined prefix
	  @param callback: a get_user_defined_prefix callback to get the contents of the prefix.
	      Its arguments:
	        ea     - linear address
	        lnnum  - line number
	        indent - indent of the line contents (-1 means the default instruction)
	                 indent and is used for instruction itself. see explanations for printf_line()
	        line   - the line to be generated. the line usually contains color tags this argument
	                 can be examined to decide whether to generated the prefix
	      It returns a buffer of size < bufsize
	  
	  In order to remove the callback before unloading the plugin, specify the width = 0 or the callback = None
	  

ida_lines.tag_addr():
	
	  tag_addr(ea) -> PyObject *
	
	
	  Insert an address mark into a string.
	  
	  @param ea: address to include (C++: ea_t)
	  

ida_lines.tag_advance():
	
	  tag_advance(line, cnt) -> int
	
	
	  Move pointer to a 'line' to 'cnt' positions right. Take into account
	  escape sequences.
	  
	  @param line: pointer to string (C++: const char *)
	  @param cnt: number of positions to move right (C++: int)
	  @return: moved pointer
	  

ida_lines.tag_remove():
	
	  tag_remove(nonnul_instr) -> PyObject *
	
	
	  Remove color escape sequences from a string
	  @param colstr: the colored string with embedded tags
	  @return: a new string w/o the tags
	  

ida_lines.tag_skipcode():
	
	  tag_skipcode(line) -> int
	
	
	  Skip one color code. This function should be used if you are
	  interested in color codes and want to analyze all of them. Otherwise
	  'tag_skipcodes()' function is better since it will skip all colors at
	  once. This function will skip the current color code if there is one.
	  If the current symbol is not a color code, it will return the input.
	  
	  @param line (C++: const char *)
	  @return: moved pointer
	  

ida_lines.tag_skipcodes():
	
	  tag_skipcodes(line) -> int
	
	
	  Move the pointer past all color codes.
	  
	  @param line: can't be NULL (C++: const char *)
	  @return: moved pointer, can't be NULL
	  

ida_lines.tag_strlen():
	
	  tag_strlen(line) -> ssize_t
	
	
	  Calculate length of a colored string This function computes the length
	  in unicode codepoints of a line
	  
	  @param line (C++: const char *)
	  @return: the number of codepoints in the line, or -1 on error
	  

ida_lines.update_extra_cmt():
	
	  update_extra_cmt(ea, what, str)
	  


=== ida_lines EPYDOC INJECTIONS ===
ida_lines.COLOR_ADDR_SIZE
"""
Size of a tagged address (see 'COLOR_ADDR' )
"""

ida_lines.COLOR_BG_MAX
"""
Max color number.
"""

ida_lines.COLOR_CODE
"""
Single instruction.
"""

ida_lines.COLOR_CURITEM
"""
Current item.
"""

ida_lines.COLOR_CURLINE
"""
Current line.
"""

ida_lines.COLOR_DATA
"""
Data bytes.
"""

ida_lines.COLOR_DEFAULT
"""
Default.
"""

ida_lines.COLOR_ESC
"""
Escape character (Quote next character). This is needed to output '\1'
and '\2' characters.
"""

ida_lines.COLOR_EXTERN
"""
External name definition segment.
"""

ida_lines.COLOR_HIDLINE
"""
Hidden line.
"""

ida_lines.COLOR_INV
"""
Escape character (Inverse foreground and background colors). This
escape character has no corresponding 'COLOR_OFF' . Its action
continues until the next 'COLOR_INV' or end of line.
"""

ida_lines.COLOR_LIBFUNC
"""
Library function.
"""

ida_lines.COLOR_LUMFUNC
"""
Lumina function.
"""

ida_lines.COLOR_OFF
"""
Followed by a color code ( 'color_t' ).

Escape character (OFF).
"""

ida_lines.COLOR_ON
"""
Followed by a color code ( 'color_t' ).

Escape character (ON).
"""

ida_lines.COLOR_REGFUNC
"""
Regular function.
"""

ida_lines.COLOR_SELECTED
"""
Selected.
"""

ida_lines.COLOR_UNKNOWN
"""
Unexplored byte.
"""

ida_lines.SCOLOR_ADDR
"""
Hidden address mark.
"""

ida_lines.SCOLOR_ALTOP
"""
Alternative operand.
"""

ida_lines.SCOLOR_ASMDIR
"""
Assembler directive.
"""

ida_lines.SCOLOR_AUTOCMT
"""
Automatic comment.
"""

ida_lines.SCOLOR_BINPREF
"""
Binary line prefix bytes.
"""

ida_lines.SCOLOR_CHAR
"""
Char constant in instruction.
"""

ida_lines.SCOLOR_CNAME
"""
Regular code name.
"""

ida_lines.SCOLOR_CODNAME
"""
Dummy code name.
"""

ida_lines.SCOLOR_COLLAPSED
"""
Collapsed line.
"""

ida_lines.SCOLOR_CREF
"""
Code reference.
"""

ida_lines.SCOLOR_CREFTAIL
"""
Code reference to tail byte.
"""

ida_lines.SCOLOR_DATNAME
"""
Dummy Data Name.
"""

ida_lines.SCOLOR_DCHAR
"""
Char constant in data directive.
"""

ida_lines.SCOLOR_DEFAULT
"""
Default.
"""

ida_lines.SCOLOR_DEMNAME
"""
Demangled Name.
"""

ida_lines.SCOLOR_DNAME
"""
Regular Data Name.
"""

ida_lines.SCOLOR_DNUM
"""
Numeric constant in data directive.
"""

ida_lines.SCOLOR_DREF
"""
Data reference.
"""

ida_lines.SCOLOR_DREFTAIL
"""
Data reference to tail byte.
"""

ida_lines.SCOLOR_DSTR
"""
String constant in data directive.
"""

ida_lines.SCOLOR_ERROR
"""
Error or problem.
"""

ida_lines.SCOLOR_ESC
"""
Escape character (Quote next character)
"""

ida_lines.SCOLOR_EXTRA
"""
Extra line.
"""

ida_lines.SCOLOR_HIDNAME
"""
Hidden name.
"""

ida_lines.SCOLOR_IMPNAME
"""
Imported name.
"""

ida_lines.SCOLOR_INSN
"""
Instruction.
"""

ida_lines.SCOLOR_INV
"""
Escape character (Inverse colors)
"""

ida_lines.SCOLOR_KEYWORD
"""
Keywords.
"""

ida_lines.SCOLOR_LIBNAME
"""
Library function name.
"""

ida_lines.SCOLOR_LOCNAME
"""
Local variable name.
"""

ida_lines.SCOLOR_MACRO
"""
Macro.
"""

ida_lines.SCOLOR_NUMBER
"""
Numeric constant in instruction.
"""

ida_lines.SCOLOR_OFF
"""
Escape character (OFF)
"""

ida_lines.SCOLOR_ON
"""
Escape character (ON)
"""

ida_lines.SCOLOR_PREFIX
"""
Line prefix.
"""

ida_lines.SCOLOR_REG
"""
Register name.
"""

ida_lines.SCOLOR_REGCMT
"""
Regular comment.
"""

ida_lines.SCOLOR_RPTCMT
"""
Repeatable comment (defined not here)
"""

ida_lines.SCOLOR_SEGNAME
"""
Segment name.
"""

ida_lines.SCOLOR_STRING
"""
String constant in instruction.
"""

ida_lines.SCOLOR_SYMBOL
"""
Punctuation.
"""

ida_lines.SCOLOR_UNAME
"""
Regular unknown name.
"""

ida_lines.SCOLOR_UNKNAME
"""
Dummy unknown name.
"""

ida_lines.SCOLOR_VOIDOP
"""
Void operand.
"""
=== ida_lines EPYDOC INJECTIONS END ===
ida_loader.base2file():
	
	  base2file(fp, pos, ea1, ea2) -> int
	
	
	  Unload database to a binary file. This function works for wide byte
	  processors too.
	  
	  @param fp: pointer to file (C++: FILE *)
	  @param pos: position in the file (C++: qoff64_t)
	  @param ea1: range of source linear addresses (C++: ea_t)
	  @param ea2: range of source linear addresses (C++: ea_t)
	  @return: 1-ok(always), write error leads to immediate exit
	  

ida_loader.build_snapshot_tree():
	
	  build_snapshot_tree(root) -> bool
	
	
	  Build the snapshot tree.
	  
	  @param root: snapshot root that will contain the snapshot tree
	               elements. (C++: snapshot_t  *)
	  @return: success
	  

ida_loader.clr_database_flag():
	
	  clr_database_flag(dbfl)
	  

ida_loader.extract_module_from_archive():
	
	  extract_module_from_archive(filename, bufsize, temp_file_ptr, is_remote) -> bool
	
	
	  Extract a module for an archive file. Parse an archive file, show the
	  list of modules to the user, allow him to select a module, extract the
	  selected module to a file (if the extract module is an archive, repeat
	  the process). This function can handle ZIP, AR, AIXAR, OMFLIB files.
	  The temporary file will be automatically deleted by IDA at the end.
	  
	  @param filename: in: input file. out: name of the selected module.
	                   (C++: char *)
	  @param bufsize: size of the buffer with 'filename' (C++: size_t)
	  @param temp_file_ptr: will point to the name of the file that contains
	                        the extracted module (C++: char **)
	  @param is_remote: is the input file remote? (C++: bool)
	  

ida_loader.file2base():
	
	  file2base(li, pos, ea1, ea2, patchable) -> int
	
	
	  Load portion of file into the database. This function will include
	  (ea1..ea2) into the addressing space of the program (make it enabled)
	  
	  @param li: pointer of input source (C++: linput_t *)
	  @param pos: position in the file (C++: qoff64_t)
	  @param ea1: range of destination linear addresses (C++: ea_t)
	  @param ea2: range of destination linear addresses (C++: ea_t)
	  @param patchable: should the kernel remember correspondence of file
	                    offsets to linear addresses. (C++: int)
	  

ida_loader.find_plugin():
	
	  find_plugin(name, load_if_needed=False) -> plugin_t *
	
	
	  Find a user-defined plugin and optionally load it.
	  
	  @param name: short plugin name without path and extension, or absolute
	               path to the file name (C++: const char *)
	  @param load_if_needed: if the plugin is not present in the memory, try
	                         to load it (C++: bool)
	  @return: pointer to plugin description block
	  

ida_loader.flush_buffers():
	
	  flush_buffers() -> int
	
	
	  Flush buffers to the disk.
	  

ida_loader.gen_exe_file():
	
	  gen_exe_file(fp) -> int
	
	
	  Generate an exe file (unload the database in binary form).
	  
	  @param fp (C++: FILE *)
	  @return: fp the output file handle. if fp == NULL then return:   1:
	           can generate an executable file 0: can't generate an
	           executable file
	  

ida_loader.gen_file():
	
	  gen_file(otype, fp, ea1, ea2, flags) -> int
	
	
	  Generate an output file. 'OFILE_EXE' :
	  
	  @param otype: type of output file. (C++: ofile_type_t)
	  @param fp: the output file handle (C++: FILE *)
	  @param ea1: start address. For some file types this argument is
	              ignored (C++: ea_t)
	  @param ea2: end address. For some file types this argument is ignored
	              as usual in ida, the end address of the range is not
	              included (C++: ea_t)
	  @param flags: Generate file flags (C++: int)
	  @return: number of the generated lines. -1 if an error occurred
	  

ida_loader.get_basic_file_type():
	
	  get_basic_file_type(li) -> filetype_t
	
	
	  Get the input file type. This function can recognize libraries and zip
	  files.
	  
	  @param li (C++: linput_t *)
	  

ida_loader.get_elf_debug_file_directory():
	
	  get_elf_debug_file_directory() -> char const *
	
	
	  Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive.
	  

ida_loader.get_file_type_name():
	
	  get_file_type_name() -> size_t
	
	
	  Get name of the current file type. The current file type is kept in
	  {filetype}.
	  
	  @return: size of answer, this function always succeeds
	  

ida_loader.get_fileregion_ea():
	
	  get_fileregion_ea(offset) -> ea_t
	
	
	  Get linear address which corresponds to the specified input file
	  offset. If can't be found, return 'BADADDR'
	  
	  @param offset (C++: qoff64_t)
	  

ida_loader.get_fileregion_offset():
	
	  get_fileregion_offset(ea) -> qoff64_t
	
	
	  Get offset in the input file which corresponds to the given ea. If the
	  specified ea can't be mapped into the input file offset, return -1.
	  
	  @param ea (C++: ea_t)
	  

ida_loader.get_path():
	
	  get_path(pt) -> char const *
	
	
	  Get the file path
	  
	  @param pt: file path type  Types of the file pathes (C++: path_type_t)
	  @return: file path, never returns NULL
	  

ida_loader.get_plugin_options():
	
	  get_plugin_options(plugin) -> char const *
	
	
	  Get plugin options from the command line. If the user has specified
	  the options in the -Oplugin_name:options format, them this function
	  will return the 'options' part of it The 'plugin' parameter should
	  denote the plugin name Returns NULL if there we no options specified
	  
	  @param plugin (C++: const char *)
	  

class ida_loader.idp_desc_t():
	
	    Proxy of C++ idp_desc_t class
	    

ida_loader.idp_desc_t.checked:
	idp_desc_t_checked_get(self) -> bool

ida_loader.idp_desc_t.family:
	idp_desc_t_family_get(self) -> qstring *

ida_loader.idp_desc_t.is_script:
	idp_desc_t_is_script_get(self) -> bool

ida_loader.idp_desc_t.mtime:
	idp_desc_t_mtime_get(self) -> time_t

ida_loader.idp_desc_t.names:
	idp_desc_t_names_get(self) -> idp_names_t *

ida_loader.idp_desc_t.path:
	idp_desc_t_path_get(self) -> qstring *

class ida_loader.idp_name_t():
	
	    Proxy of C++ idp_name_t class
	    

ida_loader.idp_name_t.hidden:
	idp_name_t_hidden_get(self) -> bool

ida_loader.idp_name_t.lname:
	idp_name_t_lname_get(self) -> qstring *

ida_loader.idp_name_t.sname:
	idp_name_t_sname_get(self) -> qstring *

ida_loader.is_database_flag():
	
	  is_database_flag(dbfl) -> bool
	
	
	  Get the current database flag
	  
	  @param dbfl: flag  Database flags (C++: uint32)
	  @return: the state of the flag (set or cleared)
	  

ida_loader.is_trusted_idb():
	
	  is_trusted_idb() -> bool
	
	
	  Is the database considered as trusted?
	  

ida_loader.load_and_run_plugin():
	
	  load_and_run_plugin(name, arg) -> bool
	
	
	  Load & run a plugin.
	  
	  
	  @param name (C++: const char *)
	  @param arg (C++: size_t)
	  

ida_loader.load_binary_file():
	
	  load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool
	
	
	  Load a binary file into the database. This function usually is called
	  from ui.
	  
	  @param filename: the name of input file as is (if the input file is
	                   from library, then this is the name from the library)
	                   (C++: const char *)
	  @param li: loader input source (C++: linput_t *)
	  @param _neflags: Load file flags . For the first file, the flag
	                   NEF_FIRST  must be set. (C++: ushort)
	  @param fileoff: Offset in the input file (C++: qoff64_t)
	  @param basepara: Load address in paragraphs (C++: ea_t)
	  @param binoff: Load offset (load_address=(basepara<<4)+binoff) (C++:
	                 ea_t)
	  @param nbytes: Number of bytes to load from the file.   0: up to the
	                 end of the file (C++: uint64)
	  

ida_loader.load_ids_module():
	
	  load_ids_module(fname) -> int
	
	
	  Load and apply IDS file. This function loads the specified IDS file
	  and applies it to the database. If the program imports functions from
	  a module with the same name as the name of the ids file being loaded,
	  then only functions from this module will be affected. Otherwise (i.e.
	  when the program does not import a module with this name) any function
	  in the program may be affected.
	  
	  @param fname: name of file to apply (C++: char *)
	  

ida_loader.load_plugin():
	
	  load_plugin(name) -> PyObject *
	
	
	  Loads a plugin
	  @return:
	      - None if plugin could not be loaded
	      - An opaque object representing the loaded plugin
	  

class ida_loader.loader_t():
	
	    Proxy of C++ loader_t class
	    

ida_loader.loader_t.flags:
	loader_t_flags_get(self) -> uint32

ida_loader.loader_t.version:
	loader_t_version_get(self) -> uint32

ida_loader.mem2base():
	
	  mem2base(py_mem, ea, fpos=-1) -> int
	
	
	  Load database from the memory.
	  @param mem: the buffer
	  @param ea: start linear addresses
	  @param fpos: position in the input file the data is taken from.
	               if == -1, then no file position correspond to the data.
	  @return:
	      - Returns zero if the passed buffer was not a string
	      - Otherwise 1 is returned
	  

class ida_loader.plugin_info_t():
	
	    Proxy of C++ plugin_info_t class
	    

ida_loader.plugin_info_t.arg:
	plugin_info_t_arg_get(self) -> size_t

ida_loader.plugin_info_t.comment:
	plugin_info_t_comment_get(self) -> char *

ida_loader.plugin_info_t.dllmem:
	plugin_info_t_dllmem_get(self) -> idadll_t *

ida_loader.plugin_info_t.entry:
	plugin_info_t_entry_get(self) -> plugin_t *

ida_loader.plugin_info_t.flags:
	plugin_info_t_flags_get(self) -> int

ida_loader.plugin_info_t.hotkey:
	plugin_info_t_hotkey_get(self) -> ushort

ida_loader.plugin_info_t.name:
	plugin_info_t_name_get(self) -> char *

ida_loader.plugin_info_t.next:
	plugin_info_t_next_get(self) -> plugin_info_t

ida_loader.plugin_info_t.org_hotkey:
	plugin_info_t_org_hotkey_get(self) -> ushort

ida_loader.plugin_info_t.org_name:
	plugin_info_t_org_name_get(self) -> char *

ida_loader.plugin_info_t.path:
	plugin_info_t_path_get(self) -> char *

ida_loader.process_archive():
	
	  process_archive(temp_file, li, module_name, neflags, defmember, loader) -> int
	
	
	  Calls 'loader_t::process_archive()' For parameters and return value
	  description look at 'loader_t::process_archive()' . Additional
	  parameter:
	  
	  @param temp_file (C++: qstring  *)
	  @param li (C++: linput_t *)
	  @param module_name (C++: qstring  *)
	  @param neflags (C++: ushort  *)
	  @param defmember (C++: const char *)
	  @param loader: pointer to  load_info_t  structure. (C++: const
	                 load_info_t  *)
	  

class ida_loader.qvector_snapshotvec_t():
	
	    Proxy of C++ qvector<(p.snapshot_t)> class
	    

ida_loader.qvector_snapshotvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_loader.qvector_snapshotvec_t.at():
	
	        at(self, n) -> snapshot_t
	        

ida_loader.qvector_snapshotvec_t.begin():
	
	        begin(self) -> qvector< snapshot_t * >::iterator
	        begin(self) -> qvector< snapshot_t * >::const_iterator
	        

ida_loader.qvector_snapshotvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_loader.qvector_snapshotvec_t.clear():
	
	        clear(self)
	        

ida_loader.qvector_snapshotvec_t.empty():
	
	        empty(self) -> bool
	        

ida_loader.qvector_snapshotvec_t.end():
	
	        end(self) -> qvector< snapshot_t * >::iterator
	        end(self) -> qvector< snapshot_t * >::const_iterator
	        

ida_loader.qvector_snapshotvec_t.erase():
	
	        erase(self, it) -> qvector< snapshot_t * >::iterator
	        erase(self, first, last) -> qvector< snapshot_t * >::iterator
	        

ida_loader.qvector_snapshotvec_t.extract():
	
	        extract(self) -> snapshot_t **
	        

ida_loader.qvector_snapshotvec_t.find():
	
	        find(self, x) -> qvector< snapshot_t * >::iterator
	        find(self, x) -> qvector< snapshot_t * >::const_iterator
	        

ida_loader.qvector_snapshotvec_t.has():
	
	        has(self, x) -> bool
	        

ida_loader.qvector_snapshotvec_t.inject():
	
	        inject(self, s, len)
	        

ida_loader.qvector_snapshotvec_t.insert():
	
	        insert(self, it, x) -> qvector< snapshot_t * >::iterator
	        

ida_loader.qvector_snapshotvec_t.pop_back():
	
	        pop_back(self)
	        

ida_loader.qvector_snapshotvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> snapshot_t *&
	        

ida_loader.qvector_snapshotvec_t.qclear():
	
	        qclear(self)
	        

ida_loader.qvector_snapshotvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_loader.qvector_snapshotvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_loader.qvector_snapshotvec_t.size():
	
	        size(self) -> size_t
	        

ida_loader.qvector_snapshotvec_t.swap():
	
	        swap(self, r)
	        

ida_loader.qvector_snapshotvec_t.truncate():
	
	        truncate(self)
	        

ida_loader.reload_file():
	
	  reload_file(file, is_remote) -> int
	
	
	  Reload the input file. This function reloads the byte values from the
	  input file. It doesn't modify the segmentation, names, comments, etc.
	  
	  @param file: name of the input file. if file == NULL then returns:
	               1: can reload the input file 0: can't reload the input
	               file (C++: const char *)
	  @param is_remote: is the file located on a remote computer with the
	                    debugger server? (C++: bool)
	  

ida_loader.run_plugin():
	
	  run_plugin(plg, arg) -> bool
	
	
	  Runs a plugin
	  @param plg: A plugin object (returned by load_plugin())
	  @return: Boolean
	  

ida_loader.save_database():
	
	  save_database(outfile, flags, root=None, attr=None) -> bool
	
	
	  Save current database using a new file name.when both root and attr
	  are not NULL then the snapshot attributes will be updated, otherwise
	  the snapshot attributes will be inherited from the current database.
	  
	  @param outfile: output database file name (C++: const char *)
	  @param flags: Database flags (C++: uint32)
	  @param root: optional: snapshot tree root. (C++: const  snapshot_t  *)
	  @param attr: optional: snapshot attributes (C++: const  snapshot_t  *)
	  @return: success
	  

ida_loader.set_database_flag():
	
	  set_database_flag(dbfl, cnd=True)
	
	
	  Set or clear database flag
	  
	  @param dbfl: flag  Database flags (C++: uint32)
	  @param cnd: set if true or clear flag otherwise (C++: bool)
	  

ida_loader.set_path():
	
	  set_path(pt, path)
	
	
	  Set the file path
	  
	  @param pt: file path type  Types of the file pathes (C++: path_type_t)
	  @param path: new file path, use NULL or empty string to clear the file
	               path (C++: const char *)
	  

class ida_loader.snapshot_t():
	
	    Proxy of C++ snapshot_t class
	    

ida_loader.snapshot_t.children:
	snapshot_t_children_get(self) -> qvector_snapshotvec_t

ida_loader.snapshot_t.clear():
	
	        clear(self)
	        

ida_loader.snapshot_t.desc:
	snapshot_t_desc_get(self) -> char [128]

ida_loader.snapshot_t.filename:
	snapshot_t_filename_get(self) -> char [QMAXPATH]

ida_loader.snapshot_t.flags:
	snapshot_t_flags_get(self) -> uint16

ida_loader.snapshot_t.id:
	snapshot_t_id_get(self) -> qtime64_t


=== ida_loader EPYDOC INJECTIONS ===
ida_loader.ACCEPT_ARCHIVE
"""
Specify that a file format is served by archive loader See
'loader_t::accept_file'
"""

ida_loader.ACCEPT_CONTINUE
"""
Specify that the function must be called another time See
'loader_t::accept_file'
"""

ida_loader.ACCEPT_FIRST
"""
Specify that a file format should be place first in "load file" dialog
box. See 'loader_t::accept_file'
"""

ida_loader.DBFL_BAK
"""
create backup file (if !DBFL_KILL)
"""

ida_loader.DBFL_COMP
"""
collect garbage
"""

ida_loader.DBFL_KILL
"""
delete unpacked database
"""

ida_loader.DBFL_TEMP
"""
temporary database
"""

ida_loader.FILEREG_NOTPATCHABLE
"""
form in the file.

the data is kept in some encoded
"""

ida_loader.FILEREG_PATCHABLE
"""
means that the input file may be patched (i.e. no compression, no
iterated data, etc)
"""

ida_loader.GENFLG_ASMINC
"""
 'OFILE_ASM' , 'OFILE_LST' : gen information only about types
"""

ida_loader.GENFLG_ASMTYPE
"""
 'OFILE_ASM' , 'OFILE_LST' : gen information about types too
"""

ida_loader.GENFLG_GENHTML
"""
 'OFILE_ASM' , 'OFILE_LST' : generate html ( 'ui_genfile_callback'
will be used)
"""

ida_loader.GENFLG_IDCTYPE
"""
 'OFILE_IDC' : gen only information about types
"""

ida_loader.GENFLG_MAPDMNG
"""
 'OFILE_MAP' : demangle names
"""

ida_loader.GENFLG_MAPLOC
"""
 'OFILE_MAP' : include local names
"""

ida_loader.GENFLG_MAPNAME
"""
 'OFILE_MAP' : include dummy names
"""

ida_loader.GENFLG_MAPSEG
"""
 'OFILE_MAP' : generate map of segments
"""

ida_loader.LDRF_RELOAD
"""
loader recognizes 'NEF_RELOAD' flag
"""

ida_loader.LDRF_REQ_PROC
"""
Requires a processor to be set. if this bit is not set, load_file()
must call set_processor_type(..., SETPROC_LOADER)
"""

ida_loader.MAX_DATABASE_DESCRIPTION
"""
Maximum database snapshot description length.
"""

ida_loader.NEF_CODE
"""
load as a code segment

for 'load_binary_file()' :
"""

ida_loader.NEF_FILL
"""
Fill segment gaps.
"""

ida_loader.NEF_FIRST
"""
into the database.

This is the first file loaded
"""

ida_loader.NEF_FLAT
"""
Autocreate FLAT group (PE)
"""

ida_loader.NEF_IMPS
"""
Create import segment.
"""

ida_loader.NEF_LALL
"""
Load all segments without questions.
"""

ida_loader.NEF_LOPT
"""
Display additional loader options dialog.
"""

ida_loader.NEF_MAN
"""
Manual load.
"""

ida_loader.NEF_MINI
"""
Create mini database (do not copy segment bytes from the input file;
use only the file header metadata)
"""

ida_loader.NEF_NAME
"""
Rename entries.
"""

ida_loader.NEF_RELOAD
"""
reload the file at the same place: - don't create segmentsdon't create
fixup infodon't import segmentsetc load only the bytes into the base.
a loader should have 'LDRF_RELOAD' bit set
"""

ida_loader.NEF_RSCS
"""
Load resources.
"""

ida_loader.NEF_SEGS
"""
Create segments.
"""

ida_loader.PLUGIN_DLL
"""
Pattern to find plugin files.
"""

ida_loader.SSF_AUTOMATIC
"""
automatic snapshot
"""

ida_loader.SSUF_DESC
"""
Update the description.
"""

ida_loader.SSUF_FLAGS
"""
Update the flags.
"""

ida_loader.SSUF_PATH
"""
Update the path.
"""
=== ida_loader EPYDOC INJECTIONS END ===
class ida_moves.bookmarks_t():
	
	    Proxy of C++ bookmarks_t class
	    

ida_moves.bookmarks_t.erase():
	
	        erase(e, index, ud) -> bool
	        

ida_moves.bookmarks_t.find_index():
	
	        find_index(e, ud) -> uint32
	        

ida_moves.bookmarks_t.get():
	
	        get(out_entry, out_desc, index, ud) -> bool
	        

ida_moves.bookmarks_t.get_desc():
	
	        get_desc(e, index, ud) -> bool
	        

ida_moves.bookmarks_t.mark():
	
	        mark(e, index, title, desc, ud) -> uint32
	        

ida_moves.bookmarks_t.size():
	
	        size(e, ud) -> uint32
	        

ida_moves.bookmarks_t_erase():
	
	  bookmarks_t_erase(e, index, ud) -> bool
	  

ida_moves.bookmarks_t_find_index():
	
	  bookmarks_t_find_index(e, ud) -> uint32
	  

ida_moves.bookmarks_t_get():
	
	  bookmarks_t_get(out_entry, out_desc, index, ud) -> bool
	  

ida_moves.bookmarks_t_get_desc():
	
	  bookmarks_t_get_desc(e, index, ud) -> bool
	  

ida_moves.bookmarks_t_mark():
	
	  bookmarks_t_mark(e, index, title, desc, ud) -> uint32
	  

ida_moves.bookmarks_t_size():
	
	  bookmarks_t_size(e, ud) -> uint32
	  

class ida_moves.graph_location_info_t():
	
	    Proxy of C++ graph_location_info_t class
	    

ida_moves.graph_location_info_t.orgx:
	graph_location_info_t_orgx_get(self) -> double

ida_moves.graph_location_info_t.orgy:
	graph_location_info_t_orgy_get(self) -> double

ida_moves.graph_location_info_t.zoom:
	graph_location_info_t_zoom_get(self) -> double

class ida_moves.lochist_entry_t():
	
	    Proxy of C++ lochist_entry_t class
	    

ida_moves.lochist_entry_t.acquire_place():
	
	        acquire_place(self, p)
	        

ida_moves.lochist_entry_t.is_valid():
	
	        is_valid(self) -> bool
	        

ida_moves.lochist_entry_t.place():
	
	        place(self) -> place_t
	        place(self) -> place_t
	        

ida_moves.lochist_entry_t.plce:
	lochist_entry_t_plce_get(self) -> place_t

ida_moves.lochist_entry_t.renderer_info():
	
	        renderer_info(self) -> renderer_info_t
	        renderer_info(self) -> renderer_info_t
	        

ida_moves.lochist_entry_t.rinfo:
	lochist_entry_t_rinfo_get(self) -> renderer_info_t

ida_moves.lochist_entry_t.set_place():
	
	        set_place(self, p)
	        

class ida_moves.lochist_t():
	
	    Proxy of C++ lochist_t class
	    

ida_moves.lochist_t.back():
	
	        back(self, cnt, try_to_unhide) -> bool
	        

ida_moves.lochist_t.clear():
	
	        clear(self)
	        

ida_moves.lochist_t.current_index():
	
	        current_index(self) -> uint32
	        

ida_moves.lochist_t.fwd():
	
	        fwd(self, cnt, try_to_unhide) -> bool
	        

ida_moves.lochist_t.get():
	
	        get(self, out, index) -> bool
	        

ida_moves.lochist_t.get_current():
	
	        get_current(self) -> lochist_entry_t
	        

ida_moves.lochist_t.get_place_id():
	
	        get_place_id(self) -> int
	        

ida_moves.lochist_t.get_template_place():
	
	        get_template_place(self) -> place_t
	        

ida_moves.lochist_t.init():
	
	        init(self, stream_name, _defpos, _ud, _flags) -> bool
	        

ida_moves.lochist_t.is_history_enabled():
	
	        is_history_enabled(self) -> bool
	        

ida_moves.lochist_t.jump():
	
	        jump(self, try_to_unhide, e)
	        

ida_moves.lochist_t.netcode():
	
	        netcode(self) -> nodeidx_t
	        

ida_moves.lochist_t.save():
	
	        save(self)
	        

ida_moves.lochist_t.seek():
	
	        seek(self, index, try_to_unhide) -> bool
	        

ida_moves.lochist_t.set():
	
	        set(self, index, e)
	        

ida_moves.lochist_t.set_current():
	
	        set_current(self, e)
	        

ida_moves.lochist_t.size():
	
	        size(self) -> uint32
	        

class ida_moves.renderer_info_pos_t():
	
	    Proxy of C++ renderer_info_pos_t class
	    

ida_moves.renderer_info_pos_t.cx:
	renderer_info_pos_t_cx_get(self) -> short

ida_moves.renderer_info_pos_t.cy:
	renderer_info_pos_t_cy_get(self) -> short

ida_moves.renderer_info_pos_t.node:
	renderer_info_pos_t_node_get(self) -> int

class ida_moves.renderer_info_t():
	
	    Proxy of C++ renderer_info_t class
	    

ida_moves.renderer_info_t.clear():
	
	        clear(self)
	        

ida_moves.renderer_info_t.gli:
	renderer_info_t_gli_get(self) -> graph_location_info_t

ida_moves.renderer_info_t.pos:
	renderer_info_t_pos_get(self) -> renderer_info_pos_t

ida_moves.renderer_info_t.rtype:
	renderer_info_t_rtype_get(self) -> tcc_renderer_type_t

class ida_moves.segm_move_info_t():
	
	    Proxy of C++ segm_move_info_t class
	    

ida_moves.segm_move_info_t.size:
	segm_move_info_t_size_get(self) -> size_t

ida_moves.segm_move_info_t.to:
	segm_move_info_t_to_get(self) -> ea_t

class ida_moves.segm_move_info_vec_t():
	
	    Proxy of C++ qvector<(segm_move_info_t)> class
	    

ida_moves.segm_move_info_vec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_moves.segm_move_info_vec_t.at():
	
	        at(self, _idx) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.begin():
	
	        begin(self) -> segm_move_info_t
	        begin(self) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_moves.segm_move_info_vec_t.clear():
	
	        clear(self)
	        

ida_moves.segm_move_info_vec_t.empty():
	
	        empty(self) -> bool
	        

ida_moves.segm_move_info_vec_t.end():
	
	        end(self) -> segm_move_info_t
	        end(self) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.erase():
	
	        erase(self, it) -> segm_move_info_t
	        erase(self, first, last) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.extract():
	
	        extract(self) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.find():
	
	        find(self, x) -> segm_move_info_t
	        find(self, x) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.grow():
	
	        grow(self, x=segm_move_info_t())
	        

ida_moves.segm_move_info_vec_t.has():
	
	        has(self, x) -> bool
	        

ida_moves.segm_move_info_vec_t.inject():
	
	        inject(self, s, len)
	        

ida_moves.segm_move_info_vec_t.insert():
	
	        insert(self, it, x) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.pop_back():
	
	        pop_back(self)
	        

ida_moves.segm_move_info_vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> segm_move_info_t
	        

ida_moves.segm_move_info_vec_t.qclear():
	
	        qclear(self)
	        

ida_moves.segm_move_info_vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_moves.segm_move_info_vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_moves.segm_move_info_vec_t.size():
	
	        size(self) -> size_t
	        

ida_moves.segm_move_info_vec_t.swap():
	
	        swap(self, r)
	        

ida_moves.segm_move_info_vec_t.truncate():
	
	        truncate(self)
	        

class ida_moves.segm_move_infos_t():
	
	    Proxy of C++ segm_move_infos_t class
	    

ida_moves.segm_move_infos_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_moves.segm_move_infos_t.at():
	
	        at(self, _idx) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.begin():
	
	        begin(self) -> segm_move_info_t
	        begin(self) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_moves.segm_move_infos_t.clear():
	
	        clear(self)
	        

ida_moves.segm_move_infos_t.empty():
	
	        empty(self) -> bool
	        

ida_moves.segm_move_infos_t.end():
	
	        end(self) -> segm_move_info_t
	        end(self) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.erase():
	
	        erase(self, it) -> segm_move_info_t
	        erase(self, first, last) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.extract():
	
	        extract(self) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.find():
	
	        find(self, ea) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.grow():
	
	        grow(self, x=segm_move_info_t())
	        

ida_moves.segm_move_infos_t.has():
	
	        has(self, x) -> bool
	        

ida_moves.segm_move_infos_t.inject():
	
	        inject(self, s, len)
	        

ida_moves.segm_move_infos_t.insert():
	
	        insert(self, it, x) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.pop_back():
	
	        pop_back(self)
	        

ida_moves.segm_move_infos_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> segm_move_info_t
	        

ida_moves.segm_move_infos_t.qclear():
	
	        qclear(self)
	        

ida_moves.segm_move_infos_t.reserve():
	
	        reserve(self, cnt)
	        

ida_moves.segm_move_infos_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_moves.segm_move_infos_t.size():
	
	        size(self) -> size_t
	        

ida_moves.segm_move_infos_t.swap():
	
	        swap(self, r)
	        

ida_moves.segm_move_infos_t.truncate():
	
	        truncate(self)
	        

ida_nalt.add_encoding():
	
	  add_encoding(encoding) -> int
	
	
	  Add a new encoding (e.g. "UTF-8").
	  
	  @param encoding (C++: const char *)
	  @return: its index (1-based) if it's already in the list, return its
	           index
	  

class ida_nalt.array_parameters_t():
	
	    Proxy of C++ array_parameters_t class
	    

ida_nalt.array_parameters_t.alignment:
	array_parameters_t_alignment_get(self) -> int32

ida_nalt.array_parameters_t.flags:
	array_parameters_t_flags_get(self) -> int32

ida_nalt.array_parameters_t.lineitems:
	array_parameters_t_lineitems_get(self) -> int32

ida_nalt.clr__bnot0():
	
	  clr__bnot0(ea)
	  

ida_nalt.clr__bnot1():
	
	  clr__bnot1(ea)
	  

ida_nalt.clr__invsign0():
	
	  clr__invsign0(ea)
	  

ida_nalt.clr__invsign1():
	
	  clr__invsign1(ea)
	  

ida_nalt.clr_abits():
	
	  clr_abits(ea, bits)
	  

ida_nalt.clr_align_flow():
	
	  clr_align_flow(ea)
	  

ida_nalt.clr_colored_item():
	
	  clr_colored_item(ea)
	  

ida_nalt.clr_fixed_spd():
	
	  clr_fixed_spd(ea)
	  

ida_nalt.clr_has_lname():
	
	  clr_has_lname(ea)
	  

ida_nalt.clr_has_ti():
	
	  clr_has_ti(ea)
	  

ida_nalt.clr_has_ti0():
	
	  clr_has_ti0(ea)
	  

ida_nalt.clr_has_ti1():
	
	  clr_has_ti1(ea)
	  

ida_nalt.clr_libitem():
	
	  clr_libitem(ea)
	  

ida_nalt.clr_lzero0():
	
	  clr_lzero0(ea)
	  

ida_nalt.clr_lzero1():
	
	  clr_lzero1(ea)
	  

ida_nalt.clr_noret():
	
	  clr_noret(ea)
	  

ida_nalt.clr_notcode():
	
	  clr_notcode(ea)
	
	
	  Clear not-code mark.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_nalt.clr_notproc():
	
	  clr_notproc(ea)
	  

ida_nalt.clr_retfp():
	
	  clr_retfp(ea)
	  

ida_nalt.clr_terse_struc():
	
	  clr_terse_struc(ea)
	  

ida_nalt.clr_tilcmt():
	
	  clr_tilcmt(ea)
	  

ida_nalt.clr_usemodsp():
	
	  clr_usemodsp(ea)
	  

ida_nalt.clr_usersp():
	
	  clr_usersp(ea)
	  

ida_nalt.clr_userti():
	
	  clr_userti(ea)
	  

ida_nalt.clr_zstroff():
	
	  clr_zstroff(ea)
	  

class ida_nalt.custom_data_type_ids_fids_array():
	
	    Proxy of C++ wrapped_array_t<(int16,8)> class
	    

ida_nalt.custom_data_type_ids_fids_array.data:
	custom_data_type_ids_fids_array_data_get(self) -> short (&)[8]

class ida_nalt.custom_data_type_ids_t():
	
	    Proxy of C++ custom_data_type_ids_t class
	    

ida_nalt.custom_data_type_ids_t.dtid:
	custom_data_type_ids_t_dtid_get(self) -> int16

ida_nalt.custom_data_type_ids_t.fids:
	
	        __getFids(self) -> custom_data_type_ids_fids_array
	        

ida_nalt.dbg_get_input_path():
	
	  dbg_get_input_path() -> ssize_t
	
	
	  Get debugger input file name/path (see 'LFLG_DBG_NOPATH' )
	  

ida_nalt.del_absbase():
	
	  del_absbase(ea)
	  

ida_nalt.del_aflags():
	
	  del_aflags(ea)
	  

ida_nalt.del_alignment():
	
	  del_alignment(ea)
	  

ida_nalt.del_array_parameters():
	
	  del_array_parameters(ea)
	  

ida_nalt.del_custom_data_type_ids():
	
	  del_custom_data_type_ids(ea)
	  

ida_nalt.del_encoding():
	
	  del_encoding(idx) -> bool
	
	
	  Delete an encoding (1-based)
	  
	  
	  @param idx (C++: int)
	  

ida_nalt.del_ind_purged():
	
	  del_ind_purged(ea)
	  

ida_nalt.del_item_color():
	
	  del_item_color(ea) -> bool
	  

ida_nalt.del_op_tinfo():
	
	  del_op_tinfo(ea, n)
	  

ida_nalt.del_refinfo():
	
	  del_refinfo(ea, n) -> int
	  

ida_nalt.del_source_linnum():
	
	  del_source_linnum(ea)
	  

ida_nalt.del_str_type():
	
	  del_str_type(ea)
	  

ida_nalt.del_switch_info():
	
	  del_switch_info(ea)
	  

ida_nalt.del_switch_parent():
	
	  del_switch_parent(ea)
	  

ida_nalt.del_tinfo():
	
	  del_tinfo(ea)
	  

ida_nalt.delete_imports():
	
	  delete_imports()
	
	
	  Delete all imported modules information.
	  

ida_nalt.ea2node():
	
	  ea2node(ea) -> nodeidx_t
	
	
	  Get netnode for the specified address.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_nalt.encoding_from_strtype():
	
	  encoding_from_strtype(strtype) -> char const *
	
	
	  Get encoding name for this strtype.
	  
	  
	  @param strtype (C++: int32)
	  

class ida_nalt.enum_const_t():
	
	    Proxy of C++ enum_const_t class
	    

ida_nalt.enum_const_t.serial:
	enum_const_t_serial_get(self) -> uchar

ida_nalt.enum_const_t.tid:
	enum_const_t_tid_get(self) -> tid_t

ida_nalt.enum_import_names():
	
	  enum_import_names(mod_index, py_cb) -> int
	
	
	  Enumerate imports from a specific module.
	  Please refer to ex_imports.py example.
	  
	  @param mod_index: The module index
	  @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
	  @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)
	  

ida_nalt.find_custom_refinfo():
	
	  find_custom_refinfo(name) -> int
	
	
	  Get id of a custom refinfo type.
	  
	  
	  @param name (C++: const char *)
	  

ida_nalt.get_absbase():
	
	  get_absbase(ea) -> ea_t
	  

ida_nalt.get_aflags():
	
	  get_aflags(ea) -> uint32
	  

ida_nalt.get_alignment():
	
	  get_alignment(ea) -> uint32
	  

ida_nalt.get_archive_path():
	
	  get_archive_path() -> ssize_t
	
	
	  Get archive file path from which input file was extracted.
	  

ida_nalt.get_array_parameters():
	
	  get_array_parameters(out, ea) -> ssize_t
	  

ida_nalt.get_asm_inc_file():
	
	  get_asm_inc_file() -> ssize_t
	
	
	  Get name of the include file.
	  

ida_nalt.get_custom_data_type_ids():
	
	  get_custom_data_type_ids(cdis, ea) -> int
	  

ida_nalt.get_custom_refinfo():
	
	  get_custom_refinfo(crid) -> custom_refinfo_handler_t const *
	
	
	  Get definition of a registered custom refinfo type.
	  
	  
	  @param crid (C++: int)
	  

ida_nalt.get_default_encoding_idx():
	
	  get_default_encoding_idx(bpu) -> int
	
	
	  Get default encoding index for a specific string type.
	  
	  @param bpu: the amount of bytes per unit (e.g., 1 for ASCII, CP1252,
	              UTF-8..., 2 for UTF-16, 4 for UTF-32) 0 means no specific
	              encoding is set - byte values are displayed without
	              conversion. (C++: int)
	  

ida_nalt.get_encoding_bpu():
	
	  get_encoding_bpu(idx) -> int
	
	
	  Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32)
	  for the encoding with the given index.
	  
	  @param idx: the encoding index (C++: int)
	  @return: the number of bytes per units (1/2/4); -1 means error
	  

ida_nalt.get_encoding_name():
	
	  get_encoding_name(idx) -> char const *
	
	
	  Get encoding name for specific index (1-based).
	  
	  @param idx (C++: int)
	  @return: NULL if idx is out of bounds
	  

ida_nalt.get_encoding_qty():
	
	  get_encoding_qty() -> int
	
	
	  Get total number of encodings (counted from 0)
	  

ida_nalt.get_gotea():
	
	  get_gotea() -> ea_t
	  

ida_nalt.get_ids_modnode():
	
	  get_ids_modnode() -> netnode
	
	
	  Get ids modnode.
	  

ida_nalt.get_imagebase():
	
	  get_imagebase() -> ea_t
	
	
	  Get image base address.
	  

ida_nalt.get_import_module_name():
	
	  get_import_module_name(mod_index) -> PyObject *
	
	
	  Returns the name of an imported module given its index
	  @return: None or the module name
	  

ida_nalt.get_import_module_qty():
	
	  get_import_module_qty() -> uint
	
	
	  Get number of import modules.
	  

ida_nalt.get_ind_purged():
	
	  get_ind_purged(ea) -> ea_t
	  

ida_nalt.get_input_file_path():
	
	  get_input_file_path() -> ssize_t
	
	
	  Get full path of the input file.
	  

ida_nalt.get_item_color():
	
	  get_item_color(ea) -> bgcolor_t
	  

ida_nalt.get_op_tinfo():
	
	  get_op_tinfo(tif, ea, n) -> bool
	  

ida_nalt.get_outfile_encoding_idx():
	
	  get_outfile_encoding_idx() -> int
	
	
	  Get the index of the encoding used when producing files 0 means no
	  that the IDB's default 1 byte-per-unit encoding is used
	  

ida_nalt.get_refinfo():
	
	  get_refinfo(ri, ea, n) -> int
	  

ida_nalt.get_reftype_by_size():
	
	  get_reftype_by_size(size) -> reftype_t
	
	
	  Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other
	  sizes returns reftype_t(-1)
	  
	  @param size (C++: size_t)
	  

ida_nalt.get_root_filename():
	
	  get_root_filename() -> ssize_t
	
	
	  Get file name only of the input file.
	  

ida_nalt.get_source_linnum():
	
	  get_source_linnum(ea) -> uval_t
	  

ida_nalt.get_str_encoding_idx():
	
	  get_str_encoding_idx(strtype) -> uchar
	
	
	  Get index of the string encoding for this string.
	  
	  
	  @param strtype (C++: int32)
	  

ida_nalt.get_str_term1():
	
	  get_str_term1(strtype) -> char
	  

ida_nalt.get_str_term2():
	
	  get_str_term2(strtype) -> char
	  

ida_nalt.get_str_type():
	
	  get_str_type(ea) -> uint32
	  

ida_nalt.get_str_type_code():
	
	  get_str_type_code(strtype) -> uchar
	  

ida_nalt.get_strtype_bpu():
	
	  get_strtype_bpu(strtype) -> int
	  

ida_nalt.get_switch_parent():
	
	  get_switch_parent(ea) -> ea_t
	  

ida_nalt.get_tinfo():
	
	  get_tinfo(tif, ea) -> bool
	  

ida_nalt.getnode():
	
	  getnode(ea) -> netnode
	  

ida_nalt.has_lname():
	
	  has_lname(ea) -> bool
	  

ida_nalt.has_ti():
	
	  has_ti(ea) -> bool
	  

ida_nalt.has_ti0():
	
	  has_ti0(ea) -> bool
	  

ida_nalt.has_ti1():
	
	  has_ti1(ea) -> bool
	  

ida_nalt.hide_border():
	
	  hide_border(ea)
	  

ida_nalt.hide_item():
	
	  hide_item(ea)
	  

ida_nalt.is__bnot0():
	
	  is__bnot0(ea) -> bool
	  

ida_nalt.is__bnot1():
	
	  is__bnot1(ea) -> bool
	  

ida_nalt.is__invsign0():
	
	  is__invsign0(ea) -> bool
	  

ida_nalt.is__invsign1():
	
	  is__invsign1(ea) -> bool
	  

ida_nalt.is_align_flow():
	
	  is_align_flow(ea) -> bool
	  

ida_nalt.is_colored_item():
	
	  is_colored_item(ea) -> bool
	  

ida_nalt.is_finally_visible_item():
	
	  is_finally_visible_item(ea) -> bool
	
	
	  Is instruction visible?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_nalt.is_fixed_spd():
	
	  is_fixed_spd(ea) -> bool
	  

ida_nalt.is_hidden_border():
	
	  is_hidden_border(ea) -> bool
	  

ida_nalt.is_hidden_item():
	
	  is_hidden_item(ea) -> bool
	  

ida_nalt.is_libitem():
	
	  is_libitem(ea) -> bool
	  

ida_nalt.is_lzero0():
	
	  is_lzero0(ea) -> bool
	  

ida_nalt.is_lzero1():
	
	  is_lzero1(ea) -> bool
	  

ida_nalt.is_noret():
	
	  is_noret(ea) -> bool
	  

ida_nalt.is_notcode():
	
	  is_notcode(ea) -> bool
	
	
	  Is the address marked as not-code?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_nalt.is_notproc():
	
	  is_notproc(ea) -> bool
	  

ida_nalt.is_pascal():
	
	  is_pascal(strtype) -> bool
	  

ida_nalt.is_reftype_target_optional():
	
	  is_reftype_target_optional(type) -> bool
	
	
	  Can the target be calculated using operand value?
	  
	  
	  @param type (C++: reftype_t)
	  

ida_nalt.is_retfp():
	
	  is_retfp(ea) -> bool
	  

ida_nalt.is_terse_struc():
	
	  is_terse_struc(ea) -> bool
	  

ida_nalt.is_tilcmt():
	
	  is_tilcmt(ea) -> bool
	  

ida_nalt.is_usersp():
	
	  is_usersp(ea) -> bool
	  

ida_nalt.is_userti():
	
	  is_userti(ea) -> bool
	  

ida_nalt.is_visible_item():
	
	  is_visible_item(ea) -> bool
	
	
	  Test visibility of item at given ea.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_nalt.is_zstroff():
	
	  is_zstroff(ea) -> bool
	  

ida_nalt.node2ea():
	
	  node2ea(ndx) -> ea_t
	  

class ida_nalt.opinfo_t():
	
	    Proxy of C++ opinfo_t class
	    

ida_nalt.opinfo_t.cd:
	opinfo_t_cd_get(self) -> custom_data_type_ids_t

ida_nalt.opinfo_t.ec:
	opinfo_t_ec_get(self) -> enum_const_t

ida_nalt.opinfo_t.path:
	opinfo_t_path_get(self) -> strpath_t

ida_nalt.opinfo_t.ri:
	opinfo_t_ri_get(self) -> refinfo_t

ida_nalt.opinfo_t.strtype:
	opinfo_t_strtype_get(self) -> int32

ida_nalt.opinfo_t.tid:
	opinfo_t_tid_get(self) -> tid_t

class ida_nalt.printop_t():
	
	    Proxy of C++ printop_t class
	    

ida_nalt.printop_t.flags:
	printop_t_flags_get(self) -> flags_t

ida_nalt.printop_t.get_ti():
	
	        get_ti(self) -> opinfo_t
	        

ida_nalt.printop_t.is_ti_valid:
	printop_t_is_ti_valid_get(self) -> bool

ida_nalt.printop_t.suspop:
	printop_t_suspop_get(self) -> int

ida_nalt.printop_t.ti:
	printop_t_ti_get(self) -> opinfo_t

class ida_nalt.refinfo_t():
	
	    Proxy of C++ refinfo_t class
	    

ida_nalt.refinfo_t.base:
	refinfo_t_base_get(self) -> ea_t

ida_nalt.refinfo_t.flags:
	refinfo_t_flags_get(self) -> uint32

ida_nalt.refinfo_t.init():
	
	        init(self, reft_and_flags, _base=0, _target=BADADDR, _tdelta=0)
	        

ida_nalt.refinfo_t.is_custom():
	
	        is_custom(self) -> bool
	        

ida_nalt.refinfo_t.is_pastend():
	
	        is_pastend(self) -> bool
	        

ida_nalt.refinfo_t.is_rvaoff():
	
	        is_rvaoff(self) -> bool
	        

ida_nalt.refinfo_t.is_signed():
	
	        is_signed(self) -> bool
	        

ida_nalt.refinfo_t.is_subtract():
	
	        is_subtract(self) -> bool
	        

ida_nalt.refinfo_t.is_target_optional():
	
	        is_target_optional(self) -> bool
	        

ida_nalt.refinfo_t.no_base_xref():
	
	        no_base_xref(self) -> bool
	        

ida_nalt.refinfo_t.set_type():
	
	        set_type(self, t)
	        

ida_nalt.refinfo_t.target:
	refinfo_t_target_get(self) -> ea_t

ida_nalt.refinfo_t.tdelta:
	refinfo_t_tdelta_get(self) -> adiff_t

ida_nalt.refinfo_t.type():
	
	        type(self) -> reftype_t
	        

ida_nalt.rename_encoding():
	
	  rename_encoding(idx, encoding) -> bool
	
	
	  Change name for an encoding (1-based)
	  
	  
	  @param idx (C++: int)
	  @param encoding (C++: const char *)
	  

ida_nalt.retrieve_input_file_crc32():
	
	  retrieve_input_file_crc32() -> uint32
	
	
	  Get input file crc32 stored in the database. it can be used to check
	  that the input file has not been changed.
	  

ida_nalt.retrieve_input_file_md5():
	
	  retrieve_input_file_md5() -> bool
	
	
	  Get input file md5.
	  

ida_nalt.retrieve_input_file_sha256():
	
	  retrieve_input_file_sha256() -> bool
	
	
	  Get input file sha256.
	  

ida_nalt.retrieve_input_file_size():
	
	  retrieve_input_file_size() -> uint32
	
	
	  Get size of input file in bytes.
	  

ida_nalt.set__bnot0():
	
	  set__bnot0(ea)
	  

ida_nalt.set__bnot1():
	
	  set__bnot1(ea)
	  

ida_nalt.set__invsign0():
	
	  set__invsign0(ea)
	  

ida_nalt.set__invsign1():
	
	  set__invsign1(ea)
	  

ida_nalt.set_abits():
	
	  set_abits(ea, bits)
	  

ida_nalt.set_absbase():
	
	  set_absbase(ea, x)
	  

ida_nalt.set_aflags():
	
	  set_aflags(ea, flags)
	  

ida_nalt.set_align_flow():
	
	  set_align_flow(ea)
	  

ida_nalt.set_alignment():
	
	  set_alignment(ea, x)
	  

ida_nalt.set_archive_path():
	
	  set_archive_path(file) -> bool
	
	
	  Set archive file path from which input file was extracted.
	  
	  
	  @param file (C++: const char *)
	  

ida_nalt.set_array_parameters():
	
	  set_array_parameters(ea, _in)
	  

ida_nalt.set_asm_inc_file():
	
	  set_asm_inc_file(file) -> bool
	
	
	  Set name of the include file.
	  
	  
	  @param file (C++: const char *)
	  

ida_nalt.set_colored_item():
	
	  set_colored_item(ea)
	  

ida_nalt.set_custom_data_type_ids():
	
	  set_custom_data_type_ids(ea, cdis)
	  

ida_nalt.set_default_encoding_idx():
	
	  set_default_encoding_idx(bpu, idx) -> bool
	
	
	  set default encoding for a string type
	  
	  @param bpu: the amount of bytes per unit (C++: int)
	  @param idx: the encoding index idx can be 0 to disable encoding
	              conversion (C++: int)
	  

ida_nalt.set_fixed_spd():
	
	  set_fixed_spd(ea)
	  

ida_nalt.set_gotea():
	
	  set_gotea(gotea)
	  

ida_nalt.set_has_lname():
	
	  set_has_lname(ea)
	  

ida_nalt.set_has_ti():
	
	  set_has_ti(ea)
	  

ida_nalt.set_has_ti0():
	
	  set_has_ti0(ea)
	  

ida_nalt.set_has_ti1():
	
	  set_has_ti1(ea)
	  

ida_nalt.set_ids_modnode():
	
	  set_ids_modnode(id)
	
	
	  Set ids modnode.
	  
	  
	  @param id (C++: netnode)
	  

ida_nalt.set_imagebase():
	
	  set_imagebase(base)
	
	
	  Set image base address.
	  
	  
	  @param base (C++: ea_t)
	  

ida_nalt.set_item_color():
	
	  set_item_color(ea, color)
	  

ida_nalt.set_libitem():
	
	  set_libitem(ea)
	  

ida_nalt.set_lzero0():
	
	  set_lzero0(ea)
	  

ida_nalt.set_lzero1():
	
	  set_lzero1(ea)
	  

ida_nalt.set_noret():
	
	  set_noret(ea)
	  

ida_nalt.set_notcode():
	
	  set_notcode(ea)
	
	
	  Mark address so that it can not be converted to instruction.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_nalt.set_notproc():
	
	  set_notproc(ea)
	  

ida_nalt.set_op_tinfo():
	
	  set_op_tinfo(ea, n, tif) -> bool
	  

ida_nalt.set_outfile_encoding_idx():
	
	  set_outfile_encoding_idx(idx) -> bool
	
	
	  set encoding to be used when producing files
	  
	  @param idx: the encoding index idx can be 0 to use the IDB's default 1
	              -byte-per-unit encoding (C++: int)
	  

ida_nalt.set_refinfo():
	
	  set_refinfo(ea, n, type, target=BADADDR, base=0, tdelta=0) -> int
	  

ida_nalt.set_refinfo_ex():
	
	  set_refinfo_ex(ea, n, ri) -> int
	  

ida_nalt.set_retfp():
	
	  set_retfp(ea)
	  

ida_nalt.set_root_filename():
	
	  set_root_filename(file)
	
	
	  Set full path of the input file.
	  
	  
	  @param file (C++: const char *)
	  

ida_nalt.set_source_linnum():
	
	  set_source_linnum(ea, lnnum)
	  

ida_nalt.set_str_type():
	
	  set_str_type(ea, x)
	  

ida_nalt.set_switch_info():
	
	  set_switch_info(ea, _in)
	  

ida_nalt.set_switch_parent():
	
	  set_switch_parent(ea, x)
	  

ida_nalt.set_terse_struc():
	
	  set_terse_struc(ea)
	  

ida_nalt.set_tilcmt():
	
	  set_tilcmt(ea)
	  

ida_nalt.set_tinfo():
	
	  set_tinfo(ea, tif) -> bool
	  

ida_nalt.set_usemodsp():
	
	  set_usemodsp(ea)
	  

ida_nalt.set_usersp():
	
	  set_usersp(ea)
	  

ida_nalt.set_userti():
	
	  set_userti(ea)
	  

ida_nalt.set_visible_item():
	
	  set_visible_item(ea, visible)
	
	
	  Change visibility of item at given ea.
	  
	  
	  @param ea (C++: ea_t)
	  @param visible (C++: bool)
	  

ida_nalt.set_zstroff():
	
	  set_zstroff(ea)
	  

class ida_nalt.strpath_ids_array():
	
	    Proxy of C++ wrapped_array_t<(tid_t,32)> class
	    

class ida_nalt.strpath_t():
	
	    Proxy of C++ strpath_t class
	    

ida_nalt.strpath_t.delta:
	strpath_t_delta_get(self) -> adiff_t

ida_nalt.strpath_t.ids:
	
	        __getIds(self) -> strpath_ids_array
	        

ida_nalt.strpath_t.len:
	strpath_t_len_get(self) -> int

class ida_nalt.switch_info_t():
	
	    Proxy of C++ switch_info_t class
	    

ida_nalt.switch_info_t.assign():
	
	        assign(self, other)
	        

ida_nalt.switch_info_t.clear():
	
	        clear(self)
	        

ida_nalt.switch_info_t.custom:
	switch_info_t_custom_get(self) -> uval_t

ida_nalt.switch_info_t.defjump:
	switch_info_t_defjump_get(self) -> ea_t

ida_nalt.switch_info_t.elbase:
	switch_info_t_elbase_get(self) -> ea_t

ida_nalt.switch_info_t.expr_ea:
	switch_info_t_expr_ea_get(self) -> ea_t

ida_nalt.switch_info_t.flags:
	switch_info_t_flags_get(self) -> uint32

ida_nalt.switch_info_t.get_jrange_vrange():
	
	        get_jrange_vrange(self, jrange=None, vrange=None) -> bool
	        

ida_nalt.switch_info_t.get_jtable_element_size():
	
	        get_jtable_element_size(self) -> int
	        

ida_nalt.switch_info_t.get_jtable_size():
	
	        get_jtable_size(self) -> int
	        

ida_nalt.switch_info_t.get_lowcase():
	
	        get_lowcase(self) -> sval_t
	        

ida_nalt.switch_info_t.get_shift():
	
	        get_shift(self) -> int
	        

ida_nalt.switch_info_t.get_version():
	
	        get_version(self) -> int
	        

ida_nalt.switch_info_t.get_vtable_element_size():
	
	        get_vtable_element_size(self) -> int
	        

ida_nalt.switch_info_t.has_default():
	
	        has_default(self) -> bool
	        

ida_nalt.switch_info_t.has_elbase():
	
	        has_elbase(self) -> bool
	        

ida_nalt.switch_info_t.ind_lowcase:
	switch_info_t_ind_lowcase_get(self) -> sval_t

ida_nalt.switch_info_t.is_custom():
	
	        is_custom(self) -> bool
	        

ida_nalt.switch_info_t.is_indirect():
	
	        is_indirect(self) -> bool
	        

ida_nalt.switch_info_t.is_nolowcase():
	
	        is_nolowcase(self) -> bool
	        

ida_nalt.switch_info_t.is_sparse():
	
	        is_sparse(self) -> bool
	        

ida_nalt.switch_info_t.is_subtract():
	
	        is_subtract(self) -> bool
	        

ida_nalt.switch_info_t.jcases:
	switch_info_t_jcases_get(self) -> int

ida_nalt.switch_info_t.jumps:
	switch_info_t_jumps_get(self) -> ea_t

ida_nalt.switch_info_t.lowcase:
	
	        _get_values_lowcase(self) -> ea_t
	        

ida_nalt.switch_info_t.marks:
	switch_info_t_marks_get(self) -> eavec_t *

ida_nalt.switch_info_t.ncases:
	switch_info_t_ncases_get(self) -> ushort

ida_nalt.switch_info_t.regdtype:
	switch_info_t_regdtype_get(self) -> op_dtype_t

ida_nalt.switch_info_t.regnum:
	switch_info_t_regnum_get(self) -> int

ida_nalt.switch_info_t.set_expr():
	
	        set_expr(self, r, dt)
	        

ida_nalt.switch_info_t.set_jtable_element_size():
	
	        set_jtable_element_size(self, size)
	        

ida_nalt.switch_info_t.set_jtable_size():
	
	        set_jtable_size(self, size)
	        

ida_nalt.switch_info_t.set_shift():
	
	        set_shift(self, shift)
	        

ida_nalt.switch_info_t.set_vtable_element_size():
	
	        set_vtable_element_size(self, size)
	        

ida_nalt.switch_info_t.startea:
	switch_info_t_startea_get(self) -> ea_t

ida_nalt.switch_info_t.use_std_table():
	
	        use_std_table(self) -> bool
	        

ida_nalt.switch_info_t.values:
	
	        _get_values_lowcase(self) -> ea_t
	        

ida_nalt.switch_info_t__from_ptrval__():
	
	  switch_info_t__from_ptrval__(ptrval) -> switch_info_t
	  

ida_nalt.unhide_border():
	
	  unhide_border(ea)
	  

ida_nalt.unhide_item():
	
	  unhide_item(ea)
	  

ida_nalt.uses_modsp():
	
	  uses_modsp(ea) -> bool
	  

ida_nalt.validate_idb_names():
	
	  validate_idb_names(do_repair) -> int
	  


=== ida_nalt EPYDOC INJECTIONS ===
ida_nalt.AFL_ALIGNFLOW
"""
the previous insn was created for alignment purposes only
"""

ida_nalt.AFL_BNOT0
"""
the 1st operand is bitwise negated
"""

ida_nalt.AFL_BNOT1
"""
the 2nd operand is bitwise negated
"""

ida_nalt.AFL_COLORED
"""
has user defined instruction color?
"""

ida_nalt.AFL_FIXEDSPD
"""
should not be modified by modules

sp delta value is fixed by analysis.
"""

ida_nalt.AFL_HIDDEN
"""
the item is hidden completely
"""

ida_nalt.AFL_LIB
"""
item from the standard library. low level flag, is used to set
'FUNC_LIB' of 'func_t'
"""

ida_nalt.AFL_LINNUM
"""
has line number info
"""

ida_nalt.AFL_LNAME
"""
has local name too ( 'FF_NAME' should be set)
"""

ida_nalt.AFL_LZERO0
"""
toggle leading zeroes for the 1st operand
"""

ida_nalt.AFL_LZERO1
"""
toggle leading zeroes for the 2nd operand
"""

ida_nalt.AFL_MANUAL
"""
the instruction/data is specified by the user
"""

ida_nalt.AFL_NOBRD
"""
the code/data border is hidden
"""

ida_nalt.AFL_NORET
"""
for imported function pointers: doesn't return. this flag can also be
used for any instruction which halts or finishes the program execution
"""

ida_nalt.AFL_NOTCODE
"""
autoanalysis should not create code here
"""

ida_nalt.AFL_NOTPROC
"""
autoanalysis should not create proc here
"""

ida_nalt.AFL_PUBNAM
"""
name is public (inter-file linkage)
"""

ida_nalt.AFL_RETFP
"""
function returns a floating point value
"""

ida_nalt.AFL_SIGN0
"""
code: toggle sign of the 1st operand
"""

ida_nalt.AFL_SIGN1
"""
code: toggle sign of the 2nd operand
"""

ida_nalt.AFL_TERSESTR
"""
terse structure variable display?
"""

ida_nalt.AFL_TI
"""
has typeinfo? ( 'NSUP_TYPEINFO' )
"""

ida_nalt.AFL_TI0
"""
has typeinfo for operand 0? ( 'NSUP_OPTYPES' )
"""

ida_nalt.AFL_TI1
"""
has typeinfo for operand 1? ( 'NSUP_OPTYPES' +1)
"""

ida_nalt.AFL_TILCMT
"""
has type comment? (such a comment may be changed by IDA)
"""

ida_nalt.AFL_USEMODSP
"""
example: pop [rsp+N]

insn modifes SP and uses the modified value
"""

ida_nalt.AFL_USERSP
"""
user-defined SP value
"""

ida_nalt.AFL_USERTI
"""
(comes from the user or type library)

the type information is definitive.
"""

ida_nalt.AFL_WEAKNAM
"""
name is weak
"""

ida_nalt.AFL_ZSTROFF
"""
display struct field name at 0 offset when displaying an offset.
example: {offset somestruct.field_0} if this flag is clear, then
{offset somestruct}
"""

ida_nalt.AP_ALLOWDUPS
"""
use 'dup' construct
"""

ida_nalt.AP_ARRAY
"""
create as array (this flag is not stored in database)
"""

ida_nalt.AP_IDXBASEMASK
"""
mask for number base of the indexes
"""

ida_nalt.AP_IDXBIN
"""
display indexes in binary
"""

ida_nalt.AP_IDXDEC
"""
display indexes in decimal
"""

ida_nalt.AP_IDXHEX
"""
display indexes in hex
"""

ida_nalt.AP_IDXOCT
"""
display indexes in octal
"""

ida_nalt.AP_INDEX
"""
display array element indexes as comments
"""

ida_nalt.AP_SIGNED
"""
treats numbers as signed
"""

ida_nalt.MAXSTRUCPATH
"""
maximal inclusion depth of unions
"""

ida_nalt.NALT_ABSBASE
"""
absolute segment location
"""

ida_nalt.NALT_AFLAGS
"""
additional flags for an item
"""

ida_nalt.NALT_ALIGN
"""
(should by equal to power of 2)

alignment value if the item is 'FF_ALIGN'
"""

ida_nalt.NALT_COLOR
"""
instruction/data background color
"""

ida_nalt.NALT_CREF_FROM
"""
code xref from, idx: source address
"""

ida_nalt.NALT_CREF_TO
"""
code xref to, idx: target address
"""

ida_nalt.NALT_DREF_FROM
"""
data xref from, idx: source address
"""

ida_nalt.NALT_DREF_TO
"""
data xref to, idx: target address
"""

ida_nalt.NALT_ENUM0
"""
enum id for the first operand
"""

ida_nalt.NALT_ENUM1
"""
enum id for the second operand
"""

ida_nalt.NALT_GR_LAYX
"""
group layout ptrs, hash: md5 of 'belongs'
"""

ida_nalt.NALT_LINNUM
"""
source line number
"""

ida_nalt.NALT_PURGE
"""
number of bytes purged from the stack when a function is called
indirectly
"""

ida_nalt.NALT_STRTYPE
"""
type of string item
"""

ida_nalt.NALT_STRUCT
"""
struct id
"""

ida_nalt.NALT_SWITCH
"""
switch idiom address (used at jump targets)
"""

ida_nalt.NSUP_ARGEAS
"""
instructions that initialize call arguments
"""

ida_nalt.NSUP_ARRAY
"""
array parameters
"""

ida_nalt.NSUP_CMT
"""
regular comment
"""

ida_nalt.NSUP_CUSTDT
"""
custom data type id
"""

ida_nalt.NSUP_FOP1
"""
forced operand 1
"""

ida_nalt.NSUP_FOP2
"""
forced operand 2
"""

ida_nalt.NSUP_FOP3
"""
forced operand 3
"""

ida_nalt.NSUP_FOP4
"""
forced operand 4
"""

ida_nalt.NSUP_FOP5
"""
forced operand 5
"""

ida_nalt.NSUP_FOP6
"""
forced operand 6
"""

ida_nalt.NSUP_FOP7
"""
forced operand 7
"""

ida_nalt.NSUP_FOP8
"""
forced operand 8
"""

ida_nalt.NSUP_FTAILS
"""
function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000
are reserved
"""

ida_nalt.NSUP_GROUP
"""
graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are
reserved
"""

ida_nalt.NSUP_GROUPS
"""
SEG_GRP: pack_dd encoded list of selectors.
"""

ida_nalt.NSUP_GR_INFO
"""
group node info: color, ea, text
"""

ida_nalt.NSUP_GR_LAYT
"""
group layouts, idx: layout pointer
"""

ida_nalt.NSUP_JINFO
"""
jump table info
"""

ida_nalt.NSUP_LLABEL
"""
local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved
"""

ida_nalt.NSUP_MANUAL
"""
manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are
reserved
"""

ida_nalt.NSUP_OMFGRP
"""
OMF: group of segments (not used anymore)
"""

ida_nalt.NSUP_OPTYPES
"""
operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000
are reserved
"""

ida_nalt.NSUP_OREF0
"""
outer complex reference information for operand 1
"""

ida_nalt.NSUP_OREF1
"""
outer complex reference information for operand 2
"""

ida_nalt.NSUP_OREF2
"""
outer complex reference information for operand 3
"""

ida_nalt.NSUP_OREF3
"""
outer complex reference information for operand 4
"""

ida_nalt.NSUP_OREF4
"""
outer complex reference information for operand 5
"""

ida_nalt.NSUP_OREF5
"""
outer complex reference information for operand 6
"""

ida_nalt.NSUP_OREF6
"""
outer complex reference information for operand 7
"""

ida_nalt.NSUP_OREF7
"""
outer complex reference information for operand 8
"""

ida_nalt.NSUP_POINTS
"""
SP change points blob (see funcs.cpp). values
NSUP_POINTS..NSUP_POINTS+0x1000 are reserved
"""

ida_nalt.NSUP_REF0
"""
complex reference information for operand 1
"""

ida_nalt.NSUP_REF1
"""
complex reference information for operand 2
"""

ida_nalt.NSUP_REF2
"""
complex reference information for operand 3
"""

ida_nalt.NSUP_REF3
"""
complex reference information for operand 4
"""

ida_nalt.NSUP_REF4
"""
complex reference information for operand 5
"""

ida_nalt.NSUP_REF5
"""
complex reference information for operand 6
"""

ida_nalt.NSUP_REF6
"""
complex reference information for operand 7
"""

ida_nalt.NSUP_REF7
"""
complex reference information for operand 8
"""

ida_nalt.NSUP_REGARG
"""
register argument type/name descriptions values
NSUP_REGARG..NSUP_REGARG+0x1000 are reserved
"""

ida_nalt.NSUP_REGVAR
"""
register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are
reserved
"""

ida_nalt.NSUP_REPCMT
"""
repeatable comment
"""

ida_nalt.NSUP_SEGTRANS
"""
segment translations
"""

ida_nalt.NSUP_STROFF0
"""
stroff: struct path for the first operand
"""

ida_nalt.NSUP_STROFF1
"""
stroff: struct path for the second operand
"""

ida_nalt.NSUP_SWITCH
"""
switch information
"""

ida_nalt.NSUP_TYPEINFO
"""
type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are
reserved
"""

ida_nalt.NSUP_XREFPOS
"""
saved xref address and type in the xrefs window
"""

ida_nalt.PATCH_TAG
"""
Patch netnode tag.
"""

ida_nalt.REFINFO_CUSTOM
"""
a custom reference the kernel will call {notify}(ph.custom_offset,
.... that can change all arguments used for calculations. This flag is
useful for custom fixups
"""

ida_nalt.REFINFO_NOBASE
"""
don't create the base xref implies that the base can be any value nb:
base xrefs are created only if the offset base points to the middle of
a segment
"""

ida_nalt.REFINFO_PASTEND
"""
reference past an item it may point to an nonexistent address do not
destroy alignment dirs
"""

ida_nalt.REFINFO_RVAOFF
"""
based reference (rva) 'refinfo_t::base' will be forced to
'get_imagebase()' such a reference is displayed with the {a_rva}
keyword
"""

ida_nalt.REFINFO_SIGNEDOP
"""
the operand value is sign-extended (only supported for
REF_OFF8/16/32/64)
"""

ida_nalt.REFINFO_SUBTRACT
"""
the reference value is subtracted from the base value instead of (as
usual) being added to it
"""

ida_nalt.REFINFO_TYPE
"""
reference type
"""

ida_nalt.RIDX_ABINAME
"""
ABI name (processor specific)
"""

ida_nalt.RIDX_ARCHIVE_PATH
"""
archive file path
"""

ida_nalt.RIDX_C_MACROS
"""
C predefined macros.
"""

ida_nalt.RIDX_DBG_BINPATHS
"""
debug binary paths, occupies 20 indexes
"""

ida_nalt.RIDX_DUALOP_GRAPH
"""
Graph text representation options.
"""

ida_nalt.RIDX_DUALOP_TEXT
"""
Text text representation options.
"""

ida_nalt.RIDX_FILE_FORMAT_NAME
"""
file format name for loader modules
"""

ida_nalt.RIDX_GROUPS
"""
segment group information (see init_groups())
"""

ida_nalt.RIDX_H_PATH
"""
C header path.
"""

ida_nalt.RIDX_IDA_VERSION
"""
version of ida which created the database
"""

ida_nalt.RIDX_INCLUDE
"""
assembler include file name
"""

ida_nalt.RIDX_MD5
"""
MD5 of the input file.
"""

ida_nalt.RIDX_NOTEPAD
"""
notepad blob, occupies 1000 indexes (1MB of text)
"""

ida_nalt.RIDX_PROBLEMS
"""
problem lists
"""

ida_nalt.RIDX_SELECTED_EXTLANG
"""
last selected extlang name (from the execute script box)
"""

ida_nalt.RIDX_SELECTORS
"""
2..63 are for selector_t blob (see init_selectors())
"""

ida_nalt.RIDX_SHA256
"""
SHA256 of the input file.
"""

ida_nalt.RIDX_SMALL_IDC
"""
Instant IDC statements, blob.
"""

ida_nalt.RIDX_SMALL_IDC_OLD
"""
Instant IDC statements (obsolete)
"""

ida_nalt.RIDX_SRCDBG_PATHS
"""
source debug paths, occupies 20 indexes
"""

ida_nalt.RIDX_STR_ENCODINGS
"""
a list of encodings for the program strings
"""

ida_nalt.STRENC_DEFAULT
"""
use default encoding for this type (see 'get_default_encoding_idx()' )
"""

ida_nalt.STRENC_NONE
"""
force no-conversion encoding
"""

ida_nalt.STRTYPE_C
"""
Zero-terminated 16bit chars.
"""

ida_nalt.STRTYPE_C_16
"""
Zero-terminated 32bit chars.
"""

ida_nalt.STRTYPE_C_32
"""
Pascal-style, one-byte length prefix.
"""

ida_nalt.STRTYPE_LEN2
"""
Pascal-style, 16bit chars, two-byte length prefix.
"""

ida_nalt.STRTYPE_LEN2_16
"""
Pascal-style, four-byte length prefix.
"""

ida_nalt.STRTYPE_LEN4
"""
Pascal-style, 16bit chars, four-byte length prefix.
"""

ida_nalt.STRTYPE_PASCAL
"""
Pascal-style, 16bit chars, one-byte length prefix.
"""

ida_nalt.STRTYPE_PASCAL_16
"""
Pascal-style, two-byte length prefix.
"""

ida_nalt.STRTYPE_TERMCHR
"""
C-style string.

< Character-terminated string. The termination characters are kept in
the next bytes of string type.
"""

ida_nalt.SWI_CUSTOM
"""
custom jump table. {create_switch_xrefs} will be called to create code
xrefs for the table. Custom jump table must be created by the module
(see also 'SWI_STDTBL' )
"""

ida_nalt.SWI_DEFRET
"""
return in the default case (defjump==BADADDR)
"""

ida_nalt.SWI_DEF_IN_TBL
"""
default case is an entry in the jump table. This flag is applicable in
2 cases:The sparse indirect switch (i.e. a switch with a values table)
<jump table="" size>=""> ==+ 1. The default case entry is the last one
in the table (or the first one in the case of an inversed jump
table).The switch with insns in the jump table. The default case entry
is before the first entry of the table. See also the
find_defjump_from_table() helper function.
"""

ida_nalt.SWI_ELBASE
"""
segment will be used)

elbase is present (otherwise the base of the switch
"""

ida_nalt.SWI_HXNOLOWCASE
"""
lowcase value should not be used by the decompiler (internal flag)
"""

ida_nalt.SWI_INDIRECT
"""
(for sparse switches)

value table elements are used as indexes into the jump table
"""

ida_nalt.SWI_J32
"""
32-bit jump offsets
"""

ida_nalt.SWI_JMPINSN
"""
jump table entries are insns. For such entries SHIFT has a different
meaning. It denotes the number of insns in the entry. For example, 0 -
the entry contains the jump to the case, 1 - the entry contains one
insn like a 'mov' and jump to the end of case, and so on.
"""

ida_nalt.SWI_JMP_INV
"""
for first entry in values table)

jumptable is inversed. (last entry is
"""

ida_nalt.SWI_JSIZE
"""
jump offset expansion bit
"""

ida_nalt.SWI_RESERVED
"""
was: SWI_DEFAULT
"""

ida_nalt.SWI_SELFREL
"""
jump address is relative to the element not to ELBASE
"""

ida_nalt.SWI_SEPARATE
"""
create an array of individual elements (otherwise separate items)
"""

ida_nalt.SWI_SHIFT_MASK
"""
use formula (element<<shift) + elbase to find jump targets
"""

ida_nalt.SWI_SIGNED
"""
jump table entries are signed
"""

ida_nalt.SWI_SPARSE
"""
otherwise lowcase present

sparse switch (value table present)
"""

ida_nalt.SWI_STDTBL
"""
custom jump table with standard table formatting. ATM IDA doesn't use
SWI_CUSTOM for switches with standard table formatting. So this flag
can be considered as obsolete.
"""

ida_nalt.SWI_SUBTRACT
"""
table values are subtracted from the elbase instead of being added
"""

ida_nalt.SWI_V32
"""
32-bit values in table
"""

ida_nalt.SWI_VERSION
"""
the structure contains the VERSION member
"""

ida_nalt.SWI_VSIZE
"""
value table element size expansion bit
"""

ida_nalt.SWI_VSPLIT
"""
value table is split (only for 32-bit values)
"""
=== ida_nalt EPYDOC INJECTIONS END ===
class ida_name.NearestName():
	
	    Utility class to help find the nearest name in a given ea/name dictionary
	    

ida_name.NearestName.find():
	
	        Returns a tupple (ea, name, pos) that is the nearest to the passed ea
	        If no name is matched then None is returned
	        

ida_name.NearestName.update():
	
	        Updates the ea/names map
	        

ida_name.append_struct_fields():
	
	  append_struct_fields(disp, n, path, flags, delta, appzero) -> flags_t
	
	
	  Append names of struct fields to a name if the name is a struct name.
	  
	  @param disp: displacement from the name (C++: adiff_t *)
	  @param n: number of operand n which the name appears (C++: int)
	  @param path: path in the struct. path is an array of id's. maximal
	               length of array is  MAXSTRUCPATH . the first element of
	               the array is the structure id. consecutive elements are
	               id's of used union members (if any). (C++: const  tid_t
	               *)
	  @param flags: the input flags. they will be returned if the struct
	                cannot be found. (C++: flags_t)
	  @param delta: delta to add to displacement (C++: adiff_t)
	  @param appzero: should append a struct field name if the displacement
	                  is zero? (C++: bool)
	  @return: flags of the innermost struct member or the input flags
	  

ida_name.calc_gtn_flags():
	
	    Calculate flags for get_ea_name() function
	
	    @param fromaddr: the referring address. May be BADADDR.
	    @param ea: linear address
	
	    @return: flags
	    

ida_name.cleanup_name():
	
	  cleanup_name(ea, name, flags=0) -> bool
	  

ida_name.del_debug_names():
	
	  del_debug_names(ea1, ea2)
	  

ida_name.del_global_name():
	
	  del_global_name(ea) -> bool
	  

ida_name.del_local_name():
	
	  del_local_name(ea) -> bool
	  

ida_name.demangle_name():
	
	  demangle_name(name, disable_mask, demreq=DQT_FULL) -> int32
	
	
	  Demangle a name.
	  
	  @param name: name to demangle (C++: const char *)
	  @param disable_mask: bits to inhibit parts of demangled name (see
	                       MNG_). by the M_COMPILER bits a specific compiler
	                       can be selected (see MT_). (C++: uint32)
	  @param demreq (C++: demreq_type_t)
	  @return: ME_... or MT__ bitmasks from  demangle.hpp
	  

class ida_name.ea_name_t():
	
	    Proxy of C++ ea_name_t class
	    

ida_name.ea_name_t.ea:
	ea_name_t_ea_get(self) -> ea_t

ida_name.ea_name_t.name:
	ea_name_t_name_get(self) -> qstring *

class ida_name.ea_name_vec_t():
	
	    Proxy of C++ qvector<(ea_name_t)> class
	    

ida_name.ea_name_vec_t.at():
	
	        at(self, _idx) -> ea_name_t
	        

ida_name.ea_name_vec_t.begin():
	
	        begin(self) -> ea_name_t
	        begin(self) -> ea_name_t
	        

ida_name.ea_name_vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_name.ea_name_vec_t.clear():
	
	        clear(self)
	        

ida_name.ea_name_vec_t.empty():
	
	        empty(self) -> bool
	        

ida_name.ea_name_vec_t.end():
	
	        end(self) -> ea_name_t
	        end(self) -> ea_name_t
	        

ida_name.ea_name_vec_t.erase():
	
	        erase(self, it) -> ea_name_t
	        erase(self, first, last) -> ea_name_t
	        

ida_name.ea_name_vec_t.extract():
	
	        extract(self) -> ea_name_t
	        

ida_name.ea_name_vec_t.grow():
	
	        grow(self, x=ea_name_t())
	        

ida_name.ea_name_vec_t.inject():
	
	        inject(self, s, len)
	        

ida_name.ea_name_vec_t.insert():
	
	        insert(self, it, x) -> ea_name_t
	        

ida_name.ea_name_vec_t.pop_back():
	
	        pop_back(self)
	        

ida_name.ea_name_vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> ea_name_t
	        

ida_name.ea_name_vec_t.qclear():
	
	        qclear(self)
	        

ida_name.ea_name_vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_name.ea_name_vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_name.ea_name_vec_t.size():
	
	        size(self) -> size_t
	        

ida_name.ea_name_vec_t.swap():
	
	        swap(self, r)
	        

ida_name.ea_name_vec_t.truncate():
	
	        truncate(self)
	        

ida_name.extract_name():
	
	  extract_name(line, x) -> ssize_t
	
	
	  Extract a name or address from the specified string.
	  
	  @param line: input string (C++: const char *)
	  @param x: x coordinate of cursor (C++: int)
	  @return: -1 if can not extract. otherwise length of the name
	  

ida_name.force_name():
	
	  force_name(ea, name, flags=0) -> bool
	  

ida_name.get_colored_demangled_name():
	
	  get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
	  

ida_name.get_colored_long_name():
	
	  get_colored_long_name(ea, gtn_flags=0) -> qstring
	  

ida_name.get_colored_name():
	
	  get_colored_name(ea) -> qstring
	  

ida_name.get_colored_short_name():
	
	  get_colored_short_name(ea, gtn_flags=0) -> qstring
	  

ida_name.get_debug_name():
	
	  get_debug_name(ea_ptr, how) -> ssize_t
	  

ida_name.get_debug_name_ea():
	
	  get_debug_name_ea(name) -> ea_t
	  

ida_name.get_debug_names():
	
	    get_debug_names(names, ea1, ea2)
	    get_debug_names(ea1, ea2) -> PyObject *
	    

ida_name.get_demangled_name():
	
	  get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
	  

ida_name.get_ea_name():
	
	  get_ea_name(ea, gtn_flags=0) -> qstring
	
	
	  Get name at the specified address.
	  
	  @param ea: linear address (C++: ea_t)
	  @param gtn_flags: how exactly the name should be retrieved.
	                    combination of  bits for get_ea_name() function.
	                    There is a convenience  bits (C++: int)
	  @return: success
	  

ida_name.get_long_name():
	
	  get_long_name(ea, gtn_flags=0) -> qstring
	  

ida_name.get_name():
	
	  get_name(ea) -> qstring
	  

ida_name.get_name_base_ea():
	
	  get_name_base_ea(_from, to) -> ea_t
	
	
	  Get address of the name used in the expression for the address
	  
	  @param _from: address of the operand which references to the address
	                (C++: ea_t)
	  @param to: the referenced address (C++: ea_t)
	  @return: address of the name used to represent the operand
	  

ida_name.get_name_color():
	
	  get_name_color(_from, ea) -> color_t
	
	
	  Calculate flags for 'get_ea_name()' function.
	  
	  Get name color.
	  
	  @param _from: linear address where the name is used. if not
	                applicable, then should be  BADADDR . The kernel returns
	                a local name color if the reference is within a
	                function, i.e. 'from' and 'ea' belong to the same
	                function. (C++: ea_t)
	  @param ea: linear address (C++: ea_t)
	  

ida_name.get_name_ea():
	
	  get_name_ea(_from, name) -> ea_t
	
	
	  Get address of the name. Dummy names (like byte_xxxx where xxxx are
	  hex digits) are parsed by this function to obtain the address. The
	  database is not consulted for them. This function works only with
	  regular names.
	  
	  @param _from: linear address where the name is used. if not
	                applicable, then should be  BADADDR . (C++: ea_t)
	  @param name: any name in the program or NULL (C++: const char *)
	  @return: address of the name or  BADADDR
	  

ida_name.get_name_expr():
	
	  get_name_expr(_from, n, ea, off, flags=0x0001) -> ssize_t
	
	
	  Convert address to name expression (name with a displacement). This
	  function takes into account fixup information and returns a colored
	  name expression (in the form <name> +/- <offset>). It also knows about
	  structure members and arrays. If the specified address doesn't have a
	  name, a dummy name is generated.
	  
	  @param _from: linear address of instruction operand or data referring
	                to the name. This address will be used to get fixup
	                information, so it should point to exact position of the
	                operand in the instruction. (C++: ea_t)
	  @param n: number of referencing operand. for data items specify 0
	            (C++: int)
	  @param ea: address to convert to name expression (C++: ea_t)
	  @param off: the value of name expression. this parameter is used only
	              to check that the name expression will have the wanted
	              value. 'off' may be equal to BADADDR but this is
	              discouraged because it prohibits checks. (C++: uval_t)
	  @param flags: Name expression flags (C++: int)
	  @return: < 0 if address is not valid, no segment or other failure.
	           otherwise the length of the name expression in characters.
	  

ida_name.get_name_value():
	
	  get_name_value(_from, name) -> int
	
	
	  Get value of the name. This function knows about: regular names,
	  enums, special segments, etc.
	  
	  @param _from: linear address where the name is used if not applicable,
	                then should be BADADDR (C++: ea_t)
	  @param name: any name in the program or NULL (C++: const char *)
	  @return: Name value result codes
	  

ida_name.get_nice_colored_name():
	
	  get_nice_colored_name(ea, flags=0) -> ssize_t
	
	
	  Get a nice colored name at the specified address. Ex:segment:sub+offse
	  tsegment:sub:local_labelsegment:labelsegment:addresssegment:address+of
	  fset
	  
	  @param ea (C++: ea_t)
	  @param flags (C++: int)
	  @return: the length of the generated name in bytes.
	  

ida_name.get_nlist_ea():
	
	  get_nlist_ea(idx) -> ea_t
	
	
	  Get address from the list at 'idx'.
	  
	  
	  @param idx (C++: size_t)
	  

ida_name.get_nlist_idx():
	
	  get_nlist_idx(ea) -> size_t
	
	
	  Get index of the name in the listreturns the closest match. may return
	  idx >= size.
	  
	  @param ea (C++: ea_t)
	  

ida_name.get_nlist_name():
	
	  get_nlist_name(idx) -> char const *
	
	
	  Get name using idx.
	  
	  
	  @param idx (C++: size_t)
	  

ida_name.get_nlist_size():
	
	  get_nlist_size() -> size_t
	
	
	  Get number of names in the list.
	  

ida_name.get_short_name():
	
	  get_short_name(ea, gtn_flags=0) -> qstring
	  

ida_name.get_visible_name():
	
	  get_visible_name(ea, gtn_flags=0) -> qstring
	  

ida_name.hide_name():
	
	  hide_name(ea)
	
	
	  Remove name from the list of names
	  
	  @param ea: address of the name (C++: ea_t)
	  

ida_name.is_ident():
	
	  is_ident(name) -> bool
	
	
	  Is a valid name? (including ::MangleChars)
	  
	  
	  @param name (C++: const char *)
	  

ida_name.is_ident_cp():
	
	  is_ident_cp(cp) -> bool
	
	
	  Can a character appear in a name? (present in ::NameChars or
	  ::MangleChars)
	  
	  
	  @param cp (C++: wchar32_t)
	  

ida_name.is_in_nlist():
	
	  is_in_nlist(ea) -> bool
	
	
	  Is name included into names list?
	  
	  
	  @param ea (C++: ea_t)
	  

ida_name.is_name_defined_locally():
	
	  is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool
	
	
	  Is the name defined locally in the specified function?
	  
	  @param pfn: pointer to function (C++: func_t  *)
	  @param name: name to check (C++: const char *)
	  @param ignore_name_def: which names to ignore when checking (C++:
	                          ignore_name_def_t)
	  @param ea1: the starting address of the range inside the function
	              (optional) (C++: ea_t)
	  @param ea2: the ending address of the range inside the function
	              (optional) (C++: ea_t)
	  @return: true if the name has been defined
	  

ida_name.is_public_name():
	
	  is_public_name(ea) -> bool
	  

ida_name.is_strlit_cp():
	
	  is_strlit_cp(cp, specific_ranges=None) -> bool
	
	
	  Can a character appear in a string literal (present in ::StrlitChars)
	  If 'specific_ranges' are specified, those will be used instead of the
	  ones corresponding to the current culture (only if ::StrlitChars is
	  configured to use the current culture)
	  
	  @param cp (C++: wchar32_t)
	  @param specific_ranges (C++: const  rangeset_crefvec_t  *)
	  

ida_name.is_uname():
	
	  is_uname(name) -> bool
	
	
	  Is valid user-specified name? (valid name & !dummy prefix).
	  
	  @param name: name to test. may be NULL. (C++: const char *)
	  

ida_name.is_valid_cp():
	
	  is_valid_cp(cp, kind, data=None) -> bool
	
	
	  Is the given codepoint acceptable in the given context?
	  
	  
	  @param cp (C++: wchar32_t)
	  @param kind (C++: nametype_t)
	  @param data (C++: void *)
	  

ida_name.is_valid_typename():
	
	  is_valid_typename(name) -> bool
	
	
	  Is valid type name?
	  
	  @param name: name to test. may be NULL. (C++: const char *)
	  

ida_name.is_visible_cp():
	
	  is_visible_cp(cp) -> bool
	
	
	  Can a character be displayed in a name? (present in ::NameChars)
	  
	  
	  @param cp (C++: wchar32_t)
	  

ida_name.is_weak_name():
	
	  is_weak_name(ea) -> bool
	  

ida_name.make_name_auto():
	
	  make_name_auto(ea) -> bool
	  

ida_name.make_name_non_public():
	
	  make_name_non_public(ea)
	  

ida_name.make_name_non_weak():
	
	  make_name_non_weak(ea)
	  

ida_name.make_name_public():
	
	  make_name_public(ea)
	  

ida_name.make_name_user():
	
	  make_name_user(ea) -> bool
	  

ida_name.make_name_weak():
	
	  make_name_weak(ea)
	  

ida_name.rebuild_nlist():
	
	  rebuild_nlist()
	
	
	  Rebuild names list.
	  

ida_name.reorder_dummy_names():
	
	  reorder_dummy_names()
	
	
	  Renumber dummy names.
	  

ida_name.set_cp_validity():
	
	  set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)
	
	
	  Mark the given codepoint (or range) as acceptable or unacceptable in
	  the given context If 'endcp' is not BADCP, it is considered to be the
	  end of the range: [cp, endcp), and is not included in the range
	  
	  @param kind (C++: ucdr_kind_t)
	  @param cp (C++: wchar32_t)
	  @param endcp (C++: wchar32_t)
	  @param valid (C++: bool)
	  

ida_name.set_debug_name():
	
	  set_debug_name(ea, name) -> bool
	  

ida_name.set_dummy_name():
	
	  set_dummy_name(_from, ea) -> bool
	
	
	  Give an autogenerated (dummy) name. Autogenerated names have special
	  prefixes (loc_...).
	  
	  @param _from: linear address of the operand which references to the
	                address (C++: ea_t)
	  @param ea: linear address (C++: ea_t)
	  

ida_name.set_name():
	
	  set_name(ea, name, flags=0) -> bool
	
	
	  Set or delete name of an item at the specified address. An item can be
	  anything: instruction, function, data byte, word, string, structure,
	  etc... Include name into the list of names.
	  
	  @param ea: linear address. do nothing if ea is not valid (return 0).
	             tail bytes can't have names. (C++: ea_t)
	  @param name: new name.   NULL: do nothing (return 0). "" : delete
	               name. otherwise this is a new name. (C++: const char *)
	  @param flags: Set name flags . If a bit is not specified, then the
	                corresponding action is not performed and the name will
	                retain the same bits as before calling this function.
	                For new names, default is: non-public, non-weak, non-
	                auto. (C++: int)
	  

ida_name.show_name():
	
	  show_name(ea)
	
	
	  Insert name to the list of names.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_name.validate_name():
	
	  validate_name(name, type, flags=0) -> PyObject *
	
	
	  Validate a name. This function replaces all invalid characters in the
	  name with SUBSTCHAR. However, it will return false if name is valid
	  but not allowed to be an identifier (is a register name).
	  
	  @param name: ptr to name. the name will be modified (C++: qstring  *)
	  @param type: the type of name we want to validate (C++: nametype_t)
	  @param flags: see SN_* . Only SN_IDBENC is currently considered (C++:
	                int)
	  @return: success
	  


=== ida_name EPYDOC INJECTIONS ===
ida_name.FUNC_IMPORT_PREFIX
"""
Name prefix used by IDA for the imported functions.
"""

ida_name.GETN_APPZERO
"""
append a struct field name if the field offset is zero?

meaningful only if the name refers to a structure.
"""

ida_name.GETN_NODUMMY
"""
do not create a new dummy name but pretend it exists
"""

ida_name.GETN_NOFIXUP
"""
ignore the fixup information when producing the name
"""

ida_name.GNCN_NOCOLOR
"""
generate an uncolored name
"""

ida_name.GNCN_NODBGNM
"""
don't use debug names
"""

ida_name.GNCN_NOFUNC
"""
don't generate funcname+... expressions
"""

ida_name.GNCN_NOLABEL
"""
don't generate labels
"""

ida_name.GNCN_NOSEG
"""
ignore the segment prefix when producing the name
"""

ida_name.GNCN_PREFDBG
"""
if using debug names, prefer debug names over function names
"""

ida_name.GNCN_REQFUNC
"""
return 0 if the address does not belong to a function
"""

ida_name.GNCN_REQNAME
"""
return 0 if the address can only be represented as a hex number
"""

ida_name.GNCN_SEGNUM
"""
segment part is displayed as a hex number
"""

ida_name.GNCN_SEG_FUNC
"""
generate both segment and function names (default is to omit segment
name if a function name is present)
"""

ida_name.GN_COLORED
"""
return colored name
"""

ida_name.GN_DEMANGLED
"""
return demangled name
"""

ida_name.GN_ISRET
"""
for dummy names: use retloc
"""

ida_name.GN_LOCAL
"""
try to get local name first; if failed, get global
"""

ida_name.GN_LONG
"""
use long form of demangled name
"""

ida_name.GN_NOT_DUMMY
"""
do not return a dummy name
"""

ida_name.GN_NOT_ISRET
"""
for dummy names: do not use retloc
"""

ida_name.GN_SHORT
"""
use short form of demangled name
"""

ida_name.GN_STRICT
"""
fail if can not demangle
"""

ida_name.GN_VISIBLE
"""
replace forbidden characters by SUBSTCHAR
"""

ida_name.MAXNAMELEN
"""
Maximum length of a name in IDA (with the trailing zero)
"""

ida_name.NT_ABS
"""
name is absolute symbol ( 'SEG_ABSSYM' )
"""

ida_name.NT_BMASK
"""
name is a bit group mask name
"""

ida_name.NT_BYTE
"""
name is byte name (regular name)
"""

ida_name.NT_ENUM
"""
name is symbolic constant
"""

ida_name.NT_LOCAL
"""
name is local label
"""

ida_name.NT_NONE
"""
name doesn't exist or has no value
"""

ida_name.NT_REGVAR
"""
name is a renamed register (*value is idx into pfn->regvars)
"""

ida_name.NT_SEG
"""
name is segment or segment register name
"""

ida_name.NT_STKVAR
"""
name is stack variable name
"""

ida_name.NT_STROFF
"""
name is structure member
"""

ida_name.SN_AUTO
"""
if set, make name autogenerated
"""

ida_name.SN_FORCE
"""
if the specified name is already present in the database, try
variations with a numerical suffix like "_123"
"""

ida_name.SN_IDBENC
"""
non-ASCII bytes will be decoded accordingly

the name is given in the IDB encoding;
"""

ida_name.SN_LOCAL
"""
create local name. a function should exist. local names can't be
public or weak. also they are not included into the list of names they
can't have dummy prefixes.
"""

ida_name.SN_NOCHECK
"""
Don't fail if the name contains invalid characters. If this bit is
clear, all invalid chars (those !is_ident_cp()) will be replaced by
SUBSTCHAR List of valid characters is defined in ida.cfg
"""

ida_name.SN_NOLIST
"""
if set, exclude name from the list. if not set, then include the name
into the list (however, if other bits are set, the name might be
immediately excluded from the list).
"""

ida_name.SN_NON_AUTO
"""
if set, make name non-autogenerated
"""

ida_name.SN_NON_PUBLIC
"""
if set, make name non-public
"""

ida_name.SN_NON_WEAK
"""
if set, make name non-weak
"""

ida_name.SN_NOWARN
"""
don't display a warning if failed
"""

ida_name.SN_PUBLIC
"""
if set, make name public
"""

ida_name.SN_WEAK
"""
if set, make name weak
"""
=== ida_name EPYDOC INJECTIONS END ===
ida_netnode.exist():
	
	  exist(n) -> bool
	  

class ida_netnode.netnode():
	
	    Proxy of C++ netnode class
	    

ida_netnode.netnode.altdel():
	
	        altdel(self, alt, tag=atag) -> bool
	        altdel(self) -> bool
	        

ida_netnode.netnode.altdel_all():
	
	        altdel_all(self, tag) -> bool
	        

ida_netnode.netnode.altdel_ea():
	
	        altdel_ea(self, ea, tag=atag) -> bool
	        

ida_netnode.netnode.altdel_idx8():
	
	        altdel_idx8(self, alt, tag) -> bool
	        

ida_netnode.netnode.altfirst():
	
	        altfirst(self, tag=atag) -> nodeidx_t
	        

ida_netnode.netnode.altfirst_idx8():
	
	        altfirst_idx8(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.altlast():
	
	        altlast(self, tag=atag) -> nodeidx_t
	        

ida_netnode.netnode.altlast_idx8():
	
	        altlast_idx8(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.altnext():
	
	        altnext(self, cur, tag=atag) -> nodeidx_t
	        

ida_netnode.netnode.altnext_idx8():
	
	        altnext_idx8(self, cur, tag) -> nodeidx_t
	        

ida_netnode.netnode.altprev():
	
	        altprev(self, cur, tag=atag) -> nodeidx_t
	        

ida_netnode.netnode.altprev_idx8():
	
	        altprev_idx8(self, cur, tag) -> nodeidx_t
	        

ida_netnode.netnode.altset():
	
	        altset(self, alt, value, tag=atag) -> bool
	        

ida_netnode.netnode.altset_ea():
	
	        altset_ea(self, ea, value, tag=atag) -> bool
	        

ida_netnode.netnode.altset_idx8():
	
	        altset_idx8(self, alt, val, tag) -> bool
	        

ida_netnode.netnode.altshift():
	
	        altshift(self, _from, to, size, tag=atag) -> size_t
	        

ida_netnode.netnode.altval():
	
	        altval(self, alt, tag=atag) -> nodeidx_t
	        

ida_netnode.netnode.altval_ea():
	
	        altval_ea(self, ea, tag=atag) -> nodeidx_t
	        

ida_netnode.netnode.altval_idx8():
	
	        altval_idx8(self, alt, tag) -> nodeidx_t
	        

ida_netnode.netnode.blobsize():
	
	        blobsize(self, _start, tag) -> size_t
	        

ida_netnode.netnode.blobsize_ea():
	
	        blobsize_ea(self, ea, tag) -> size_t
	        

ida_netnode.netnode.chardel():
	
	        chardel(self, alt, tag) -> bool
	        

ida_netnode.netnode.chardel_ea():
	
	        chardel_ea(self, ea, tag) -> bool
	        

ida_netnode.netnode.chardel_idx8():
	
	        chardel_idx8(self, alt, tag) -> bool
	        

ida_netnode.netnode.charfirst():
	
	        charfirst(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.charfirst_idx8():
	
	        charfirst_idx8(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.charlast():
	
	        charlast(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.charlast_idx8():
	
	        charlast_idx8(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.charnext():
	
	        charnext(self, cur, tag) -> nodeidx_t
	        

ida_netnode.netnode.charnext_idx8():
	
	        charnext_idx8(self, cur, tag) -> nodeidx_t
	        

ida_netnode.netnode.charprev():
	
	        charprev(self, cur, tag) -> nodeidx_t
	        

ida_netnode.netnode.charprev_idx8():
	
	        charprev_idx8(self, cur, tag) -> nodeidx_t
	        

ida_netnode.netnode.charset():
	
	        charset(self, alt, val, tag) -> bool
	        

ida_netnode.netnode.charset_ea():
	
	        charset_ea(self, ea, val, tag) -> bool
	        

ida_netnode.netnode.charset_idx8():
	
	        charset_idx8(self, alt, val, tag) -> bool
	        

ida_netnode.netnode.charshift():
	
	        charshift(self, _from, to, size, tag) -> size_t
	        

ida_netnode.netnode.charval():
	
	        charval(self, alt, tag) -> uchar
	        

ida_netnode.netnode.charval_ea():
	
	        charval_ea(self, ea, tag) -> uchar
	        

ida_netnode.netnode.charval_idx8():
	
	        charval_idx8(self, alt, tag) -> uchar
	        

ida_netnode.netnode.copyto():
	
	        copyto(self, target, count=1) -> size_t
	        

ida_netnode.netnode.create():
	
	        create(self, _name, namlen=0) -> bool
	        create(self) -> bool
	        

ida_netnode.netnode.delblob():
	
	        delblob(self, _start, tag) -> int
	        

ida_netnode.netnode.delblob_ea():
	
	        delblob_ea(self, ea, tag) -> int
	        

ida_netnode.netnode.delvalue():
	
	        delvalue(self) -> bool
	        

ida_netnode.netnode.eadel():
	
	        eadel(self, ea, tag) -> bool
	        

ida_netnode.netnode.eadel_idx8():
	
	        eadel_idx8(self, idx, tag) -> bool
	        

ida_netnode.netnode.eaget():
	
	        eaget(self, ea, tag) -> ea_t
	        

ida_netnode.netnode.eaget_idx():
	
	        eaget_idx(self, idx, tag) -> ea_t
	        

ida_netnode.netnode.eaget_idx8():
	
	        eaget_idx8(self, idx, tag) -> ea_t
	        

ida_netnode.netnode.easet():
	
	        easet(self, ea, addr, tag) -> bool
	        

ida_netnode.netnode.easet_idx():
	
	        easet_idx(self, idx, addr, tag) -> bool
	        

ida_netnode.netnode.easet_idx8():
	
	        easet_idx8(self, idx, addr, tag) -> bool
	        

ida_netnode.netnode.end():
	
	        end(self) -> bool
	        

ida_netnode.netnode.get_name():
	
	        get_name(self) -> ssize_t
	        

ida_netnode.netnode.getblob():
	
	        getblob(self, start, tag) -> PyObject *
	        

ida_netnode.netnode.getblob_ea():
	
	        getblob_ea(self, ea, tag) -> PyObject *
	        

ida_netnode.netnode.getclob():
	
	        getclob(self, start, tag) -> PyObject *
	        

ida_netnode.netnode.hashdel():
	
	        hashdel(self, idx, tag=htag) -> bool
	        

ida_netnode.netnode.hashdel_all():
	
	        hashdel_all(self, tag=htag) -> bool
	        

ida_netnode.netnode.hashfirst():
	
	        hashfirst(self, tag=htag) -> ssize_t
	        

ida_netnode.netnode.hashlast():
	
	        hashlast(self, tag=htag) -> ssize_t
	        

ida_netnode.netnode.hashnext():
	
	        hashnext(self, idx, tag=htag) -> ssize_t
	        

ida_netnode.netnode.hashprev():
	
	        hashprev(self, idx, tag=htag) -> ssize_t
	        

ida_netnode.netnode.hashset():
	
	        hashset(self, idx, value, tag=htag) -> bool
	        

ida_netnode.netnode.hashset_buf():
	
	        hashset_buf(self, idx, py_str, tag=htag) -> bool
	        

ida_netnode.netnode.hashset_idx():
	
	        hashset_idx(self, idx, value, tag=htag) -> bool
	        

ida_netnode.netnode.hashstr():
	
	        hashstr(self, idx, tag=htag) -> ssize_t
	        

ida_netnode.netnode.hashstr_buf():
	
	        hashstr_buf(self, idx, tag=htag) -> PyObject *
	        

ida_netnode.netnode.hashval():
	
	        hashval(self, idx, tag=htag) -> ssize_t
	        

ida_netnode.netnode.hashval_long():
	
	        hashval_long(self, idx, tag=htag) -> nodeidx_t
	        

ida_netnode.netnode.index():
	
	        index(self) -> nodeidx_t
	        

ida_netnode.netnode.kill():
	
	        kill(self)
	        

ida_netnode.netnode.long_value():
	
	        long_value(self) -> nodeidx_t
	        

ida_netnode.netnode.lower_bound():
	
	        lower_bound(self, cur, tag=stag) -> nodeidx_t
	        

ida_netnode.netnode.lower_bound_ea():
	
	        lower_bound_ea(self, ea, tag=stag) -> nodeidx_t
	        

ida_netnode.netnode.lower_bound_idx8():
	
	        lower_bound_idx8(self, alt, tag) -> nodeidx_t
	        

ida_netnode.netnode.moveto():
	
	        moveto(self, target, count=1) -> size_t
	        

ida_netnode.netnode.next():
	
	        next(self) -> bool
	        

ida_netnode.netnode.prev():
	
	        prev(self) -> bool
	        

ida_netnode.netnode.rename():
	
	        rename(self, newname, namlen=0) -> bool
	        

ida_netnode.netnode.set():
	
	        set(self, value) -> bool
	        

ida_netnode.netnode.set_long():
	
	        set_long(self, x) -> bool
	        

ida_netnode.netnode.setblob():
	
	        setblob(self, buf, _start, tag) -> bool
	        

ida_netnode.netnode.setblob_ea():
	
	        setblob_ea(self, buf, ea, tag) -> bool
	        

ida_netnode.netnode.start():
	
	        start(self) -> bool
	        

ida_netnode.netnode.supdel():
	
	        supdel(self, alt, tag=stag) -> bool
	        supdel(self) -> bool
	        

ida_netnode.netnode.supdel_all():
	
	        supdel_all(self, tag) -> bool
	        

ida_netnode.netnode.supdel_ea():
	
	        supdel_ea(self, ea, tag=stag) -> bool
	        

ida_netnode.netnode.supdel_idx8():
	
	        supdel_idx8(self, alt, tag) -> bool
	        

ida_netnode.netnode.supdel_range():
	
	        supdel_range(self, idx1, idx2, tag) -> int
	        

ida_netnode.netnode.supdel_range_idx8():
	
	        supdel_range_idx8(self, idx1, idx2, tag) -> int
	        

ida_netnode.netnode.supfirst():
	
	        supfirst(self, tag=stag) -> nodeidx_t
	        

ida_netnode.netnode.supfirst_idx8():
	
	        supfirst_idx8(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.suplast():
	
	        suplast(self, tag=stag) -> nodeidx_t
	        

ida_netnode.netnode.suplast_idx8():
	
	        suplast_idx8(self, tag) -> nodeidx_t
	        

ida_netnode.netnode.supnext():
	
	        supnext(self, cur, tag=stag) -> nodeidx_t
	        

ida_netnode.netnode.supnext_idx8():
	
	        supnext_idx8(self, alt, tag) -> nodeidx_t
	        

ida_netnode.netnode.supprev():
	
	        supprev(self, cur, tag=stag) -> nodeidx_t
	        

ida_netnode.netnode.supprev_idx8():
	
	        supprev_idx8(self, alt, tag) -> nodeidx_t
	        

ida_netnode.netnode.supset():
	
	        supset(self, alt, value, tag=stag) -> bool
	        

ida_netnode.netnode.supset_ea():
	
	        supset_ea(self, ea, value, tag=stag) -> bool
	        

ida_netnode.netnode.supset_idx8():
	
	        supset_idx8(self, alt, value, tag) -> bool
	        

ida_netnode.netnode.supshift():
	
	        supshift(self, _from, to, size, tag=stag) -> size_t
	        

ida_netnode.netnode.supstr():
	
	        supstr(self, alt, tag=stag) -> ssize_t
	        

ida_netnode.netnode.supstr_ea():
	
	        supstr_ea(self, ea, tag=stag) -> ssize_t
	        

ida_netnode.netnode.supstr_idx8():
	
	        supstr_idx8(self, alt, tag) -> ssize_t
	        

ida_netnode.netnode.supval():
	
	        supval(self, alt, tag=stag) -> ssize_t
	        

ida_netnode.netnode.supval_ea():
	
	        supval_ea(self, ea, tag=stag) -> ssize_t
	        

ida_netnode.netnode.supval_idx8():
	
	        supval_idx8(self, alt, tag) -> ssize_t
	        

ida_netnode.netnode.valobj():
	
	        valobj(self) -> ssize_t
	        

ida_netnode.netnode.valstr():
	
	        valstr(self) -> ssize_t
	        

ida_netnode.netnode.value_exists():
	
	        value_exists(self) -> bool
	        


=== ida_netnode EPYDOC INJECTIONS ===
ida_netnode.BADNODE
"""
A number to represent a bad netnode reference.
"""
=== ida_netnode EPYDOC INJECTIONS END ===
ida_offset.add_refinfo_dref():
	
	  add_refinfo_dref(insn, _from, ri, opval, type, opoff) -> ea_t
	
	
	  Add xrefs for a reference from the given instruction ({ea}). This
	  function creates a cross references to the target and the base.
	  'insn_t::add_off_drefs()' calls this function to create xrefs for
	  'offset' operand.
	  
	  @param insn: the referencing instruction (C++: const  insn_t  &)
	  @param _from: the referencing instruction/data address (C++: ea_t)
	  @param ri: reference info block from the database (C++: const
	             refinfo_t  &)
	  @param opval: operand value (usually  op_t::value  or  op_t::addr )
	                (C++: adiff_t)
	  @param type: type of xref (C++: dref_t)
	  @param opoff: offset of the operand from the start of instruction
	                (C++: int)
	  @return: the target address of the reference
	  

ida_offset.calc_basevalue():
	
	  calc_basevalue(target, base) -> ea_t
	
	
	  Calculate the value of the reference base.
	  
	  
	  @param target (C++: ea_t)
	  @param base (C++: ea_t)
	  

ida_offset.calc_offset_base():
	
	  calc_offset_base(ea, n) -> ea_t
	
	
	  Try to calculate the offset base This function takes into account the
	  fixup information, current ds and cs values.
	  
	  @param ea: the referencing instruction/data address (C++: ea_t)
	  @param n: operand number   0: first operand 1: other operand (C++:
	            int)
	  @return: output base address or  BADADDR
	  

ida_offset.calc_probable_base_by_value():
	
	  calc_probable_base_by_value(ea, off) -> ea_t
	
	
	  Try to calculate the offset base. 2 bases are checked: current ds and
	  cs. If fails, return 'BADADDR'
	  
	  @param ea (C++: ea_t)
	  @param off (C++: uval_t)
	  

ida_offset.calc_reference_data():
	
	  calc_reference_data(target, base, _from, ri, opval) -> bool
	
	
	  Calculate the target and base addresses of an offset expression. The
	  calculated target and base addresses are returned in the locations
	  pointed by 'base' and 'target'. In case 'ri.base' is 'BADADDR' , the
	  function calculates the offset base address from the referencing
	  instruction/data address. The target address is copied from ri.target.
	  If ri.target is 'BADADDR' then the target is calculated using the base
	  address and 'opval'. This function also checks if 'opval' matches the
	  full value of the reference and takes in account the memory-mapping.
	  
	  @param target: output target address (C++: ea_t *)
	  @param base: output base address (C++: ea_t *)
	  @param _from: the referencing instruction/data address (C++: ea_t)
	  @param ri: reference info block from the database (C++: const
	             refinfo_t  &)
	  @param opval: operand value (usually  op_t::value  or  op_t::addr )
	                (C++: adiff_t)
	  @return: success
	  

ida_offset.calc_target():
	
	    calc_target(_from, opval, ri) -> ea_t
	    calc_target(_from, ea, n, opval) -> ea_t
	
	
	  Calculates the target, using the provided 'refinfo_t' .
	  
	  
	  @param _from (C++: ea_t)
	  @param opval (C++: adiff_t)
	  @param ri (C++: const  refinfo_t  &)
	    

ida_offset.can_be_off32():
	
	  can_be_off32(ea) -> ea_t
	
	
	  Does the specified address contain a valid OFF32 value?. For symbols
	  in special segments the displacement is not taken into account. If
	  yes, then the target address of OFF32 will be returned. If not, then
	  'BADADDR' is returned.
	  
	  @param ea (C++: ea_t)
	  

ida_offset.get_default_reftype():
	
	  get_default_reftype(ea) -> reftype_t
	
	
	  Get default reference type depending on the segment.
	  
	  @param ea (C++: ea_t)
	  @return: one of  REF_OFF8 , REF_OFF16 , REF_OFF32
	  

ida_offset.get_offbase():
	
	  get_offbase(ea, n) -> ea_t
	
	
	  Get offset base value
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (C++: int)
	  @return: offset base or  BADADDR
	  

ida_offset.get_offset_expr():
	
	  get_offset_expr(ea, n, ri, _from, offset, getn_flags=0) -> int
	
	
	  See 'get_offset_expression()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  @param ri (C++: const  refinfo_t  &)
	  @param _from (C++: ea_t)
	  @param offset (C++: adiff_t)
	  @param getn_flags (C++: int)
	  

ida_offset.get_offset_expression():
	
	  get_offset_expression(ea, n, _from, offset, getn_flags=0) -> int
	
	
	  Get offset expression (in the form "offset name+displ"). This function
	  uses offset translation function ({translate}) if your IDP module has
	  such a function. Translation function is used to map linear addresses
	  in the program (only for offsets).Example: suppose we have instruction
	  at linear address 0x00011000: {mov ax, [bx+7422h]} and at ds:7422h:
	  {array dw ...} We want to represent the second operand with an offset
	  expression, so then we call: { get_offset_expresion(0x001100, 1,
	  0x001102, 0x7422, buf); | | | | | | | | | +output buffer | | | +value
	  of offset expression | | +address offset value in the instruction |
	  +the second operand +address of instruction } and the function will
	  return a colored string: {offset array}
	  
	  @param ea: start of instruction or data with the offset expression
	             (C++: ea_t)
	  @param n: number of operand (may be ORed with  OPND_OUTER )   0: first
	            operand 1: second operand (C++: int)
	  @param _from: linear address of instruction operand or data referring
	                to the name. This address will be used to get fixup
	                information, so it should point to exact position of
	                operand in the instruction. (C++: ea_t)
	  @param offset: value of operand or its part. The function will return
	                 text representation of this value as offset expression.
	                 (C++: adiff_t)
	  @param getn_flags: combination of:   GETN_APPZERO : meaningful only if
	                     the name refers to a structure. appends the struct
	                     field name if the field offset is zero GETN_NODUMMY
	                     : do not generate dummy names for the expression
	                     but pretend they already exist (useful to verify
	                     that the offset expression can be represented)
	                     (C++: int)
	  

ida_offset.op_offset():
	
	  op_offset(ea, n, type, target=BADADDR, base=0, tdelta=0) -> int
	
	
	  See 'op_offset_ex()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  @param type (C++: reftype_t)
	  @param target (C++: ea_t)
	  @param base (C++: ea_t)
	  @param tdelta (C++: adiff_t)
	  

ida_offset.op_offset_ex():
	
	  op_offset_ex(ea, n, ri) -> int
	
	
	  Convert operand to a reference. To delete an offset, use
	  'clr_op_type()' function.
	  
	  @param ea: linear address. if 'ea' has unexplored bytes, try to
	             convert them to   no segment: fail 16bit segment: to 16bit
	             word data 32bit segment: to dword (C++: ea_t)
	  @param n: number of operand (may be ORed with  OPND_OUTER )   0: first
	            1: second 2: third OPND_MASK : all operands (C++: int)
	  @param ri: reference information (C++: const  refinfo_t  *)
	  @return: success
	  

ida_offset.op_plain_offset():
	
	  op_plain_offset(ea, n, base) -> bool
	
	
	  Convert operand to a reference with the default reference type.
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  @param base (C++: ea_t)
	  

class ida_pro.boolvec_t():
	
	    Proxy of C++ qvector<(bool)> class
	    

ida_pro.boolvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.boolvec_t.at():
	
	        __getitem__(self, i) -> bool const &
	        

ida_pro.boolvec_t.begin():
	
	        begin(self) -> qvector< bool >::iterator
	        begin(self) -> qvector< bool >::const_iterator
	        

ida_pro.boolvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.boolvec_t.clear():
	
	        clear(self)
	        

ida_pro.boolvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.boolvec_t.end():
	
	        end(self) -> qvector< bool >::iterator
	        end(self) -> qvector< bool >::const_iterator
	        

ida_pro.boolvec_t.erase():
	
	        erase(self, it) -> qvector< bool >::iterator
	        erase(self, first, last) -> qvector< bool >::iterator
	        

ida_pro.boolvec_t.extract():
	
	        extract(self) -> bool *
	        

ida_pro.boolvec_t.find():
	
	        find(self, x) -> qvector< bool >::iterator
	        find(self, x) -> qvector< bool >::const_iterator
	        

ida_pro.boolvec_t.grow():
	
	        grow(self, x=bool())
	        

ida_pro.boolvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.boolvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.boolvec_t.insert():
	
	        insert(self, it, x) -> qvector< bool >::iterator
	        

ida_pro.boolvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.boolvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> bool &
	        

ida_pro.boolvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.boolvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.boolvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.boolvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.boolvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.boolvec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.channel_redir_t():
	
	    Proxy of C++ channel_redir_t class
	    

ida_pro.channel_redir_t.fd:
	channel_redir_t_fd_get(self) -> int

ida_pro.channel_redir_t.file:
	channel_redir_t_file_get(self) -> qstring *

ida_pro.channel_redir_t.flags:
	channel_redir_t_flags_get(self) -> int

ida_pro.channel_redir_t.is_append():
	
	        is_append(self) -> bool
	        

ida_pro.channel_redir_t.is_input():
	
	        is_input(self) -> bool
	        

ida_pro.channel_redir_t.is_output():
	
	        is_output(self) -> bool
	        

ida_pro.channel_redir_t.is_quoted():
	
	        is_quoted(self) -> bool
	        

ida_pro.channel_redir_t.length:
	channel_redir_t_length_get(self) -> int

ida_pro.channel_redir_t.start:
	channel_redir_t_start_get(self) -> int

ida_pro.check_process_exit():
	
	  check_process_exit(handle, exit_code, msecs=-1) -> int
	
	
	  Check whether process has terminated or not.
	  
	  @param handle: process handle to wait for (C++: void *)
	  @param exit_code: pointer to the buffer for the exit code (C++: int *)
	  

ida_pro.check_type_trait():
	
	    check_type_trait(arg1) -> bool
	    check_type_trait(arg1) -> bool
	    

ida_pro.clear_bits():
	
	  clear_bits(bitmap, low, high)
	
	
	  Clear bits between [low, high) in 'bitmap'.
	  
	  
	  @param bitmap (C++: uchar  *)
	  @param low (C++: size_t)
	  @param high (C++: size_t)
	  

class ida_pro.ea_array():
	
	    Proxy of C++ ea_array class
	    

ida_pro.ea_array.cast():
	
	        cast(self) -> ea_t *
	        

ida_pro.ea_array.frompointer():
	
	        frompointer(t) -> ea_array
	        

ida_pro.ea_array_frompointer():
	
	  ea_array_frompointer(t) -> ea_array
	  

class ida_pro.ea_pointer():
	
	    Proxy of C++ ea_pointer class
	    

ida_pro.ea_pointer.assign():
	
	        assign(self, value)
	        

ida_pro.ea_pointer.cast():
	
	        cast(self) -> ea_t *
	        

ida_pro.ea_pointer.frompointer():
	
	        frompointer(t) -> ea_pointer
	        

ida_pro.ea_pointer.value():
	
	        value(self) -> ea_t
	        

ida_pro.ea_pointer_frompointer():
	
	  ea_pointer_frompointer(t) -> ea_pointer
	  

ida_pro.extend_sign():
	
	  extend_sign(v, nbytes, sign_extend) -> uint64
	
	
	  Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v'
	  is considered to be of size 'nbytes'.
	  
	  @param v (C++: uint64)
	  @param nbytes (C++: int)
	  @param sign_extend (C++: bool)
	  

class ida_pro.instant_dbgopts_t():
	
	    Proxy of C++ instant_dbgopts_t class
	    

ida_pro.instant_dbgopts_t.attach:
	instant_dbgopts_t_attach_get(self) -> bool

ida_pro.instant_dbgopts_t.debmod:
	instant_dbgopts_t_debmod_get(self) -> qstring *

ida_pro.instant_dbgopts_t.env:
	instant_dbgopts_t_env_get(self) -> qstring *

ida_pro.instant_dbgopts_t.event_id:
	instant_dbgopts_t_event_id_get(self) -> int

ida_pro.instant_dbgopts_t.host:
	instant_dbgopts_t_host_get(self) -> qstring *

ida_pro.instant_dbgopts_t.pid:
	instant_dbgopts_t_pid_get(self) -> int

ida_pro.instant_dbgopts_t.port:
	instant_dbgopts_t_port_get(self) -> int

class ida_pro.int64vec_t():
	
	    Proxy of C++ qvector<(long long)> class
	    

ida_pro.int64vec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.int64vec_t.at():
	
	        __getitem__(self, i) -> long long const &
	        

ida_pro.int64vec_t.begin():
	
	        begin(self) -> qvector< long long >::iterator
	        begin(self) -> qvector< long long >::const_iterator
	        

ida_pro.int64vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.int64vec_t.clear():
	
	        clear(self)
	        

ida_pro.int64vec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.int64vec_t.end():
	
	        end(self) -> qvector< long long >::iterator
	        end(self) -> qvector< long long >::const_iterator
	        

ida_pro.int64vec_t.erase():
	
	        erase(self, it) -> qvector< long long >::iterator
	        erase(self, first, last) -> qvector< long long >::iterator
	        

ida_pro.int64vec_t.extract():
	
	        extract(self) -> long long *
	        

ida_pro.int64vec_t.find():
	
	        find(self, x) -> qvector< long long >::iterator
	        find(self, x) -> qvector< long long >::const_iterator
	        

ida_pro.int64vec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.int64vec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.int64vec_t.insert():
	
	        insert(self, it, x) -> qvector< long long >::iterator
	        

ida_pro.int64vec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.int64vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> long long &
	        

ida_pro.int64vec_t.qclear():
	
	        qclear(self)
	        

ida_pro.int64vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.int64vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.int64vec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.int64vec_t.swap():
	
	        swap(self, r)
	        

ida_pro.int64vec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.int_pointer():
	
	    Proxy of C++ int_pointer class
	    

ida_pro.int_pointer.assign():
	
	        assign(self, value)
	        

ida_pro.int_pointer.cast():
	
	        cast(self) -> int *
	        

ida_pro.int_pointer.frompointer():
	
	        frompointer(t) -> int_pointer
	        

ida_pro.int_pointer.value():
	
	        value(self) -> int
	        

ida_pro.int_pointer_frompointer():
	
	  int_pointer_frompointer(t) -> int_pointer
	  

class ida_pro.intvec_t():
	
	    Proxy of C++ qvector<(int)> class
	    

ida_pro.intvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.intvec_t.at():
	
	        __getitem__(self, i) -> int const &
	        

ida_pro.intvec_t.begin():
	
	        begin(self) -> qvector< int >::iterator
	        begin(self) -> qvector< int >::const_iterator
	        

ida_pro.intvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.intvec_t.clear():
	
	        clear(self)
	        

ida_pro.intvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.intvec_t.end():
	
	        end(self) -> qvector< int >::iterator
	        end(self) -> qvector< int >::const_iterator
	        

ida_pro.intvec_t.erase():
	
	        erase(self, it) -> qvector< int >::iterator
	        erase(self, first, last) -> qvector< int >::iterator
	        

ida_pro.intvec_t.extract():
	
	        extract(self) -> int *
	        

ida_pro.intvec_t.find():
	
	        find(self, x) -> qvector< int >::iterator
	        find(self, x) -> qvector< int >::const_iterator
	        

ida_pro.intvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.intvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.intvec_t.insert():
	
	        insert(self, it, x) -> qvector< int >::iterator
	        

ida_pro.intvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.intvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> int &
	        

ida_pro.intvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.intvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.intvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.intvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.intvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.intvec_t.truncate():
	
	        truncate(self)
	        

ida_pro.is_control_tty():
	
	  is_control_tty(fd) -> enum tty_control_t
	
	
	  Check if the current process is the owner of the TTY specified by 'fd'
	  (typically an opened descriptor to /dev/tty).
	  
	  @param fd (C++: int)
	  

ida_pro.is_main_thread():
	
	  is_main_thread() -> bool
	
	
	  Are we running in the main thread?
	  

ida_pro.log2ceil():
	
	  log2ceil(d64) -> int
	
	
	  calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 ==
	  0
	  
	  @param d64 (C++: uint64)
	  

ida_pro.log2floor():
	
	  log2floor(d64) -> int
	  

class ida_pro.longlongvec_t():
	
	    Proxy of C++ qvector<(long long)> class
	    

ida_pro.longlongvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.longlongvec_t.at():
	
	        __getitem__(self, i) -> long long const &
	        

ida_pro.longlongvec_t.begin():
	
	        begin(self) -> qvector< long long >::iterator
	        begin(self) -> qvector< long long >::const_iterator
	        

ida_pro.longlongvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.longlongvec_t.clear():
	
	        clear(self)
	        

ida_pro.longlongvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.longlongvec_t.end():
	
	        end(self) -> qvector< long long >::iterator
	        end(self) -> qvector< long long >::const_iterator
	        

ida_pro.longlongvec_t.erase():
	
	        erase(self, it) -> qvector< long long >::iterator
	        erase(self, first, last) -> qvector< long long >::iterator
	        

ida_pro.longlongvec_t.extract():
	
	        extract(self) -> long long *
	        

ida_pro.longlongvec_t.find():
	
	        find(self, x) -> qvector< long long >::iterator
	        find(self, x) -> qvector< long long >::const_iterator
	        

ida_pro.longlongvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.longlongvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.longlongvec_t.insert():
	
	        insert(self, it, x) -> qvector< long long >::iterator
	        

ida_pro.longlongvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.longlongvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> long long &
	        

ida_pro.longlongvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.longlongvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.longlongvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.longlongvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.longlongvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.longlongvec_t.truncate():
	
	        truncate(self)
	        

ida_pro.parse_dbgopts():
	
	  parse_dbgopts(ido, r_switch) -> bool
	
	
	  Parse the -r command line switch (for instant debugging). r_switch
	  points to the value of the -r switch. Example: win32+
	  
	  @param ido (C++: struct  instant_dbgopts_t  *)
	  @param r_switch (C++: const char *)
	  @return: true-ok, false-parse error
	  

ida_pro.qatoll():
	
	  qatoll(nptr) -> int64
	  

ida_pro.qcontrol_tty():
	
	  qcontrol_tty()
	
	
	  Make the current terminal the controlling terminal of the calling
	  process.The current terminal is supposed to be /dev/tty
	  

ida_pro.qdetach_tty():
	
	  qdetach_tty()
	
	
	  If the current terminal is the controlling terminal of the calling
	  process, give up this controlling terminal.The current terminal is
	  supposed to be /dev/tty
	  

ida_pro.qexit():
	
	  qexit(code)
	
	
	  Call qatexit functions, shut down UI and kernel, and exit.
	  
	  @param code: exit code (C++: int)
	  

class ida_pro.qmutex_locker_t():
	
	    Proxy of C++ qmutex_locker_t class
	    

class ida_pro.qrefcnt_obj_t():
	
	    Proxy of C++ qrefcnt_obj_t class
	    

ida_pro.qrefcnt_obj_t.refcnt:
	qrefcnt_obj_t_refcnt_get(self) -> int

ida_pro.qrefcnt_obj_t.release():
	
	        release(self)
	        

ida_pro.qstrvec_t_add():
	
	  qstrvec_t_add(self, s) -> bool
	  

ida_pro.qstrvec_t_addressof():
	
	  qstrvec_t_addressof(self, idx) -> PyObject *
	  

ida_pro.qstrvec_t_assign():
	
	  qstrvec_t_assign(self, other) -> bool
	  

ida_pro.qstrvec_t_clear():
	
	  qstrvec_t_clear(self, qclear) -> bool
	  

ida_pro.qstrvec_t_create():
	
	  qstrvec_t_create() -> PyObject *
	  

ida_pro.qstrvec_t_destroy():
	
	  qstrvec_t_destroy(py_obj) -> bool
	  

ida_pro.qstrvec_t_from_list():
	
	  qstrvec_t_from_list(self, py_list) -> bool
	  

ida_pro.qstrvec_t_get():
	
	  qstrvec_t_get(self, idx) -> PyObject *
	  

ida_pro.qstrvec_t_get_clink():
	
	  qstrvec_t_get_clink(self) -> qstrvec_t *
	  

ida_pro.qstrvec_t_get_clink_ptr():
	
	  qstrvec_t_get_clink_ptr(self) -> PyObject *
	  

ida_pro.qstrvec_t_insert():
	
	  qstrvec_t_insert(self, idx, s) -> bool
	  

ida_pro.qstrvec_t_remove():
	
	  qstrvec_t_remove(self, idx) -> bool
	  

ida_pro.qstrvec_t_set():
	
	  qstrvec_t_set(self, idx, s) -> bool
	  

ida_pro.qstrvec_t_size():
	
	  qstrvec_t_size(self) -> size_t
	  

ida_pro.quote_cmdline_arg():
	
	  quote_cmdline_arg(arg) -> bool
	
	
	  Quote a command line argument if it contains escape characters. For
	  example, *.c will be converted into "*.c" because * may be
	  inadvertently expanded by the shell
	  
	  @param arg (C++: qstring  *)
	  @return: true: modified 'arg'
	  

ida_pro.qvector_reserve():
	
	  qvector_reserve(vec, old, cnt, elsize) -> void *
	
	
	  Change capacity of given qvector.
	  
	  @param vec: a pointer to a qvector (C++: void *)
	  @param old: a pointer to the qvector's array (C++: void *)
	  @param cnt: number of elements to reserve (C++: size_t)
	  @param elsize: size of each element (C++: size_t)
	  @return: a pointer to the newly allocated array
	  

ida_pro.readbytes():
	
	  readbytes(h, res, size, mf) -> int
	
	
	  Read at most 4 bytes from file.
	  
	  @param h: file handle (C++: int)
	  @param res: value read from file (C++: uint32  *)
	  @param size: size of value in bytes (1,2,4) (C++: int)
	  @param mf: is MSB first? (C++: bool)
	  @return: 0 on success, nonzero otherwise
	  

ida_pro.reloc_value():
	
	  reloc_value(value, size, delta, mf)
	  

ida_pro.relocate_relobj():
	
	  relocate_relobj(_relobj, ea, mf) -> bool
	  

class ida_pro.sel_array():
	
	    Proxy of C++ sel_array class
	    

ida_pro.sel_array.cast():
	
	        cast(self) -> sel_t *
	        

ida_pro.sel_array.frompointer():
	
	        frompointer(t) -> sel_array
	        

ida_pro.sel_array_frompointer():
	
	  sel_array_frompointer(t) -> sel_array
	  

class ida_pro.sel_pointer():
	
	    Proxy of C++ sel_pointer class
	    

ida_pro.sel_pointer.assign():
	
	        assign(self, value)
	        

ida_pro.sel_pointer.cast():
	
	        cast(self) -> sel_t *
	        

ida_pro.sel_pointer.frompointer():
	
	        frompointer(t) -> sel_pointer
	        

ida_pro.sel_pointer.value():
	
	        value(self) -> sel_t
	        

ida_pro.sel_pointer_frompointer():
	
	  sel_pointer_frompointer(t) -> sel_pointer
	  

ida_pro.set_bits():
	
	  set_bits(bitmap, low, high)
	
	
	  Set bits between [low, high) in 'bitmap'.
	  
	  
	  @param bitmap (C++: uchar  *)
	  @param low (C++: size_t)
	  @param high (C++: size_t)
	  

class ida_pro.sizevec_t():
	
	    Proxy of C++ qvector<(size_t)> class
	    

ida_pro.sizevec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.sizevec_t.at():
	
	        at(self, _idx) -> size_t const &
	        

ida_pro.sizevec_t.begin():
	
	        begin(self) -> qvector< size_t >::iterator
	        begin(self) -> qvector< size_t >::const_iterator
	        

ida_pro.sizevec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.sizevec_t.clear():
	
	        clear(self)
	        

ida_pro.sizevec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.sizevec_t.end():
	
	        end(self) -> qvector< size_t >::iterator
	        end(self) -> qvector< size_t >::const_iterator
	        

ida_pro.sizevec_t.erase():
	
	        erase(self, it) -> qvector< size_t >::iterator
	        erase(self, first, last) -> qvector< size_t >::iterator
	        

ida_pro.sizevec_t.extract():
	
	        extract(self) -> size_t *
	        

ida_pro.sizevec_t.find():
	
	        find(self, x) -> qvector< size_t >::iterator
	        find(self, x) -> qvector< size_t >::const_iterator
	        

ida_pro.sizevec_t.grow():
	
	        grow(self, x=size_t())
	        

ida_pro.sizevec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.sizevec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.sizevec_t.insert():
	
	        insert(self, it, x) -> qvector< size_t >::iterator
	        

ida_pro.sizevec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.sizevec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> size_t &
	        

ida_pro.sizevec_t.qclear():
	
	        qclear(self)
	        

ida_pro.sizevec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.sizevec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.sizevec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.sizevec_t.swap():
	
	        swap(self, r)
	        

ida_pro.sizevec_t.truncate():
	
	        truncate(self)
	        

ida_pro.str2user():
	
	  str2user(str) -> PyObject *
	
	
	  Insert C-style escape characters to string
	  
	  @return: new string with escape characters inserted
	  

class ida_pro.strvec_t():
	
	    Proxy of C++ qvector<(simpleline_t)> class
	    

ida_pro.strvec_t.at():
	
	        __getitem__(self, i) -> simpleline_t const &
	        

ida_pro.strvec_t.begin():
	
	        begin(self) -> qvector< simpleline_t >::iterator
	        begin(self) -> qvector< simpleline_t >::const_iterator
	        

ida_pro.strvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.strvec_t.clear():
	
	        clear(self)
	        

ida_pro.strvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.strvec_t.end():
	
	        end(self) -> qvector< simpleline_t >::iterator
	        end(self) -> qvector< simpleline_t >::const_iterator
	        

ida_pro.strvec_t.erase():
	
	        erase(self, it) -> qvector< simpleline_t >::iterator
	        erase(self, first, last) -> qvector< simpleline_t >::iterator
	        

ida_pro.strvec_t.extract():
	
	        extract(self) -> simpleline_t *
	        

ida_pro.strvec_t.grow():
	
	        grow(self, x=simpleline_t())
	        

ida_pro.strvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.strvec_t.insert():
	
	        insert(self, it, x) -> qvector< simpleline_t >::iterator
	        

ida_pro.strvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.strvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> simpleline_t &
	        

ida_pro.strvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.strvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.strvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.strvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.strvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.strvec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.sval_pointer():
	
	    Proxy of C++ sval_pointer class
	    

ida_pro.sval_pointer.assign():
	
	        assign(self, value)
	        

ida_pro.sval_pointer.cast():
	
	        cast(self) -> sval_t *
	        

ida_pro.sval_pointer.frompointer():
	
	        frompointer(t) -> sval_pointer
	        

ida_pro.sval_pointer.value():
	
	        value(self) -> sval_t
	        

ida_pro.sval_pointer_frompointer():
	
	  sval_pointer_frompointer(t) -> sval_pointer
	  

class ida_pro.svalvec_t():
	
	    Proxy of C++ qvector<(signed-ea-like-numeric-type)> class
	    

ida_pro.svalvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.svalvec_t.at():
	
	        __getitem__(self, i) -> signed-ea-like-numeric-type &
	        

ida_pro.svalvec_t.begin():
	
	        begin(self) -> qvector< signed-ea-like-numeric-type >::iterator
	        begin(self) -> qvector< signed-ea-like-numeric-type >::const_iterator
	        

ida_pro.svalvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.svalvec_t.clear():
	
	        clear(self)
	        

ida_pro.svalvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.svalvec_t.end():
	
	        end(self) -> qvector< signed-ea-like-numeric-type >::iterator
	        end(self) -> qvector< signed-ea-like-numeric-type >::const_iterator
	        

ida_pro.svalvec_t.erase():
	
	        erase(self, it) -> qvector< signed-ea-like-numeric-type >::iterator
	        erase(self, first, last) -> qvector< signed-ea-like-numeric-type >::iterator
	        

ida_pro.svalvec_t.extract():
	
	        extract(self) -> signed-ea-like-numeric-type *
	        

ida_pro.svalvec_t.find():
	
	        find(self, x) -> qvector< signed-ea-like-numeric-type >::iterator
	        find(self, x) -> qvector< signed-ea-like-numeric-type >::const_iterator
	        

ida_pro.svalvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.svalvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.svalvec_t.insert():
	
	        insert(self, it, x) -> qvector< signed-ea-like-numeric-type >::iterator
	        

ida_pro.svalvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.svalvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> signed-ea-like-numeric-type &
	        

ida_pro.svalvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.svalvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.svalvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.svalvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.svalvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.svalvec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.tid_array():
	
	    Proxy of C++ tid_array class
	    

ida_pro.tid_array.cast():
	
	        cast(self) -> tid_t *
	        

ida_pro.tid_array.frompointer():
	
	        frompointer(t) -> tid_array
	        

ida_pro.tid_array_frompointer():
	
	  tid_array_frompointer(t) -> tid_array
	  

class ida_pro.uchar_array():
	
	    Proxy of C++ uchar_array class
	    

ida_pro.uchar_array.cast():
	
	        cast(self) -> uchar *
	        

ida_pro.uchar_array.frompointer():
	
	        frompointer(t) -> uchar_array
	        

ida_pro.uchar_array_frompointer():
	
	  uchar_array_frompointer(t) -> uchar_array
	  

class ida_pro.uint64vec_t():
	
	    Proxy of C++ qvector<(unsigned long long)> class
	    

ida_pro.uint64vec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.uint64vec_t.at():
	
	        __getitem__(self, i) -> unsigned long long const &
	        

ida_pro.uint64vec_t.begin():
	
	        begin(self) -> qvector< unsigned long long >::iterator
	        begin(self) -> qvector< unsigned long long >::const_iterator
	        

ida_pro.uint64vec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.uint64vec_t.clear():
	
	        clear(self)
	        

ida_pro.uint64vec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.uint64vec_t.end():
	
	        end(self) -> qvector< unsigned long long >::iterator
	        end(self) -> qvector< unsigned long long >::const_iterator
	        

ida_pro.uint64vec_t.erase():
	
	        erase(self, it) -> qvector< unsigned long long >::iterator
	        erase(self, first, last) -> qvector< unsigned long long >::iterator
	        

ida_pro.uint64vec_t.extract():
	
	        extract(self) -> unsigned long long *
	        

ida_pro.uint64vec_t.find():
	
	        find(self, x) -> qvector< unsigned long long >::iterator
	        find(self, x) -> qvector< unsigned long long >::const_iterator
	        

ida_pro.uint64vec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.uint64vec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.uint64vec_t.insert():
	
	        insert(self, it, x) -> qvector< unsigned long long >::iterator
	        

ida_pro.uint64vec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.uint64vec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> unsigned long long &
	        

ida_pro.uint64vec_t.qclear():
	
	        qclear(self)
	        

ida_pro.uint64vec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.uint64vec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.uint64vec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.uint64vec_t.swap():
	
	        swap(self, r)
	        

ida_pro.uint64vec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.uintvec_t():
	
	    Proxy of C++ qvector<(unsigned int)> class
	    

ida_pro.uintvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.uintvec_t.at():
	
	        __getitem__(self, i) -> unsigned int const &
	        

ida_pro.uintvec_t.begin():
	
	        begin(self) -> qvector< unsigned int >::iterator
	        begin(self) -> qvector< unsigned int >::const_iterator
	        

ida_pro.uintvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.uintvec_t.clear():
	
	        clear(self)
	        

ida_pro.uintvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.uintvec_t.end():
	
	        end(self) -> qvector< unsigned int >::iterator
	        end(self) -> qvector< unsigned int >::const_iterator
	        

ida_pro.uintvec_t.erase():
	
	        erase(self, it) -> qvector< unsigned int >::iterator
	        erase(self, first, last) -> qvector< unsigned int >::iterator
	        

ida_pro.uintvec_t.extract():
	
	        extract(self) -> unsigned int *
	        

ida_pro.uintvec_t.find():
	
	        find(self, x) -> qvector< unsigned int >::iterator
	        find(self, x) -> qvector< unsigned int >::const_iterator
	        

ida_pro.uintvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.uintvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.uintvec_t.insert():
	
	        insert(self, it, x) -> qvector< unsigned int >::iterator
	        

ida_pro.uintvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.uintvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> unsigned int &
	        

ida_pro.uintvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.uintvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.uintvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.uintvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.uintvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.uintvec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.ulonglongvec_t():
	
	    Proxy of C++ qvector<(unsigned long long)> class
	    

ida_pro.ulonglongvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.ulonglongvec_t.at():
	
	        __getitem__(self, i) -> unsigned long long const &
	        

ida_pro.ulonglongvec_t.begin():
	
	        begin(self) -> qvector< unsigned long long >::iterator
	        begin(self) -> qvector< unsigned long long >::const_iterator
	        

ida_pro.ulonglongvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.ulonglongvec_t.clear():
	
	        clear(self)
	        

ida_pro.ulonglongvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.ulonglongvec_t.end():
	
	        end(self) -> qvector< unsigned long long >::iterator
	        end(self) -> qvector< unsigned long long >::const_iterator
	        

ida_pro.ulonglongvec_t.erase():
	
	        erase(self, it) -> qvector< unsigned long long >::iterator
	        erase(self, first, last) -> qvector< unsigned long long >::iterator
	        

ida_pro.ulonglongvec_t.extract():
	
	        extract(self) -> unsigned long long *
	        

ida_pro.ulonglongvec_t.find():
	
	        find(self, x) -> qvector< unsigned long long >::iterator
	        find(self, x) -> qvector< unsigned long long >::const_iterator
	        

ida_pro.ulonglongvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.ulonglongvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.ulonglongvec_t.insert():
	
	        insert(self, it, x) -> qvector< unsigned long long >::iterator
	        

ida_pro.ulonglongvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.ulonglongvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> unsigned long long &
	        

ida_pro.ulonglongvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.ulonglongvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.ulonglongvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.ulonglongvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.ulonglongvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.ulonglongvec_t.truncate():
	
	        truncate(self)
	        

class ida_pro.uval_array():
	
	    Proxy of C++ uval_array class
	    

ida_pro.uval_array.cast():
	
	        cast(self) -> uval_t *
	        

ida_pro.uval_array.frompointer():
	
	        frompointer(t) -> uval_array
	        

ida_pro.uval_array_frompointer():
	
	  uval_array_frompointer(t) -> uval_array
	  

class ida_pro.uvalvec_t():
	
	    Proxy of C++ qvector<(unsigned-ea-like-numeric-type)> class
	    

ida_pro.uvalvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_pro.uvalvec_t.at():
	
	        __getitem__(self, i) -> unsigned-ea-like-numeric-type &
	        

ida_pro.uvalvec_t.begin():
	
	        begin(self) -> qvector< unsigned-ea-like-numeric-type >::iterator
	        begin(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator
	        

ida_pro.uvalvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_pro.uvalvec_t.clear():
	
	        clear(self)
	        

ida_pro.uvalvec_t.empty():
	
	        empty(self) -> bool
	        

ida_pro.uvalvec_t.end():
	
	        end(self) -> qvector< unsigned-ea-like-numeric-type >::iterator
	        end(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator
	        

ida_pro.uvalvec_t.erase():
	
	        erase(self, it) -> qvector< unsigned-ea-like-numeric-type >::iterator
	        erase(self, first, last) -> qvector< unsigned-ea-like-numeric-type >::iterator
	        

ida_pro.uvalvec_t.extract():
	
	        extract(self) -> unsigned-ea-like-numeric-type *
	        

ida_pro.uvalvec_t.find():
	
	        find(self, x) -> qvector< unsigned-ea-like-numeric-type >::iterator
	        find(self, x) -> qvector< unsigned-ea-like-numeric-type >::const_iterator
	        

ida_pro.uvalvec_t.has():
	
	        has(self, x) -> bool
	        

ida_pro.uvalvec_t.inject():
	
	        inject(self, s, len)
	        

ida_pro.uvalvec_t.insert():
	
	        insert(self, it, x) -> qvector< unsigned-ea-like-numeric-type >::iterator
	        

ida_pro.uvalvec_t.pop_back():
	
	        pop_back(self)
	        

ida_pro.uvalvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> unsigned-ea-like-numeric-type &
	        

ida_pro.uvalvec_t.qclear():
	
	        qclear(self)
	        

ida_pro.uvalvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_pro.uvalvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_pro.uvalvec_t.size():
	
	        size(self) -> size_t
	        

ida_pro.uvalvec_t.swap():
	
	        swap(self, r)
	        

ida_pro.uvalvec_t.truncate():
	
	        truncate(self)
	        

ida_pro.writebytes():
	
	  writebytes(h, l, size, mf) -> int
	
	
	  Write at most 4 bytes to file.
	  
	  @param h: file handle (C++: int)
	  @param l: value to write (C++: uint32)
	  @param size: size of value in bytes (1,2,4) (C++: int)
	  @param mf: is MSB first? (C++: bool)
	  @return: 0 on success, nonzero otherwise
	  


=== ida_pro EPYDOC INJECTIONS ===
ida_pro.CP_UTF16
"""
UTF-16 codepage.
"""

ida_pro.IDA_SDK_VERSION
"""
IDA SDK v7.2.
"""

ida_pro.IDBDEC_ESCAPE
"""
convert non-printable characters to C escapes (, , )
"""

ida_pro.IOREDIR_APPEND
"""
append, do not overwrite the output file
"""

ida_pro.IOREDIR_INPUT
"""
input redirection
"""

ida_pro.IOREDIR_OUTPUT
"""
output redirection
"""

ida_pro.IOREDIR_QUOTED
"""
the file name was quoted
"""

ida_pro.MAXSTR
"""
maximum string size
"""

ida_pro.SUBSTCHAR
"""
default char, used if a char cannot be represented in a codepage
"""

ida_pro.__MF__
"""
byte sex of our platform (Most significant byte First). 0: little
endian (Intel 80x86). 1: big endian (PowerPC).
"""
=== ida_pro EPYDOC INJECTIONS END ===
ida_problems.forget_problem():
	
	  forget_problem(type, ea) -> bool
	
	
	  Remove an address from a problem list
	  
	  @param type: problem list type (C++: problist_id_t)
	  @param ea: linear address (C++: ea_t)
	  @return: success
	  

ida_problems.get_problem():
	
	  get_problem(type, lowea) -> ea_t
	
	
	  Get an address from the specified problem list. The address is not
	  removed from the list.
	  
	  @param type: problem list type (C++: problist_id_t)
	  @param lowea: the returned address will be higher or equal than the
	                specified address (C++: ea_t)
	  @return: linear address or  BADADDR
	  

ida_problems.get_problem_desc():
	
	  get_problem_desc(t, ea) -> ssize_t
	
	
	  Get the human-friendly description of the problem, if one was provided
	  to remember_problem.
	  
	  @param t: problem list type. (C++: problist_id_t)
	  @param ea: linear address. (C++: ea_t)
	  @return: the message length or -1 if none
	  

ida_problems.get_problem_name():
	
	  get_problem_name(type, longname=True) -> char const *
	
	
	  Get problem list description.
	  
	  
	  @param type (C++: problist_id_t)
	  @param longname (C++: bool)
	  

ida_problems.is_problem_present():
	
	  is_problem_present(t, ea) -> bool
	
	
	  Check if the specified address is present in the problem list.
	  
	  
	  @param t (C++: problist_id_t)
	  @param ea (C++: ea_t)
	  

ida_problems.remember_problem():
	
	  remember_problem(type, ea, msg=None)
	
	
	  Insert an address to a list of problems. Display a message saying
	  about the problem (except of 'PR_ATTN' , 'PR_FINAL' ) 'PR_JUMP' is
	  temporarily ignored.
	  
	  @param type: problem list type (C++: problist_id_t)
	  @param ea: linear address (C++: ea_t)
	  @param msg: a user-friendly message to be displayed instead of the
	              default more generic one associated with the type of
	              problem. Defaults to NULL. (C++: const char *)
	  

ida_problems.was_ida_decision():
	
	  was_ida_decision(ea) -> bool
	  

class ida_range.array_of_rangesets():
	
	    Proxy of C++ qvector<(rangeset_t)> class
	    

ida_range.array_of_rangesets.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_range.array_of_rangesets.at():
	
	        at(self, _idx) -> rangeset_t
	        

ida_range.array_of_rangesets.begin():
	
	        begin(self) -> rangeset_t
	        begin(self) -> rangeset_t
	        

ida_range.array_of_rangesets.capacity():
	
	        capacity(self) -> size_t
	        

ida_range.array_of_rangesets.clear():
	
	        clear(self)
	        

ida_range.array_of_rangesets.empty():
	
	        empty(self) -> bool
	        

ida_range.array_of_rangesets.end():
	
	        end(self) -> rangeset_t
	        end(self) -> rangeset_t
	        

ida_range.array_of_rangesets.erase():
	
	        erase(self, it) -> rangeset_t
	        erase(self, first, last) -> rangeset_t
	        

ida_range.array_of_rangesets.extract():
	
	        extract(self) -> rangeset_t
	        

ida_range.array_of_rangesets.find():
	
	        find(self, x) -> rangeset_t
	        find(self, x) -> rangeset_t
	        

ida_range.array_of_rangesets.grow():
	
	        grow(self, x=rangeset_t())
	        

ida_range.array_of_rangesets.has():
	
	        has(self, x) -> bool
	        

ida_range.array_of_rangesets.inject():
	
	        inject(self, s, len)
	        

ida_range.array_of_rangesets.insert():
	
	        insert(self, it, x) -> rangeset_t
	        

ida_range.array_of_rangesets.pop_back():
	
	        pop_back(self)
	        

ida_range.array_of_rangesets.push_back():
	
	        push_back(self, x)
	        push_back(self) -> rangeset_t
	        

ida_range.array_of_rangesets.qclear():
	
	        qclear(self)
	        

ida_range.array_of_rangesets.reserve():
	
	        reserve(self, cnt)
	        

ida_range.array_of_rangesets.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_range.array_of_rangesets.size():
	
	        size(self) -> size_t
	        

ida_range.array_of_rangesets.swap():
	
	        swap(self, r)
	        

ida_range.array_of_rangesets.truncate():
	
	        truncate(self)
	        

class ida_range.range_t():
	
	    Proxy of C++ range_t class
	    

ida_range.range_t._print():
	
	        _print(self) -> size_t
	        

ida_range.range_t.clear():
	
	        clear(self)
	        

ida_range.range_t.compare():
	
	        compare(self, r) -> int
	        

ida_range.range_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_range.range_t.empty():
	
	        empty(self) -> bool
	        

ida_range.range_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_range.range_t.extend():
	
	        extend(self, ea)
	        

ida_range.range_t.intersect():
	
	        intersect(self, r)
	        

ida_range.range_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_range.range_t.size():
	
	        size(self) -> asize_t
	        

ida_range.range_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

ida_range.range_t_print():
	
	  range_t_print(cb) -> size_t
	
	
	  Helper function. Should not be called directly!
	  

class ida_range.rangeset_t():
	
	    Proxy of C++ rangeset_t class
	    

ida_range.rangeset_t._print():
	
	        _print(self) -> size_t
	        

ida_range.rangeset_t.add():
	
	        add(self, range) -> bool
	        add(self, start, _end) -> bool
	        add(self, aset) -> bool
	        

ida_range.rangeset_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_range.rangeset_t.cached_range():
	
	        cached_range(self) -> range_t
	        

ida_range.rangeset_t.clear():
	
	        clear(self)
	        

ida_range.rangeset_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, aset) -> bool
	        

ida_range.rangeset_t.empty():
	
	        empty(self) -> bool
	        

ida_range.rangeset_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_range.rangeset_t.find_range():
	
	        find_range(self, ea) -> range_t
	        

ida_range.rangeset_t.getrange():
	
	        getrange(self, idx) -> range_t
	        

ida_range.rangeset_t.has_common():
	
	        has_common(self, range) -> bool
	        has_common(self, aset) -> bool
	        

ida_range.rangeset_t.includes():
	
	        includes(self, range) -> bool
	        

ida_range.rangeset_t.intersect():
	
	        intersect(self, aset) -> bool
	        

ida_range.rangeset_t.is_equal():
	
	        is_equal(self, aset) -> bool
	        

ida_range.rangeset_t.is_subset_of():
	
	        is_subset_of(self, aset) -> bool
	        

ida_range.rangeset_t.lastrange():
	
	        lastrange(self) -> range_t
	        

ida_range.rangeset_t.next_addr():
	
	        next_addr(self, ea) -> ea_t
	        

ida_range.rangeset_t.next_range():
	
	        next_range(self, ea) -> ea_t
	        

ida_range.rangeset_t.nranges():
	
	        nranges(self) -> size_t
	        

ida_range.rangeset_t.prev_addr():
	
	        prev_addr(self, ea) -> ea_t
	        

ida_range.rangeset_t.prev_range():
	
	        prev_range(self, ea) -> ea_t
	        

ida_range.rangeset_t.sub():
	
	        sub(self, range) -> bool
	        sub(self, ea) -> bool
	        sub(self, aset) -> bool
	        

ida_range.rangeset_t.swap():
	
	        swap(self, r)
	        

class ida_range.rangevec_base_t():
	
	    Proxy of C++ qvector<(range_t)> class
	    

ida_range.rangevec_base_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_range.rangevec_base_t.at():
	
	        at(self, _idx) -> range_t
	        

ida_range.rangevec_base_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_range.rangevec_base_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_range.rangevec_base_t.clear():
	
	        clear(self)
	        

ida_range.rangevec_base_t.empty():
	
	        empty(self) -> bool
	        

ida_range.rangevec_base_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_range.rangevec_base_t.erase():
	
	        erase(self, it) -> range_t
	        erase(self, first, last) -> range_t
	        

ida_range.rangevec_base_t.extract():
	
	        extract(self) -> range_t
	        

ida_range.rangevec_base_t.find():
	
	        find(self, x) -> range_t
	        find(self, x) -> range_t
	        

ida_range.rangevec_base_t.grow():
	
	        grow(self, x=range_t())
	        

ida_range.rangevec_base_t.has():
	
	        has(self, x) -> bool
	        

ida_range.rangevec_base_t.inject():
	
	        inject(self, s, len)
	        

ida_range.rangevec_base_t.insert():
	
	        insert(self, it, x) -> range_t
	        

ida_range.rangevec_base_t.pop_back():
	
	        pop_back(self)
	        

ida_range.rangevec_base_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> range_t
	        

ida_range.rangevec_base_t.qclear():
	
	        qclear(self)
	        

ida_range.rangevec_base_t.reserve():
	
	        reserve(self, cnt)
	        

ida_range.rangevec_base_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_range.rangevec_base_t.size():
	
	        size(self) -> size_t
	        

ida_range.rangevec_base_t.swap():
	
	        swap(self, r)
	        

ida_range.rangevec_base_t.truncate():
	
	        truncate(self)
	        

class ida_range.rangevec_t():
	
	    Proxy of C++ rangevec_t class
	    

ida_range.rangevec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_range.rangevec_t.at():
	
	        at(self, _idx) -> range_t
	        

ida_range.rangevec_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_range.rangevec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_range.rangevec_t.clear():
	
	        clear(self)
	        

ida_range.rangevec_t.empty():
	
	        empty(self) -> bool
	        

ida_range.rangevec_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_range.rangevec_t.erase():
	
	        erase(self, it) -> range_t
	        erase(self, first, last) -> range_t
	        

ida_range.rangevec_t.extract():
	
	        extract(self) -> range_t
	        

ida_range.rangevec_t.find():
	
	        find(self, x) -> range_t
	        find(self, x) -> range_t
	        

ida_range.rangevec_t.grow():
	
	        grow(self, x=range_t())
	        

ida_range.rangevec_t.has():
	
	        has(self, x) -> bool
	        

ida_range.rangevec_t.inject():
	
	        inject(self, s, len)
	        

ida_range.rangevec_t.insert():
	
	        insert(self, it, x) -> range_t
	        

ida_range.rangevec_t.pop_back():
	
	        pop_back(self)
	        

ida_range.rangevec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> range_t
	        

ida_range.rangevec_t.qclear():
	
	        qclear(self)
	        

ida_range.rangevec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_range.rangevec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_range.rangevec_t.size():
	
	        size(self) -> size_t
	        

ida_range.rangevec_t.swap():
	
	        swap(self, r)
	        

ida_range.rangevec_t.truncate():
	
	        truncate(self)
	        

ida_registry.reg_data_type():
	
	  reg_data_type(name, subkey=None) -> regval_type_t
	
	
	  Get data type of a given value.
	  
	  @param name: value name (C++: const char *)
	  @param subkey: key name (C++: const char *)
	  @return: false if the [key+]value doesn't exist
	  

ida_registry.reg_delete():
	
	  reg_delete(name, subkey=None) -> bool
	
	
	  Delete a value from the registry.
	  
	  @param name: value name (C++: const char *)
	  @param subkey: parent key (C++: const char *)
	  @return: success
	  

ida_registry.reg_delete_subkey():
	
	  reg_delete_subkey(name) -> bool
	
	
	  Delete a key from the registry.
	  
	  
	  @param name (C++: const char *)
	  

ida_registry.reg_delete_tree():
	
	  reg_delete_tree(name) -> bool
	
	
	  Delete a subtree from the registry.
	  
	  
	  @param name (C++: const char *)
	  

ida_registry.reg_exists():
	
	  reg_exists(name, subkey=None) -> bool
	
	
	  Is there already a value with the given name?
	  
	  @param name: value name (C++: const char *)
	  @param subkey: parent key (C++: const char *)
	  

ida_registry.reg_flush():
	
	  reg_flush()
	  

ida_registry.reg_load():
	
	  reg_load()
	  

ida_registry.reg_read_binary():
	
	  reg_read_binary(name, subkey=None) -> PyObject *
	
	
	  Read binary data from the registry.
	  
	  @param name: value name (C++: const char *)
	  @param subkey: key name (C++: const char *)
	  @return: false if 'data' is not large enough to hold all data present.
	           in this case 'data' is left untouched.
	  

ida_registry.reg_read_bool():
	
	  reg_read_bool(name, defval, subkey=None) -> bool
	
	
	  Read boolean value from the registry.
	  
	  @param name: value name (C++: const char *)
	  @param defval: default value (C++: bool)
	  @param subkey: key name (C++: const char *)
	  @return: boolean read from registry, or 'defval' if the read failed
	  

ida_registry.reg_read_int():
	
	  reg_read_int(name, defval, subkey=None) -> int
	
	
	  Read integer value from the registry.
	  
	  @param name: value name (C++: const char *)
	  @param defval: default value (C++: int)
	  @param subkey: key name (C++: const char *)
	  @return: the value read from the registry, or 'defval' if the read
	           failed
	  

ida_registry.reg_read_string():
	
	  reg_read_string(name, subkey=None, _def=None) -> PyObject *
	
	
	  Read a string from the registry.
	  
	  @param name: value name (C++: const char *)
	  @param subkey: key name (C++: const char *)
	  @return: success
	  

ida_registry.reg_read_strlist():
	
	  reg_read_strlist(list, subkey)
	
	
	  Retrieve all string values associated with the given key. Also see
	  'reg_update_strlist()' .
	  
	  @param list (C++: qstrvec_t  *)
	  @param subkey (C++: const char *)
	  

ida_registry.reg_subkey_exists():
	
	  reg_subkey_exists(name) -> bool
	
	
	  Is there already a key with the given name?
	  
	  
	  @param name (C++: const char *)
	  

ida_registry.reg_subkey_subkeys():
	
	  reg_subkey_subkeys(name) -> PyObject *
	
	
	  Get all subkey names of given key.
	  
	  
	  @param name (C++: const char *)
	  

ida_registry.reg_subkey_values():
	
	  reg_subkey_values(name) -> PyObject *
	
	
	  Get all value names under given key.
	  
	  
	  @param name (C++: const char *)
	  

ida_registry.reg_update_filestrlist():
	
	  reg_update_filestrlist(subkey, add, maxrecs, rem=None)
	
	
	  Update registry with a file list. Case sensitivity will vary depending
	  on the target OS.'add' and 'rem' must be UTF-8, just like for regular
	  string operations.
	  
	  @param subkey (C++: const char *)
	  @param add (C++: const char *)
	  @param maxrecs (C++: size_t)
	  @param rem (C++: const char *)
	  

ida_registry.reg_update_strlist():
	
	  reg_update_strlist(subkey, add, maxrecs, rem=None, ignorecase=False)
	
	
	  Update list of strings associated with given key.
	  
	  @param subkey: key name (C++: const char *)
	  @param add: string to be added to list, can be NULL (C++: const char
	              *)
	  @param maxrecs: limit list to this size (C++: size_t)
	  @param rem: string to be removed from list, can be NULL (C++: const
	              char *)
	  @param ignorecase: ignore case for 'add' and 'rem' (C++: bool)
	  

ida_registry.reg_write_binary():
	
	  reg_write_binary(name, py_bytes, subkey=None)
	
	
	  Write binary data to the registry.
	  
	  @param name: value name (C++: const char *)
	  @param subkey: key name (C++: const char *)
	  

ida_registry.reg_write_bool():
	
	  reg_write_bool(name, value, subkey=None)
	
	
	  Write boolean value to the registry.
	  
	  @param name: value name (C++: const char *)
	  @param value: boolean to write (nonzero = true) (C++: int)
	  @param subkey: key name (C++: const char *)
	  

ida_registry.reg_write_int():
	
	  reg_write_int(name, value, subkey=None)
	
	
	  Write integer value to the registry.
	  
	  @param name: value name (C++: const char *)
	  @param value: value to write (C++: int)
	  @param subkey: key name (C++: const char *)
	  

ida_registry.reg_write_string():
	
	  reg_write_string(name, utf8, subkey=None)
	
	
	  Write a string to the registry.
	  
	  @param name: value name (C++: const char *)
	  @param utf8: utf8-encoded string (C++: const char *)
	  @param subkey: key name (C++: const char *)
	  


=== ida_registry EPYDOC INJECTIONS ===
ida_registry.ROOT_KEY_NAME
"""
Key used to store IDA settings in registry (Windows version).this name
is automatically prepended to all key names passed to functions in
this file.
"""
=== ida_registry EPYDOC INJECTIONS END ===
ida_search.find_binary():
	
	  find_binary(arg1, arg2, arg3, arg4, arg5) -> ea_t
	  

ida_search.find_code():
	
	  find_code(ea, sflag) -> ea_t
	
	
	  Find next code address.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_data():
	
	  find_data(ea, sflag) -> ea_t
	
	
	  Find next data address.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_defined():
	
	  find_defined(ea, sflag) -> ea_t
	
	
	  Find next ea that is the start of an instruction or data.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_error():
	
	  find_error(ea, sflag) -> ea_t
	
	
	  Find next error or problem.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_imm():
	
	  find_imm(newEA, sflag, srchValue) -> ea_t
	
	
	  Find next immediate operand with the given value.
	  
	  
	  @param newEA (C++: ea_t)
	  @param sflag (C++: int)
	  @param srchValue (C++: uval_t)
	  

ida_search.find_not_func():
	
	  find_not_func(ea, sflag) -> ea_t
	
	
	  Find next code address that does not belong to a function.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_notype():
	
	  find_notype(ea, sflag) -> ea_t
	
	
	  Find next operand without any type info.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_suspop():
	
	  find_suspop(ea, sflag) -> ea_t
	
	
	  Find next suspicious operand.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.find_text():
	
	  find_text(start_ea, y, x, ustr, sflag) -> ea_t
	
	
	  See 'search()'
	  
	  
	  @param start_ea (C++: ea_t)
	  @param y (C++: int)
	  @param x (C++: int)
	  @param ustr (C++: const char *)
	  @param sflag (C++: int)
	  

ida_search.find_unknown():
	
	  find_unknown(ea, sflag) -> ea_t
	
	
	  Find next unexplored address.
	  
	  
	  @param ea (C++: ea_t)
	  @param sflag (C++: int)
	  

ida_search.search_down():
	
	  search_down(sflag) -> bool
	
	
	  Is the 'SEARCH_DOWN' bit set?
	  
	  
	  @param sflag (C++: int)
	  


=== ida_search EPYDOC INJECTIONS ===
ida_search.SEARCH_BRK
"""
return 'BADADDR' if Ctrl-Break wass pressed during search
"""

ida_search.SEARCH_CASE
"""
case-sensitive search (case-insensitive otherwise)
"""

ida_search.SEARCH_DOWN
"""
search towards higher addresses
"""

ida_search.SEARCH_IDENT
"""
search for an identifier (text search). it means that the characters
before and after the match can not be is_visible_char().
"""

ida_search.SEARCH_NEXT
"""
for other find_.. functions it is implicitly set

useful only for 'search()' and find_binary().
"""

ida_search.SEARCH_NOBRK
"""
don't test for ctrl-break to interrupt the search
"""

ida_search.SEARCH_NOSHOW
"""
don't display the search progress/refresh screen
"""

ida_search.SEARCH_REGEX
"""
regular expressions in search string (only supported for txt search)
"""

ida_search.SEARCH_UP
"""
search towards lower addresses
"""
=== ida_search EPYDOC INJECTIONS END ===
ida_segment.add_segm():
	
	  add_segm(para, start, end, name, sclass, flags=0) -> bool
	
	
	  Add a new segment, second form. Segment alignment is set to
	  'saRelByte' . Segment combination is "public" or "stack" (if segment
	  class is "STACK"). Addressing mode of segment is taken as default
	  (16bit or 32bit). Default segment registers are set to 'BADSEL' . If a
	  segment already exists at the specified range of addresses, this
	  segment will be truncated. Instructions and data in the old segment
	  will be deleted if the new segment has another addressing mode or
	  another segment base address.
	  
	  @param para: segment base paragraph. if paragraph can't fit in 16bit,
	               then a new selector is allocated and mapped to the
	               paragraph. (C++: ea_t)
	  @param start: start address of the segment. if start== BADADDR  then
	                start <- to_ea(para,0). (C++: ea_t)
	  @param end: end address of the segment. end address should be higher
	              than start address. For emulate empty segments, use
	              SEG_NULL  segment type. If the end address is lower than
	              start address, then fail. If end== BADADDR , then a
	              segment up to the next segment will be created (if the
	              next segment doesn't exist, then 1 byte segment will be
	              created). If 'end' is too high and the new segment would
	              overlap the next segment, 'end' is adjusted properly.
	              (C++: ea_t)
	  @param name: name of new segment. may be NULL (C++: const char *)
	  @param sclass: class of the segment. may be NULL. type of the new
	                 segment is modified if class is one of predefined
	                 names:   "CODE" ->  SEG_CODE "DATA" ->  SEG_DATA
	                 "CONST" ->  SEG_DATA "STACK" ->  SEG_BSS "BSS" ->
	                 SEG_BSS "XTRN" ->  SEG_XTRN "COMM" ->  SEG_COMM "ABS"
	                 ->  SEG_ABSSYM (C++: const char *)
	  @param flags (C++: int)
	  

ida_segment.add_segm_ex():
	
	  add_segm_ex(s, name, sclass, flags) -> bool
	
	
	  Add a new segment. If a segment already exists at the specified range
	  of addresses, this segment will be truncated. Instructions and data in
	  the old segment will be deleted if the new segment has another
	  addressing mode or another segment base address.
	  
	  @param s: pointer to filled segment structure. segment selector should
	            have proper mapping (see  set_selector() ).   if
	            s.start_ea== BADADDR  then s.start_ea <- get_segm_base(&s)
	            if s.end_ea== BADADDR , then a segment up to the next
	            segment will be created (if the next segment doesn't exist,
	            then 1 byte segment will be created). if the s.end_ea <
	            s.start_ea, then fail. if s.end_ea is too high and the new
	            segment would overlap the next segment, s.end_ea is adjusted
	            properly. (C++: segment_t  *)
	  @param name: name of new segment. may be NULL. if specified, the
	               segment is immediately renamed (C++: const char *)
	  @param sclass: class of the segment. may be NULL. if specified, the
	                 segment class is immediately changed (C++: const char
	                 *)
	  @param flags: Add segment flags (C++: int)
	  

ida_segment.add_segment_translation():
	
	  add_segment_translation(segstart, mappedseg) -> bool
	
	
	  Add segment translation.
	  
	  @param segstart: start address of the segment to add translation to
	                   (C++: ea_t)
	  @param mappedseg: start address of the overlayed segment (C++: ea_t)
	  

ida_segment.allocate_selector():
	
	  allocate_selector(segbase) -> sel_t
	
	
	  Allocate a selector for a segment unconditionally. You must call this
	  function before calling 'add_segm_ex()' . 'add_segm()' calls this
	  function itself, so you don't need to allocate a selector. This
	  function will allocate a new free selector and setup its mapping using
	  'find_free_selector()' and 'set_selector()' functions.
	  
	  @param segbase: a new segment base paragraph (C++: ea_t)
	  @return: the allocated selector number
	  

ida_segment.change_segment_status():
	
	  change_segment_status(s, is_deb_segm) -> int
	
	
	  Convert a debugger segment to a regular segment and vice versa. When
	  converting debug->regular, the memory contents will be copied to the
	  database.
	  
	  @param s: segment to modify (C++: segment_t  *)
	  @param is_deb_segm: new status of the segment (C++: bool)
	  @return: Change segment status result codes
	  

ida_segment.del_segm():
	
	  del_segm(ea, flags) -> bool
	
	
	  Delete a segment.
	  
	  @param ea: any address belonging to the segment (C++: ea_t)
	  @param flags: Segment modification flags (C++: int)
	  

ida_segment.del_segment_translations():
	
	  del_segment_translations(segstart)
	
	
	  Delete the translation list
	  
	  @param segstart: start address of the segment to delete translation
	                   list (C++: ea_t)
	  

ida_segment.del_selector():
	
	  del_selector(selector)
	
	
	  Delete mapping of a selector. Be wary of deleting selectors that are
	  being used in the program, this can make a mess in the segments.
	  
	  @param selector: number of selector to remove from the translation
	                   table (C++: sel_t)
	  

ida_segment.find_free_selector():
	
	  find_free_selector() -> sel_t
	
	
	  Find first unused selector.
	  
	  @return: a number >= 1
	  

ida_segment.find_selector():
	
	  find_selector(base) -> sel_t
	
	
	  Find a selector that has mapping to the specified paragraph.
	  
	  @param base: paragraph to search in the translation table (C++: ea_t)
	  @return: selector value or base
	  

ida_segment.get_defsr():
	
	  get_defsr(s, reg) -> sel_t
	  

ida_segment.get_first_seg():
	
	  get_first_seg() -> segment_t
	
	
	  Get pointer to the first segment.
	  

ida_segment.get_group_selector():
	
	  get_group_selector(grpsel) -> sel_t
	
	
	  Get common selector for a group of segments.
	  
	  @param grpsel: selector of group segment (C++: sel_t)
	  @return: common selector of the group or 'grpsel' if no such group is
	           found
	  

ida_segment.get_last_seg():
	
	  get_last_seg() -> segment_t
	
	
	  Get pointer to the last segment.
	  

ida_segment.get_next_seg():
	
	  get_next_seg(ea) -> segment_t
	
	
	  Get pointer to the next segment.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_segment.get_prev_seg():
	
	  get_prev_seg(ea) -> segment_t
	
	
	  Get pointer to the previous segment.
	  
	  
	  @param ea (C++: ea_t)
	  

ida_segment.get_segm_base():
	
	  get_segm_base(s) -> ea_t
	
	
	  Get segment base linear address. Segment base linear address is used
	  to calculate virtual addresses. The virtual address of the first byte
	  of the segment will be (start address of segment - segment base linear
	  address)
	  
	  @param s: pointer to segment (C++: const  segment_t  *)
	  @return: 0 if s == NULL, otherwise segment base linear address
	  

ida_segment.get_segm_by_name():
	
	  get_segm_by_name(name) -> segment_t
	
	
	  Get pointer to segment by its name. If there are several segments with
	  the same name, returns the first of them.
	  
	  @param name: segment name. may be NULL. (C++: const char *)
	  @return: NULL or pointer to segment structure
	  

ida_segment.get_segm_by_sel():
	
	  get_segm_by_sel(selector) -> segment_t
	
	
	  Get pointer to segment structure. This function finds a segment by its
	  selector. If there are several segments with the same selectors, the
	  last one will be returned.
	  
	  @param selector: a segment with the specified selector will be
	                   returned (C++: sel_t)
	  @return: pointer to segment or NULL
	  

ida_segment.get_segm_class():
	
	  get_segm_class(s) -> ssize_t
	
	
	  Get segment class. Segment class is arbitrary text (max 8 characters).
	  
	  @param s: pointer to segment (C++: const  segment_t  *)
	  @return: size of segment class (-1 if s==NULL or bufsize<=0)
	  

ida_segment.get_segm_name():
	
	  get_segm_name(s, flags=0) -> ssize_t
	
	
	  Get true segment name by pointer to segment.
	  
	  @param s: pointer to segment (C++: const  segment_t  *)
	  @param flags: 0-return name as is; 1-substitute bad symbols with _ 1
	                corresponds to GN_VISIBLE (C++: int)
	  @return: size of segment name (-1 if s==NULL)
	  

ida_segment.get_segm_num():
	
	  get_segm_num(ea) -> int
	
	
	  Get number of segment by address.
	  
	  @param ea: linear address belonging to the segment (C++: ea_t)
	  @return: -1 if no segment occupies the specified address. otherwise
	           returns number of the specified segment (0.. get_segm_qty()
	           -1)
	  

ida_segment.get_segm_para():
	
	  get_segm_para(s) -> ea_t
	
	
	  Get segment base paragraph. Segment base paragraph may be converted to
	  segment base linear address using 'to_ea()' function. In fact,
	  to_ea(get_segm_para(s), 0) == get_segm_base(s).
	  
	  @param s: pointer to segment (C++: const  segment_t  *)
	  @return: 0 if s == NULL, the segment base paragraph
	  

ida_segment.get_segm_qty():
	
	  get_segm_qty() -> int
	
	
	  Get number of segments.
	  

ida_segment.get_segment_alignment():
	
	  get_segment_alignment(align) -> char const *
	
	
	  Get text representation of segment alignment code.
	  
	  @param align (C++: uchar)
	  @return: text digestable by IBM PC assembler.
	  

ida_segment.get_segment_cmt():
	
	  get_segment_cmt(s, repeatable) -> ssize_t
	
	
	  Get segment comment.
	  
	  @param s: pointer to segment structure (C++: const  segment_t  *)
	  @param repeatable: 0: get regular comment. 1: get repeatable comment.
	                     (C++: bool)
	  @return: size of comment or -1
	  

ida_segment.get_segment_combination():
	
	  get_segment_combination(comb) -> char const *
	
	
	  Get text representation of segment combination code.
	  
	  @param comb (C++: uchar)
	  @return: text digestable by IBM PC assembler.
	  

ida_segment.get_segment_translations():
	
	  get_segment_translations(transmap, segstart) -> ssize_t
	
	
	  Get segment translation list.
	  
	  @param transmap: vector of segment start addresses for the translation
	                   list (C++: eavec_t  *)
	  @param segstart: start address of the segment to get information about
	                   (C++: ea_t)
	  @return: -1 if no translation list or bad segstart. otherwise returns
	           size of translation list.
	  

ida_segment.get_selector_qty():
	
	  get_selector_qty() -> int
	
	
	  Get number of defined selectors.
	  

ida_segment.get_visible_segm_name():
	
	  get_visible_segm_name(s) -> ssize_t
	
	
	  Get segment name by pointer to segment.
	  
	  @param s: pointer to segment (C++: const  segment_t  *)
	  @return: size of segment name (-1 if s==NULL)
	  

ida_segment.getn_selector():
	
	  getn_selector(n) -> bool
	
	
	  Get description of selector (0.. 'get_selector_qty()' -1)
	  
	  
	  @param n (C++: int)
	  

ida_segment.getnseg():
	
	  getnseg(n) -> segment_t
	
	
	  Get pointer to segment by its number.Obsoleted because it can slow
	  down the debugger (it has to refresh the whole memory segmentation to
	  calculate the correct answer)
	  
	  @param n: segment number in the range (0.. get_segm_qty() -1) (C++:
	            int)
	  @return: NULL or pointer to segment structure
	  

ida_segment.getseg():
	
	  getseg(ea) -> segment_t
	
	
	  Get pointer to segment by linear address.
	  
	  @param ea: linear address belonging to the segment (C++: ea_t)
	  @return: NULL or pointer to segment structure
	  

ida_segment.is_finally_visible_segm():
	
	  is_finally_visible_segm(s) -> bool
	
	
	  See 'SFL_HIDDEN' , 'SW_SHHID_SEGM' .
	  
	  
	  @param s (C++: segment_t  *)
	  

ida_segment.is_miniidb():
	
	  is_miniidb() -> bool
	
	
	  Is the database a miniidb created by the debugger?.
	  
	  @return: true if the database contains no segments or only debugger
	           segments
	  

ida_segment.is_segm_locked():
	
	  is_segm_locked(segm) -> bool
	
	
	  Is a segment pointer locked?
	  
	  
	  @param segm (C++: const  segment_t  *)
	  

ida_segment.is_spec_ea():
	
	  is_spec_ea(ea) -> bool
	
	
	  Does the address belong to a segment with a special type?. (
	  'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' , 'SEG_COMM' )
	  
	  @param ea: linear address (C++: ea_t)
	  

ida_segment.is_spec_segm():
	
	  is_spec_segm(seg_type) -> bool
	
	
	  Has segment a special type?. ( 'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' ,
	  'SEG_COMM' )
	  
	  @param seg_type (C++: uchar)
	  

ida_segment.is_visible_segm():
	
	  is_visible_segm(s) -> bool
	
	
	  See 'SFL_HIDDEN' .
	  
	  
	  @param s (C++: segment_t  *)
	  

ida_segment.lock_segm():
	
	  lock_segm(segm, lock)
	
	
	  Lock segment pointer Locked pointers are guaranteed to remain valid
	  until they are unlocked. Ranges with locked pointers can not be
	  deleted or moved.
	  
	  @param segm (C++: const  segment_t  *)
	  @param lock (C++: bool)
	  

class ida_segment.lock_segment():
	
	    Proxy of C++ lock_segment class
	    

ida_segment.move_segm():
	
	  move_segm(s, to, flags=0) -> int
	
	
	  Move a segment to a new address. This function moves all information
	  to the new address. It fixes up address sensitive information in the
	  kernel. The total effect is equal to reloading the segment to the
	  target address. For the file format dependent address sensitive
	  information, 'loader_t::move_segm' is called. Also IDB notification
	  event 'idb_event::segm_moved' is called.
	  
	  @param s: segment to move (C++: segment_t  *)
	  @param to: new segment start address (C++: ea_t)
	  @param flags: Move segment flags (C++: int)
	  @return: Move segment result codes
	  

ida_segment.move_segm_start():
	
	  move_segm_start(ea, newstart, mode) -> bool
	
	
	  Move segment start. The main difference between this function and
	  'set_segm_start()' is that this function may expand the previous
	  segment while 'set_segm_start()' never does it. So, this function
	  allows to change bounds of two segments simultaneously. If the
	  previous segment and the specified segment have the same addressing
	  mode and segment base, then instructions and data are not destroyed -
	  they simply move from one segment to another. Otherwise all
	  instructions/data which migrate from one segment to another are
	  destroyed.this function never disables addresses.
	  
	  @param ea: any address belonging to the segment (C++: ea_t)
	  @param newstart: new start address of the segment note that segment
	                   start address should be higher than segment base
	                   linear address. (C++: ea_t)
	  @param mode: policy for destroying defined items   0: if it is
	               necessary to destroy defined items, display a dialog box
	               and ask confirmation 1: if it is necessary to destroy
	               defined items, just destroy them without asking the user
	               -1: if it is necessary to destroy defined items, don't
	               destroy them (i.e. function will fail) -2: don't destroy
	               defined items (function will succeed) (C++: int)
	  

ida_segment.rebase_program():
	
	  rebase_program(delta, flags) -> int
	
	
	  Rebase the whole program by 'delta' bytes.
	  
	  @param delta: number of bytes to move the program (C++: adiff_t)
	  @param flags: Move segment flags  it is recommended to use
	                MSF_FIXONCE  so that the loader takes care of global
	                variables it stored in the database (C++: int)
	  @return: Move segment result codes
	  

ida_segment.segm_adjust_diff():
	
	  segm_adjust_diff(s, delta) -> adiff_t
	
	
	  Truncate and sign extend a delta depending on the segment.
	  
	  
	  @param s (C++: const  segment_t  *)
	  @param delta (C++: adiff_t)
	  

ida_segment.segm_adjust_ea():
	
	  segm_adjust_ea(s, ea) -> ea_t
	
	
	  Truncate an address depending on the segment.
	  
	  
	  @param s (C++: const  segment_t  *)
	  @param ea (C++: ea_t)
	  

class ida_segment.segment_t():
	
	    Proxy of C++ segment_t class
	    

ida_segment.segment_t._print():
	
	        _print(self) -> size_t
	        

ida_segment.segment_t.abits():
	
	        abits(self) -> int
	        

ida_segment.segment_t.abytes():
	
	        abytes(self) -> int
	        

ida_segment.segment_t.align:
	segment_t_align_get(self) -> uchar

ida_segment.segment_t.bitness:
	segment_t_bitness_get(self) -> uchar

ida_segment.segment_t.clear():
	
	        clear(self)
	        

ida_segment.segment_t.clr_comorg():
	
	        clr_comorg(self)
	        

ida_segment.segment_t.clr_ob_ok():
	
	        clr_ob_ok(self)
	        

ida_segment.segment_t.color:
	segment_t_color_get(self) -> bgcolor_t

ida_segment.segment_t.comb:
	segment_t_comb_get(self) -> uchar

ida_segment.segment_t.comorg():
	
	        comorg(self) -> bool
	        

ida_segment.segment_t.compare():
	
	        compare(self, r) -> int
	        

ida_segment.segment_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_segment.segment_t.defsr:
	segment_t_defsr_get(self) -> sel_t [16]

ida_segment.segment_t.empty():
	
	        empty(self) -> bool
	        

ida_segment.segment_t.end_ea:
	segment_t_end_ea_get(self) -> ea_t

ida_segment.segment_t.extend():
	
	        extend(self, ea)
	        

ida_segment.segment_t.flags:
	segment_t_flags_get(self) -> ushort

ida_segment.segment_t.intersect():
	
	        intersect(self, r)
	        

ida_segment.segment_t.is_header_segm():
	
	        is_header_segm(self) -> bool
	        

ida_segment.segment_t.is_hidden_segtype():
	
	        is_hidden_segtype(self) -> bool
	        

ida_segment.segment_t.is_loader_segm():
	
	        is_loader_segm(self) -> bool
	        

ida_segment.segment_t.is_visible_segm():
	
	        is_visible_segm(self) -> bool
	        

ida_segment.segment_t.name:
	segment_t_name_get(self) -> uval_t

ida_segment.segment_t.ob_ok():
	
	        ob_ok(self) -> bool
	        

ida_segment.segment_t.orgbase:
	segment_t_orgbase_get(self) -> uval_t

ida_segment.segment_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_segment.segment_t.perm:
	segment_t_perm_get(self) -> uchar

ida_segment.segment_t.sclass:
	segment_t_sclass_get(self) -> uval_t

ida_segment.segment_t.sel:
	segment_t_sel_get(self) -> sel_t

ida_segment.segment_t.set_comorg():
	
	        set_comorg(self)
	        

ida_segment.segment_t.set_debugger_segm():
	
	        set_debugger_segm(self, debseg)
	        

ida_segment.segment_t.set_header_segm():
	
	        set_header_segm(self, on)
	        

ida_segment.segment_t.set_hidden_segtype():
	
	        set_hidden_segtype(self, hide)
	        

ida_segment.segment_t.set_loader_segm():
	
	        set_loader_segm(self, ldrseg)
	        

ida_segment.segment_t.set_ob_ok():
	
	        set_ob_ok(self)
	        

ida_segment.segment_t.set_visible_segm():
	
	        set_visible_segm(self, visible)
	        

ida_segment.segment_t.size():
	
	        size(self) -> asize_t
	        

ida_segment.segment_t.start_ea:
	segment_t_start_ea_get(self) -> ea_t

ida_segment.segment_t.type:
	segment_t_type_get(self) -> uchar

ida_segment.segment_t.update():
	
	        update(self) -> bool
	        

ida_segment.segment_t.use32():
	
	        use32(self) -> bool
	        

ida_segment.segment_t.use64():
	
	        use64(self) -> bool
	        

ida_segment.segtype():
	
	  segtype(ea) -> uchar
	
	
	  Get segment type.
	  
	  @param ea: any linear address within the segment (C++: ea_t)
	  @return: Segment types ,  SEG_UNDF  if no segment found at 'ea'
	  

ida_segment.sel2ea():
	
	  sel2ea(selector) -> ea_t
	
	
	  Get mapping of a selector as a linear address.
	  
	  @param selector: number of selector to translate to linear address
	                   (C++: sel_t)
	  @return: linear address the specified selector is mapped to. if there
	           is no mapping, returns to_ea(selector,0);
	  

ida_segment.sel2para():
	
	  sel2para(selector) -> ea_t
	
	
	  Get mapping of a selector.
	  
	  @param selector: number of selector to translate (C++: sel_t)
	  @return: paragraph the specified selector is mapped to. if there is no
	           mapping, returns 'selector'.
	  

ida_segment.set_defsr():
	
	  set_defsr(s, reg, value)
	  

ida_segment.set_group_selector():
	
	  set_group_selector(grp, sel) -> int
	
	
	  Initialize groups. The kernel calls this function at the start of
	  work.Create a new group of segments (used OMF files).
	  
	  @param grp: selector of group segment (segment type is  SEG_GRP ) You
	              should create an 'empty' (1 byte) group segment It won't
	              contain anything and will be used to redirect references
	              to the group of segments to the common selector. (C++:
	              sel_t)
	  @param sel: common selector of all segments belonging to the segment
	              You should create all segments within the group with the
	              same selector value. (C++: sel_t)
	  @return: 1 ok
	  

ida_segment.set_segm_addressing():
	
	  set_segm_addressing(s, bitness) -> bool
	
	
	  Change segment addressing mode (16, 32, 64 bits). You must use this
	  function to change segment addressing, never change the 'bitness'
	  field directly. This function will delete all instructions, comments
	  and names in the segment
	  
	  @param s: pointer to segment (C++: segment_t  *)
	  @param bitness: new addressing mode of segment   2: 64bit segment 1:
	                  32bit segment 0: 16bit segment (C++: size_t)
	  @return: success
	  

ida_segment.set_segm_base():
	
	  set_segm_base(s, newbase) -> bool
	
	
	  Internal function.
	  
	  
	  @param s (C++: segment_t  *)
	  @param newbase (C++: ea_t)
	  

ida_segment.set_segm_class():
	
	  set_segm_class(s, sclass, flags=0) -> int
	
	
	  Set segment class.
	  
	  @param s: pointer to segment (may be NULL) (C++: segment_t  *)
	  @param sclass: segment class (may be NULL). If segment type is
	                 SEG_NORM  and segment class is one of predefined names,
	                 then segment type is changed to:   "CODE" ->  SEG_CODE
	                 "DATA" ->  SEG_DATA "STACK" ->  SEG_BSS "BSS" ->
	                 SEG_BSS if "UNK" then segment type is reset to
	                 SEG_NORM . (C++: const char *)
	  @param flags (C++: int)
	  

ida_segment.set_segm_end():
	
	  set_segm_end(ea, newend, flags) -> bool
	
	
	  Set segment end address. The next segment is shrinked to allow
	  expansion of the specified segment. The kernel might even delete the
	  next segment if necessary. The kernel will ask the user for a
	  permission to destroy instructions or data going out of segment scope
	  if such instructions exist.
	  
	  @param ea: any address belonging to the segment (C++: ea_t)
	  @param newend: new end address of the segment (C++: ea_t)
	  @param flags: Segment modification flags (C++: int)
	  

ida_segment.set_segm_name():
	
	  set_segm_name(s, name, flags=0) -> int
	
	
	  Rename segment. The new name is validated (see validate_name). A
	  segment always has a name. If you hadn't specified a name, the kernel
	  will assign it "seg###" name where ### is segment number.
	  
	  @param s: pointer to segment (may be NULL) (C++: segment_t  *)
	  @param name: new segment name (C++: const char *)
	  @param flags: ADDSEG_IDBENC or 0 (C++: int)
	  

ida_segment.set_segm_start():
	
	  set_segm_start(ea, newstart, flags) -> bool
	
	
	  Set segment start address. The previous segment is trimmed to allow
	  expansion of the specified segment. The kernel might even delete the
	  previous segment if necessary. The kernel will ask the user for a
	  permission to destroy instructions or data going out of segment scope
	  if such instructions exist.
	  
	  @param ea: any address belonging to the segment (C++: ea_t)
	  @param newstart: new start address of the segment note that segment
	                   start address should be higher than segment base
	                   linear address. (C++: ea_t)
	  @param flags: Segment modification flags (C++: int)
	  

ida_segment.set_segment_cmt():
	
	  set_segment_cmt(s, cmt, repeatable)
	
	
	  Set segment comment.
	  
	  @param s: pointer to segment structure (C++: const  segment_t  *)
	  @param cmt: comment string, may be multiline (with '  '). maximal size
	              is 4096 bytes. Use empty str ("") to delete comment (C++:
	              const char *)
	  @param repeatable: 0: set regular comment. 1: set repeatable comment.
	                     (C++: bool)
	  

ida_segment.set_segment_translations():
	
	  set_segment_translations(segstart, transmap) -> bool
	
	
	  Set new translation list.
	  
	  @param segstart: start address of the segment to add translation to
	                   (C++: ea_t)
	  @param transmap: vector of segment start addresses for the translation
	                   list. If transmap is empty, the translation list is
	                   deleted. (C++: const  eavec_t  &)
	  

ida_segment.set_selector():
	
	  set_selector(selector, paragraph) -> int
	
	
	  Set mapping of selector to a paragraph. You should call this
	  functionbeforecreating a segment which uses the selector, otherwise
	  the creation of the segment will fail.
	  
	  @param selector: number of selector to map   if selector ==  BADSEL ,
	                   then return 0 (fail) if the selector has had a
	                   mapping, old mapping is destroyed if the selector
	                   number is equal to paragraph value, then the mapping
	                   is destroyed because we don't need to keep trivial
	                   mappings. (C++: sel_t)
	  @param paragraph: paragraph to map selector (C++: ea_t)
	  

ida_segment.set_visible_segm():
	
	  set_visible_segm(s, visible)
	
	
	  See 'SFL_HIDDEN' .
	  
	  
	  @param s (C++: segment_t  *)
	  @param visible (C++: bool)
	  

ida_segment.setup_selector():
	
	  setup_selector(segbase) -> sel_t
	
	
	  Allocate a selector for a segment if necessary. You must call this
	  function before calling 'add_segm_ex()' . 'add_segm()' calls this
	  function itself, so you don't need to allocate a selector. This
	  function will allocate a selector if 'segbase' requires more than 16
	  bits and the current processor is IBM PC. Otherwise it will return the
	  segbase value.
	  
	  @param segbase: a new segment base paragraph (C++: ea_t)
	  @return: the allocated selector number
	  

ida_segment.std_out_segm_footer():
	
	  std_out_segm_footer(ctx, seg)
	
	
	  Generate segment footer line as a comment line. This function may be
	  used in IDP modules to generate segment footer if the target assembler
	  doesn't have 'ends' directive.
	  
	  @param ctx (C++: struct  outctx_t  &)
	  @param seg (C++: segment_t  *)
	  

ida_segment.take_memory_snapshot():
	
	  take_memory_snapshot(only_loader_segs) -> bool
	
	
	  Take a memory snapshot of the running process.
	  
	  @param only_loader_segs: only is_loader_segm() segments will be
	                           affected (C++: bool)
	  @return: success
	  

ida_segment.update_segm():
	
	  update_segm(s) -> bool
	  


=== ida_segment EPYDOC INJECTIONS ===
ida_segment.ADDSEG_FILLGAP
"""
fill gap between new segment and previous one. i.e. if such a gap
exists, and this gap is less than 64K, then fill the gap by extending
the previous segment and adding .align directive to it. This way we
avoid gaps between segments. too many gaps lead to a virtual array
failure. it can not hold more than ~1000 gaps.
"""

ida_segment.ADDSEG_IDBENC
"""
non-ASCII bytes will be decoded accordingly

'name' and 'sclass' are given in the IDB encoding;
"""

ida_segment.ADDSEG_NOAA
"""
do not mark new segment for auto-analysis
"""

ida_segment.ADDSEG_NOSREG
"""
(undefine all default segment registers)

set all default segment register values to 'BADSEL'
"""

ida_segment.ADDSEG_NOTRUNC
"""
destroy/truncate old segments instead.

don't truncate the new segment at the beginning of the next segment if
they overlap.
"""

ida_segment.ADDSEG_OR_DIE
"""
 'qexit()' if can't add a segment
"""

ida_segment.ADDSEG_QUIET
"""
silent mode, no "Adding segment..." in the messages window
"""

ida_segment.ADDSEG_SPARSE
"""
use sparse storage method for the new segment
"""

ida_segment.CSS_BREAK
"""
memory reading process stopped by user
"""

ida_segment.CSS_NODBG
"""
debugger is not running
"""

ida_segment.CSS_NOMEM
"""
is too big)

not enough memory (might be because the segment
"""

ida_segment.CSS_NORANGE
"""
could not find corresponding memory range
"""

ida_segment.CSS_OK
"""
ok
"""

ida_segment.MAX_GROUPS
"""
max number of segment groups
"""

ida_segment.MAX_SEGM_TRANSLATIONS
"""
max number of segment translations
"""

ida_segment.MFS_NETMAP
"""
valid for 'rebase_program()'

change inf.netdelta if possible (this is faster)
"""

ida_segment.MOVE_SEGM_CHUNK
"""
Too many chunks are defined, can't move.
"""

ida_segment.MOVE_SEGM_IDP
"""
IDP module forbids moving the segment.
"""

ida_segment.MOVE_SEGM_LOADER
"""
The segment has been moved but the loader complained.
"""

ida_segment.MOVE_SEGM_ODD
"""
Can not move segments by an odd number of bytes.
"""

ida_segment.MOVE_SEGM_OK
"""
all ok
"""

ida_segment.MOVE_SEGM_ORPHAN
"""
Orphan bytes hinder segment movement.
"""

ida_segment.MOVE_SEGM_PARAM
"""
The specified segment does not exist.
"""

ida_segment.MOVE_SEGM_ROOM
"""
Not enough free room at the target address.
"""

ida_segment.MSF_FIXONCE
"""
valid for 'rebase_program()' . see 'loader_t::move_segm' .

call loader only once with the special calling method.
"""

ida_segment.MSF_LDKEEP
"""
keep the loader in the memory (optimization)
"""

ida_segment.MSF_NOFIX
"""
don't call the loader to fix relocations
"""

ida_segment.MSF_PRIORITY
"""
valid for 'move_segm()'

loader segments will overwrite any existing debugger segments when
moved.
"""

ida_segment.MSF_SILENT
"""
don't display a "please wait" box on the screen
"""

ida_segment.SEGMOD_KEEP
"""
keep information (code & data, etc)
"""

ida_segment.SEGMOD_KEEP0
"""
flag for internal use, don't set
"""

ida_segment.SEGMOD_KEEPSEL
"""
do not try to delete unused selector
"""

ida_segment.SEGMOD_KILL
"""
disable addresses if segment gets shrinked or deleted
"""

ida_segment.SEGMOD_NOMOVE
"""
(for 'set_segm_start()' )

don't move info from the start of segment to the new start address
"""

ida_segment.SEGMOD_SILENT
"""
be silent
"""

ida_segment.SEGMOD_SPARSE
"""
(for 'set_segm_start()' , 'set_segm_end()' )

use sparse storage if extending the segment
"""

ida_segment.SEGPERM_EXEC
"""
Execute.
"""

ida_segment.SEGPERM_READ
"""
Read.
"""

ida_segment.SEGPERM_WRITE
"""
Write.
"""

ida_segment.SEG_ABSSYM
"""
segment with definitions of absolute symbols
"""

ida_segment.SEG_BSS
"""
uninitialized segment
"""

ida_segment.SEG_CODE
"""
code segment
"""

ida_segment.SEG_COMM
"""
segment with communal definitions
"""

ida_segment.SEG_DATA
"""
data segment
"""

ida_segment.SEG_GRP
"""
group of segments
"""

ida_segment.SEG_IMEM
"""
internal processor memory & sfr (8051)
"""

ida_segment.SEG_IMP
"""
java: implementation segment
"""

ida_segment.SEG_NORM
"""
unknown type, no assumptions
"""

ida_segment.SEG_NULL
"""
zero-length segment
"""

ida_segment.SEG_UNDF
"""
undefined segment type (not used)
"""

ida_segment.SEG_XTRN
"""
no instructions are allowed

segment with 'extern' definitions.
"""

ida_segment.SFL_COMORG
"""
IDP dependent field (IBM PC: if set, ORG directive is not commented
out)
"""

ida_segment.SFL_DEBUG
"""
Is the segment created for the debugger?. Such segments are temporary
and do not have permanent flags.
"""

ida_segment.SFL_HEADER
"""
Header segment (do not create offsets to it in the disassembly)
"""

ida_segment.SFL_HIDDEN
"""
Is the segment hidden?
"""

ida_segment.SFL_HIDETYPE
"""
Hide segment type (do not print it in the listing)
"""

ida_segment.SFL_LOADER
"""
Is the segment created by the loader?
"""

ida_segment.SFL_OBOK
"""
Orgbase is present? (IDP dependent field)
"""

ida_segment.SREG_NUM
"""
Maximum number of segment registers is 16 (see 'segregs.hpp' )
"""

ida_segment.saAbs
"""
Absolute segment.
"""

ida_segment.saGroup
"""
Segment group.
"""

ida_segment.saRel1024Bytes
"""
1024 bytes
"""

ida_segment.saRel128Bytes
"""
128 bytes
"""

ida_segment.saRel2048Bytes
"""
2048 bytes
"""

ida_segment.saRel32Bytes
"""
32 bytes
"""

ida_segment.saRel4K
"""
alignment. It is not supported by LINK.

This value is used by the PharLap OMF for page (4K)
"""

ida_segment.saRel512Bytes
"""
512 bytes
"""

ida_segment.saRel64Bytes
"""
64 bytes
"""

ida_segment.saRelByte
"""
Relocatable, byte aligned.
"""

ida_segment.saRelDble
"""
boundary.

Relocatable, aligned on a double word (4-byte)
"""

ida_segment.saRelPage
"""
Relocatable, aligned on 256-byte boundary.
"""

ida_segment.saRelPara
"""
Relocatable, paragraph (16-byte) aligned.
"""

ida_segment.saRelQword
"""
8 bytes
"""

ida_segment.saRelWord
"""
Relocatable, word (2-byte) aligned.
"""

ida_segment.scCommon
"""
Common. Combine by overlay using maximum size.
"""

ida_segment.scGroup
"""
Segment group.
"""

ida_segment.scPriv
"""
segment.

Private. Do not combine with any other program
"""

ida_segment.scPub
"""
the alignment requirement.

Public. Combine by appending at an offset that meets
"""

ida_segment.scPub2
"""
As defined by Microsoft, same as C=2 (public).
"""

ida_segment.scPub3
"""
As defined by Microsoft, same as C=2 (public).
"""

ida_segment.scStack
"""
byte alignment.

Stack. Combine as for C=2. This combine type forces
"""
=== ida_segment EPYDOC INJECTIONS END ===
ida_segregs.copy_sreg_ranges():
	
	  copy_sreg_ranges(dst_rg, src_rg, map_selector=False)
	
	
	  Duplicate segment register ranges.
	  
	  @param dst_rg: number of destination segment register (C++: int)
	  @param src_rg: copy ranges from (C++: int)
	  @param map_selector: map selectors to linear addresses using  sel2ea()
	                       (C++: bool)
	  

ida_segregs.del_sreg_range():
	
	  del_sreg_range(ea, rg) -> bool
	
	
	  Delete segment register range started at ea. When a segment register
	  range is deleted, the previous range is extended to cover the empty
	  space. The segment register range at the beginning of a segment can
	  not be deleted.
	  
	  @param ea: start_ea of the deleted range (C++: ea_t)
	  @param rg: the segment register number (C++: int)
	  @return: success
	  

ida_segregs.get_prev_sreg_range():
	
	  get_prev_sreg_range(out, ea, rg) -> bool
	
	
	  Get segment register range previous to one with address.more efficient
	  then get_sreg_range(reg, ea-1)
	  
	  @param out: segment register range (C++: sreg_range_t  *)
	  @param ea: any linear address in the program (C++: ea_t)
	  @param rg: the segment register number (C++: int)
	  @return: success
	  

ida_segregs.get_sreg():
	
	  get_sreg(ea, rg) -> sel_t
	
	
	  Get value of a segment register. This function uses segment register
	  range and default segment register values stored in the segment
	  structure.
	  
	  @param ea: linear address in the program (C++: ea_t)
	  @param rg: number of the segment register (C++: int)
	  @return: value of the segment register,  BADSEL  if value is unknown.
	  

ida_segregs.get_sreg_range():
	
	  get_sreg_range(out, ea, rg) -> bool
	
	
	  Get segment register range by linear address.
	  
	  @param out: segment register range (C++: sreg_range_t  *)
	  @param ea: any linear address in the program (C++: ea_t)
	  @param rg: the segment register number (C++: int)
	  @return: success
	  

ida_segregs.get_sreg_range_num():
	
	  get_sreg_range_num(ea, rg) -> int
	
	
	  Get number of segment register range by address.
	  
	  @param ea: any address in the range (C++: ea_t)
	  @param rg: the segment register number (C++: int)
	  @return: -1 if no range occupies the specified address. otherwise
	           returns number of the specified range
	           (0..get_srranges_qty()-1)
	  

ida_segregs.get_sreg_ranges_qty():
	
	  get_sreg_ranges_qty(rg) -> size_t
	
	
	  Get number of segment register ranges.
	  
	  @param rg: the segment register number (C++: int)
	  

ida_segregs.getn_sreg_range():
	
	  getn_sreg_range(out, rg, n) -> bool
	
	
	  Get segment register range by its number.
	  
	  @param out: segment register range (C++: sreg_range_t  *)
	  @param rg: the segment register number (C++: int)
	  @param n: number of range (0..qty()-1) (C++: int)
	  @return: success
	  

ida_segregs.set_default_dataseg():
	
	  set_default_dataseg(ds_sel)
	
	
	  Set default value of DS register for all segments.
	  
	  
	  @param ds_sel (C++: sel_t)
	  

ida_segregs.set_default_sreg_value():
	
	  set_default_sreg_value(sg, rg, value) -> bool
	
	
	  Set default value of a segment register for a segment.
	  
	  @param sg: pointer to segment structure if NULL, then set the register
	             for all segments (C++: segment_t  *)
	  @param rg: number of segment register (C++: int)
	  @param value: its default value. this value will be used by
	                get_sreg()  if value of the register is unknown at the
	                specified address. (C++: sel_t)
	  @return: success
	  

ida_segregs.set_sreg_at_next_code():
	
	  set_sreg_at_next_code(ea1, ea2, rg, value)
	
	
	  Set the segment register value at the next instruction. This function
	  is designed to be called from 'idb_event::sgr_changed' handler in
	  order to contain the effect of changing a segment register value only
	  until the next instruction.It is useful, for example, in the ARM
	  module: the modification of the T register does not affect existing
	  instructions later in the code.
	  
	  @param ea1: address to start to search for an instruction (C++: ea_t)
	  @param ea2: the maximal address (C++: ea_t)
	  @param rg: the segment register number (C++: int)
	  @param value: the segment register value (C++: sel_t)
	  

ida_segregs.split_sreg_range():
	
	  split_sreg_range(ea, rg, v, tag, silent=False) -> bool
	
	
	  Create a new segment register range. This function is used when the
	  IDP emulator detects that a segment register changes its value.
	  
	  @param ea: linear address where the segment register will have a new
	             value. if ea== BADADDR , nothing to do. (C++: ea_t)
	  @param rg: the number of the segment register (C++: int)
	  @param v: the new value of the segment register. If the value is
	            unknown, you should specify  BADSEL . (C++: sel_t)
	  @param tag: the register info tag. see  Segment register range tags
	              (C++: uchar)
	  @param silent: if false, display a warning() in the case of failure
	                 (C++: bool)
	  @return: success
	  

class ida_segregs.sreg_range_t():
	
	    Proxy of C++ sreg_range_t class
	    

ida_segregs.sreg_range_t._print():
	
	        _print(self) -> size_t
	        

ida_segregs.sreg_range_t.clear():
	
	        clear(self)
	        

ida_segregs.sreg_range_t.compare():
	
	        compare(self, r) -> int
	        

ida_segregs.sreg_range_t.contains():
	
	        contains(self, ea) -> bool
	        contains(self, r) -> bool
	        

ida_segregs.sreg_range_t.empty():
	
	        empty(self) -> bool
	        

ida_segregs.sreg_range_t.end_ea:
	range_t_end_ea_get(self) -> ea_t

ida_segregs.sreg_range_t.extend():
	
	        extend(self, ea)
	        

ida_segregs.sreg_range_t.intersect():
	
	        intersect(self, r)
	        

ida_segregs.sreg_range_t.overlaps():
	
	        overlaps(self, r) -> bool
	        

ida_segregs.sreg_range_t.size():
	
	        size(self) -> asize_t
	        

ida_segregs.sreg_range_t.start_ea:
	range_t_start_ea_get(self) -> ea_t

ida_segregs.sreg_range_t.tag:
	sreg_range_t_tag_get(self) -> uchar

ida_segregs.sreg_range_t.val:
	sreg_range_t_val_get(self) -> sel_t


=== ida_segregs EPYDOC INJECTIONS ===
ida_segregs.SR_auto
"""
the value is determined by IDA
"""

ida_segregs.SR_autostart
"""
used as 'SR_auto' for segment starting address
"""

ida_segregs.SR_inherit
"""
the value is inherited from the previous range
"""

ida_segregs.SR_user
"""
the value is specified by the user
"""
=== ida_segregs EPYDOC INJECTIONS END ===
ida_strlist.build_strlist():
	
	  build_strlist()
	
	
	  Build the string list. You should initialize options before this call
	  using the restore_config() or setup_strings_window() methods.
	  

ida_strlist.clear_strlist():
	
	  clear_strlist()
	
	
	  Clear the string list.
	  

ida_strlist.get_strlist_item():
	
	  get_strlist_item(si, n) -> bool
	
	
	  Get nth element of the string list (n=0.. 'get_strlist_qty()' -1)
	  
	  
	  @param si (C++: string_info_t  *)
	  @param n (C++: size_t)
	  

ida_strlist.get_strlist_options():
	
	  get_strlist_options() -> strwinsetup_t
	
	
	  Get access to the static string list options.
	  

ida_strlist.get_strlist_qty():
	
	  get_strlist_qty() -> size_t
	
	
	  Get number of elements in the string list.
	  

class ida_strlist.string_info_t():
	
	    Proxy of C++ string_info_t class
	    

ida_strlist.string_info_t.ea:
	string_info_t_ea_get(self) -> ea_t

ida_strlist.string_info_t.length:
	string_info_t_length_get(self) -> int

ida_strlist.string_info_t.type:
	string_info_t_type_get(self) -> int

class ida_strlist.strwinsetup_t():
	
	    Proxy of C++ strwinsetup_t class
	    

ida_strlist.strwinsetup_t.display_only_existing_strings:
	strwinsetup_t_display_only_existing_strings_get(self) -> uchar

ida_strlist.strwinsetup_t.ignore_heads:
	strwinsetup_t_ignore_heads_get(self) -> uchar

ida_strlist.strwinsetup_t.is_initialized():
	
	        is_initialized(self) -> bool
	        

ida_strlist.strwinsetup_t.minlen:
	strwinsetup_t_minlen_get(self) -> sval_t

ida_strlist.strwinsetup_t.only_7bit:
	strwinsetup_t_only_7bit_get(self) -> uchar

ida_strlist.strwinsetup_t.strtypes:
	
	        _get_strtypes(self) -> PyObject *
	        

ida_struct.add_struc():
	
	  add_struc(idx, name, is_union=False) -> tid_t
	
	
	  Create a structure type. if idx== 'BADADDR' then add as the last idx.
	  if name==NULL then a name will be generated "struct_%d".
	  
	  @param idx (C++: uval_t)
	  @param name (C++: const char *)
	  @param is_union (C++: bool)
	  

ida_struct.add_struc_member():
	
	  add_struc_member(sptr, fieldname, offset, flag, mt, nbytes) -> struc_error_t
	
	
	  Add member to existing structure.
	  
	  @param sptr: structure to modify (C++: struc_t  *)
	  @param fieldname: if NULL, then "anonymous_#" name will be generated
	                    (C++: const char *)
	  @param offset: BADADDR  means add to the end of structure (C++: ea_t)
	  @param flag: type + representation bits (C++: flags_t)
	  @param mt: additional info about member type. must be present for
	             structs, offsets, enums, strings, struct offsets. (C++:
	             const  opinfo_t  *)
	  @param nbytes: if == 0 then the structure will be a varstruct. in this
	                 case the member should be the last member in the
	                 structure (C++: asize_t)
	  

ida_struct.del_member_tinfo():
	
	  del_member_tinfo(sptr, mptr) -> bool
	
	
	  Delete tinfo for given member.
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param mptr (C++: member_t  *)
	  

ida_struct.del_struc():
	
	  del_struc(sptr) -> bool
	
	
	  Delete a structure type.
	  
	  
	  @param sptr (C++: struc_t  *)
	  

ida_struct.del_struc_member():
	
	  del_struc_member(sptr, offset) -> bool
	
	
	  Delete member at given offset.
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param offset (C++: ea_t)
	  

ida_struct.del_struc_members():
	
	  del_struc_members(sptr, off1, off2) -> int
	
	
	  Delete members which occupy range of offsets (off1..off2).
	  
	  @param sptr (C++: struc_t  *)
	  @param off1 (C++: ea_t)
	  @param off2 (C++: ea_t)
	  @return: number of deleted members or -1 on error
	  

ida_struct.expand_struc():
	
	  expand_struc(sptr, offset, delta, recalc=True) -> bool
	
	
	  Expand/Shrink structure type.
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param offset (C++: ea_t)
	  @param delta (C++: adiff_t)
	  @param recalc (C++: bool)
	  

ida_struct.get_best_fit_member():
	
	  get_best_fit_member(sptr, offset) -> member_t
	
	
	  Get member that is most likely referenced by the specified offset.
	  Useful for offsets > sizeof(struct).
	  
	  @param sptr (C++: const  struc_t  *)
	  @param offset (C++: asize_t)
	  

ida_struct.get_first_struc_idx():
	
	  get_first_struc_idx() -> uval_t
	
	
	  Get index of first structure.
	  
	  @return: BADADDR  if no known structures, 0 otherwise
	  

ida_struct.get_last_struc_idx():
	
	  get_last_struc_idx() -> uval_t
	
	
	  Get index of last structure.
	  
	  @return: BADADDR  if no known structures,  get_struc_qty() -1
	           otherwise
	  

ida_struct.get_max_offset():
	
	  get_max_offset(sptr) -> ea_t
	
	
	  For unions: returns number of members, for structs: returns size of
	  structure.
	  
	  
	  @param sptr (C++: struc_t  *)
	  

ida_struct.get_member():
	
	  get_member(sptr, offset) -> member_t
	
	
	  Get member at given offset.
	  
	  
	  @param sptr (C++: const  struc_t  *)
	  @param offset (C++: asize_t)
	  

ida_struct.get_member_by_fullname():
	
	  get_member_by_fullname(fullname) -> member_t
	
	
	  Get a member by its fully qualified name, "struct.field".
	  
	  
	  @param fullname (C++: const char *)
	  

ida_struct.get_member_by_id():
	
	  get_member_by_id(mid) -> member_t
	
	
	  Check if the specified member id points to a struct member.
	  
	  
	  @param mid (C++: tid_t)
	  

ida_struct.get_member_by_name():
	
	  get_member_by_name(sptr, membername) -> member_t
	
	
	  Get a member by its name, like "field44".
	  
	  
	  @param sptr (C++: const  struc_t  *)
	  @param membername (C++: const char *)
	  

ida_struct.get_member_cmt():
	
	  get_member_cmt(mid, repeatable) -> ssize_t
	
	
	  Get comment of structure member.
	  
	  
	  @param mid (C++: tid_t)
	  @param repeatable (C++: bool)
	  

ida_struct.get_member_fullname():
	
	  get_member_fullname(mid) -> ssize_t
	
	
	  Get a member's fully qualified name, "struct.field".
	  
	  
	  @param mid (C++: tid_t)
	  

ida_struct.get_member_name():
	
	  get_member_name(mid) -> ssize_t
	
	
	  Get name of structure member.
	  
	  
	  @param mid (C++: tid_t)
	  

ida_struct.get_member_size():
	
	  get_member_size(nonnul_mptr) -> asize_t
	
	
	  Get size of structure member. May return 0 for the last member of
	  varstruct. For union members, returns 'member_t::eoff' .
	  

ida_struct.get_member_struc():
	
	  get_member_struc(fullname) -> struc_t
	
	
	  Get containing structure of member by its full name "struct.field".
	  
	  
	  @param fullname (C++: const char *)
	  

ida_struct.get_member_tinfo():
	
	  get_member_tinfo(tif, mptr) -> bool
	
	
	  Get tinfo for given member.
	  
	  
	  @param tif (C++: tinfo_t  *)
	  @param mptr (C++: const  member_t  *)
	  

ida_struct.get_next_member_idx():
	
	  get_next_member_idx(sptr, off) -> ssize_t
	
	
	  Get the next member idx, if it does not exist, return -1.
	  
	  
	  @param sptr (C++: const  struc_t  *)
	  @param off (C++: asize_t)
	  

ida_struct.get_next_struc_idx():
	
	  get_next_struc_idx(idx) -> uval_t
	
	
	  Get next struct index.
	  
	  @param idx (C++: uval_t)
	  @return: BADADDR  if resulting index is out of bounds, otherwise idx++
	  

ida_struct.get_or_guess_member_tinfo():
	
	  get_or_guess_member_tinfo(tif, mptr) -> bool
	
	
	  Try to get tinfo for given member - if failed, generate a tinfo using
	  information about the member id from the disassembly
	  
	  @param tif (C++: tinfo_t  *)
	  @param mptr (C++: const  member_t  *)
	  

ida_struct.get_prev_member_idx():
	
	  get_prev_member_idx(sptr, off) -> ssize_t
	
	
	  Get the prev member idx, if it does not exist, return -1.
	  
	  
	  @param sptr (C++: const  struc_t  *)
	  @param off (C++: asize_t)
	  

ida_struct.get_prev_struc_idx():
	
	  get_prev_struc_idx(idx) -> uval_t
	
	
	  Get previous struct index.
	  
	  @param idx (C++: uval_t)
	  @return: BADADDR  if resulting index is negative, otherwise idx - 1
	  

ida_struct.get_sptr():
	
	  get_sptr(mptr) -> struc_t
	
	
	  Get child struct if member is a struct.
	  
	  
	  @param mptr (C++: const  member_t  *)
	  

ida_struct.get_struc():
	
	  get_struc(id) -> struc_t
	
	
	  Get pointer to struct type info.
	  
	  
	  @param id (C++: tid_t)
	  

ida_struct.get_struc_by_idx():
	
	  get_struc_by_idx(idx) -> tid_t
	
	
	  Get struct id by struct number.
	  
	  
	  @param idx (C++: uval_t)
	  

ida_struct.get_struc_cmt():
	
	  get_struc_cmt(id, repeatable) -> ssize_t
	
	
	  Get struct comment.
	  
	  
	  @param id (C++: tid_t)
	  @param repeatable (C++: bool)
	  

ida_struct.get_struc_first_offset():
	
	  get_struc_first_offset(sptr) -> ea_t
	
	
	  Get offset of first member.
	  
	  @param sptr (C++: const  struc_t  *)
	  @return: BADADDR  if memqty == 0
	  

ida_struct.get_struc_id():
	
	  get_struc_id(name) -> tid_t
	
	
	  Get struct id by name.
	  
	  
	  @param name (C++: const char *)
	  

ida_struct.get_struc_idx():
	
	  get_struc_idx(id) -> uval_t
	
	
	  Get internal number of the structure.
	  
	  
	  @param id (C++: tid_t)
	  

ida_struct.get_struc_last_offset():
	
	  get_struc_last_offset(sptr) -> ea_t
	
	
	  Get offset of last member.
	  
	  @param sptr (C++: const  struc_t  *)
	  @return: BADADDR  if memqty == 0
	  

ida_struct.get_struc_name():
	
	  get_struc_name(id) -> ssize_t
	
	
	  Get struct name by id.
	  
	  
	  @param id (C++: tid_t)
	  

ida_struct.get_struc_next_offset():
	
	  get_struc_next_offset(sptr, offset) -> ea_t
	
	
	  Get offset of member with smallest offset larger than 'offset'.
	  
	  @param sptr (C++: const  struc_t  *)
	  @param offset (C++: ea_t)
	  @return: BADADDR  if no next offset
	  

ida_struct.get_struc_prev_offset():
	
	  get_struc_prev_offset(sptr, offset) -> ea_t
	
	
	  Get offset of member with largest offset less than 'offset'.
	  
	  @param sptr (C++: const  struc_t  *)
	  @param offset (C++: ea_t)
	  @return: BADADDR  if no prev offset
	  

ida_struct.get_struc_qty():
	
	  get_struc_qty() -> size_t
	
	
	  Get number of known structures.
	  

ida_struct.get_struc_size():
	
	    get_struc_size(sptr) -> asize_t
	    get_struc_size(id) -> asize_t
	
	
	  Get struct size (also see 'get_struc_size(tid_t)' )
	  
	  
	  @param sptr (C++: const  struc_t  *)
	    

ida_struct.is_anonymous_member_name():
	
	  is_anonymous_member_name(name) -> bool
	
	
	  Is member name prefixed with "anonymous"?
	  
	  
	  @param name (C++: const char *)
	  

ida_struct.is_dummy_member_name():
	
	  is_dummy_member_name(name) -> bool
	
	
	  Is member name an auto-generated name?
	  
	  
	  @param name (C++: const char *)
	  

ida_struct.is_member_id():
	
	  is_member_id(mid) -> bool
	
	
	  Is a member id?
	  
	  
	  @param mid (C++: tid_t)
	  

ida_struct.is_special_member():
	
	  is_special_member(id) -> bool
	
	
	  Is a special member with the name beginning with ' '?
	  
	  
	  @param id (C++: tid_t)
	  

ida_struct.is_union():
	
	  is_union(id) -> bool
	
	
	  Is a union?
	  
	  
	  @param id (C++: tid_t)
	  

ida_struct.is_varmember():
	
	  is_varmember(mptr) -> bool
	
	
	  Is variable size member?
	  
	  
	  @param mptr (C++: const  member_t  *)
	  

ida_struct.is_varstr():
	
	  is_varstr(id) -> bool
	
	
	  Is variable size structure?
	  
	  
	  @param id (C++: tid_t)
	  

class ida_struct.member_t():
	
	    Proxy of C++ member_t class
	    

ida_struct.member_t.by_til():
	
	        by_til(self) -> bool
	        

ida_struct.member_t.eoff:
	member_t_eoff_get(self) -> ea_t

ida_struct.member_t.flag:
	member_t_flag_get(self) -> flags_t

ida_struct.member_t.get_soff():
	
	        get_soff(self) -> ea_t
	        

ida_struct.member_t.has_ti():
	
	        has_ti(self) -> bool
	        

ida_struct.member_t.has_union():
	
	        has_union(self) -> bool
	        

ida_struct.member_t.id:
	member_t_id_get(self) -> tid_t

ida_struct.member_t.is_baseclass():
	
	        is_baseclass(self) -> bool
	        

ida_struct.member_t.is_destructor():
	
	        is_destructor(self) -> bool
	        

ida_struct.member_t.is_dupname():
	
	        is_dupname(self) -> bool
	        

ida_struct.member_t.props:
	member_t_props_get(self) -> uint32

ida_struct.member_t.soff:
	member_t_soff_get(self) -> ea_t

ida_struct.member_t.unimem():
	
	        unimem(self) -> bool
	        

ida_struct.retrieve_member_info():
	
	  retrieve_member_info(buf, mptr) -> opinfo_t
	
	
	  Get operand type info for member.
	  
	  
	  @param buf (C++: opinfo_t  *)
	  @param mptr (C++: const  member_t  *)
	  

ida_struct.save_struc():
	
	  save_struc(sptr, may_update_ltypes=True)
	
	
	  Update struct information in the database (internal function)
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param may_update_ltypes (C++: bool)
	  

ida_struct.set_member_cmt():
	
	  set_member_cmt(mptr, cmt, repeatable) -> bool
	
	
	  Set member comment.
	  
	  
	  @param mptr (C++: member_t  *)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

ida_struct.set_member_name():
	
	  set_member_name(sptr, offset, name) -> bool
	
	
	  Set name of member at given offset.
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param offset (C++: ea_t)
	  @param name (C++: const char *)
	  

ida_struct.set_member_tinfo():
	
	  set_member_tinfo(sptr, mptr, memoff, tif, flags) -> smt_code_t
	
	
	  Set tinfo for given member.
	  
	  @param sptr: containing struct (C++: struc_t  *)
	  @param mptr: target member (C++: member_t  *)
	  @param memoff: offset within member (C++: uval_t)
	  @param tif: type info (C++: const  tinfo_t  &)
	  @param flags: Set member tinfo flags (C++: int)
	  

ida_struct.set_member_type():
	
	  set_member_type(sptr, offset, flag, mt, nbytes) -> bool
	
	
	  Set type of member at given offset (also see 'add_struc_member()' )
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param offset (C++: ea_t)
	  @param flag (C++: flags_t)
	  @param mt (C++: const  opinfo_t  *)
	  @param nbytes (C++: asize_t)
	  

ida_struct.set_struc_align():
	
	  set_struc_align(sptr, shift) -> bool
	
	
	  Set structure alignment ( 'SF_ALIGN' )
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param shift (C++: int)
	  

ida_struct.set_struc_cmt():
	
	  set_struc_cmt(id, cmt, repeatable) -> bool
	
	
	  Set structure comment.
	  
	  
	  @param id (C++: tid_t)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

ida_struct.set_struc_hidden():
	
	  set_struc_hidden(sptr, is_hidden)
	
	
	  Hide/unhide a struct type.
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param is_hidden (C++: bool)
	  

ida_struct.set_struc_idx():
	
	  set_struc_idx(sptr, idx) -> bool
	
	
	  Set internal number of struct. Also see 'get_struc_idx()' ,
	  'get_struc_by_idx()' .
	  
	  @param sptr (C++: const  struc_t  *)
	  @param idx (C++: uval_t)
	  

ida_struct.set_struc_listed():
	
	  set_struc_listed(sptr, is_listed)
	
	
	  Add/remove a struct type from the struct list.
	  
	  
	  @param sptr (C++: struc_t  *)
	  @param is_listed (C++: bool)
	  

ida_struct.set_struc_name():
	
	  set_struc_name(id, name) -> bool
	
	
	  Set structure name.
	  
	  
	  @param id (C++: tid_t)
	  @param name (C++: const char *)
	  

ida_struct.stroff_as_size():
	
	  stroff_as_size(plen, sptr, value) -> bool
	
	
	  Should display a structure offset expression as the structure size?
	  
	  
	  @param plen (C++: int)
	  @param sptr (C++: const  struc_t  *)
	  @param value (C++: asize_t)
	  

class ida_struct.struc_t():
	
	    Proxy of C++ struc_t class
	    

ida_struct.struc_t.age:
	struc_t_age_get(self) -> ushort

ida_struct.struc_t.from_til():
	
	        from_til(self) -> bool
	        

ida_struct.struc_t.get_alignment():
	
	        get_alignment(self) -> int
	        

ida_struct.struc_t.get_member():
	
	        get_member(self, index) -> member_t
	        

ida_struct.struc_t.has_union():
	
	        has_union(self) -> bool
	        

ida_struct.struc_t.id:
	struc_t_id_get(self) -> tid_t

ida_struct.struc_t.is_choosable():
	
	        is_choosable(self) -> bool
	        

ida_struct.struc_t.is_frame():
	
	        is_frame(self) -> bool
	        

ida_struct.struc_t.is_ghost():
	
	        is_ghost(self) -> bool
	        

ida_struct.struc_t.is_hidden():
	
	        is_hidden(self) -> bool
	        

ida_struct.struc_t.is_union():
	
	        is_union(self) -> bool
	        

ida_struct.struc_t.is_varstr():
	
	        is_varstr(self) -> bool
	        

ida_struct.struc_t.members:
	struc_t_members_get(self) -> member_t

ida_struct.struc_t.memqty:
	struc_t_memqty_get(self) -> uint32

ida_struct.struc_t.ordinal:
	struc_t_ordinal_get(self) -> int32

ida_struct.struc_t.props:
	struc_t_props_get(self) -> uint32

ida_struct.struc_t.set_alignment():
	
	        set_alignment(self, shift)
	        

ida_struct.struc_t.set_ghost():
	
	        set_ghost(self, _is_ghost)
	        

class ida_struct.struct_field_visitor_t():
	
	    Proxy of C++ struct_field_visitor_t class
	    

ida_struct.struct_field_visitor_t.visit_field():
	
	        visit_field(self, sptr, mptr) -> int
	        

ida_struct.visit_stroff_fields():
	
	  visit_stroff_fields(sfv, path, disp, appzero) -> flags_t
	
	
	  Visit structure fields in a stroff expression or in a reference to a
	  struct data variable. This function can be used to enumerate all
	  components of an expression like 'a.b.c'.
	  
	  @param sfv: visitor object (C++: struct_field_visitor_t  &)
	  @param path: struct path (path[0] contains the initial struct id)
	               (C++: const  tid_t  *)
	  @param disp: offset into structure (C++: adiff_t *)
	  @param appzero: should visit field at offset zero? (C++: bool)
	  


=== ida_struct EPYDOC INJECTIONS ===
ida_struct.MF_BASECLASS
"""
a special member representing base class
"""

ida_struct.MF_BYTIL
"""
the member was created due to the type system
"""

ida_struct.MF_DTOR
"""
a special member representing destructor
"""

ida_struct.MF_DUPNAME
"""
duplicate name resolved with _N suffix (N==soff)
"""

ida_struct.MF_HASTI
"""
has type information?
"""

ida_struct.MF_HASUNI
"""
has members of type "union"?
"""

ida_struct.MF_OK
"""
is the member ok? (always yes)
"""

ida_struct.MF_UNIMEM
"""
is a member of a union?
"""

ida_struct.SET_MEMTI_BYTIL
"""
new type was created by the type subsystem
"""

ida_struct.SET_MEMTI_COMPATIBLE
"""
new type must be compatible with the old
"""

ida_struct.SET_MEMTI_FUNCARG
"""
mptr is function argument (can not create arrays)
"""

ida_struct.SET_MEMTI_MAY_DESTROY
"""
may destroy other members
"""

ida_struct.SET_MEMTI_USERTI
"""
user-specified type
"""

ida_struct.SF_ALIGN
"""
alignment (shift amount: 0..31)
"""

ida_struct.SF_FRAME
"""
the structure is a function frame
"""

ida_struct.SF_GHOST
"""
ghost copy of a local type
"""

ida_struct.SF_HASUNI
"""
has members of type "union"?
"""

ida_struct.SF_HIDDEN
"""
the structure is collapsed
"""

ida_struct.SF_NOLIST
"""
don't include in the chooser list
"""

ida_struct.SF_TYPLIB
"""
the structure comes from type library
"""

ida_struct.SF_UNION
"""
varunions are prohibited!

is a union?
"""

ida_struct.SF_VAR
"""
is variable size structure (varstruct)? a variable size structure is
one with the zero size last member. if the last member is a varstruct,
then the current structure is a varstruct too.
"""

ida_struct.STRUC_SEPARATOR
"""
structname.fieldname
"""
=== ida_struct EPYDOC INJECTIONS END ===
ida_tryblks.add_tryblk():
	
	  add_tryblk(tb) -> int
	
	
	  Add one try block information.
	  
	  @param tb: try block to add. (C++: const  tryblk_t  &)
	  @return: error code; 0 means good
	  

class ida_tryblks.catch_t():
	
	    Proxy of C++ catch_t class
	    

ida_tryblks.catch_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_tryblks.catch_t.at():
	
	        at(self, _idx) -> range_t
	        

ida_tryblks.catch_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_tryblks.catch_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_tryblks.catch_t.clear():
	
	        clear(self)
	        

ida_tryblks.catch_t.disp:
	try_handler_t_disp_get(self) -> sval_t

ida_tryblks.catch_t.empty():
	
	        empty(self) -> bool
	        

ida_tryblks.catch_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_tryblks.catch_t.erase():
	
	        erase(self, it) -> range_t
	        erase(self, first, last) -> range_t
	        

ida_tryblks.catch_t.extract():
	
	        extract(self) -> range_t
	        

ida_tryblks.catch_t.find():
	
	        find(self, x) -> range_t
	        find(self, x) -> range_t
	        

ida_tryblks.catch_t.fpreg:
	try_handler_t_fpreg_get(self) -> int

ida_tryblks.catch_t.grow():
	
	        grow(self, x=range_t())
	        

ida_tryblks.catch_t.has():
	
	        has(self, x) -> bool
	        

ida_tryblks.catch_t.inject():
	
	        inject(self, s, len)
	        

ida_tryblks.catch_t.insert():
	
	        insert(self, it, x) -> range_t
	        

ida_tryblks.catch_t.obj:
	catch_t_obj_get(self) -> sval_t

ida_tryblks.catch_t.pop_back():
	
	        pop_back(self)
	        

ida_tryblks.catch_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> range_t
	        

ida_tryblks.catch_t.qclear():
	
	        qclear(self)
	        

ida_tryblks.catch_t.reserve():
	
	        reserve(self, cnt)
	        

ida_tryblks.catch_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_tryblks.catch_t.size():
	
	        size(self) -> size_t
	        

ida_tryblks.catch_t.swap():
	
	        swap(self, r)
	        

ida_tryblks.catch_t.truncate():
	
	        truncate(self)
	        

ida_tryblks.catch_t.type_id:
	catch_t_type_id_get(self) -> sval_t

class ida_tryblks.catchvec_t():
	
	    Proxy of C++ qvector<(catch_t)> class
	    

ida_tryblks.catchvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_tryblks.catchvec_t.at():
	
	        at(self, _idx) -> catch_t
	        

ida_tryblks.catchvec_t.begin():
	
	        begin(self) -> catch_t
	        begin(self) -> catch_t
	        

ida_tryblks.catchvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_tryblks.catchvec_t.clear():
	
	        clear(self)
	        

ida_tryblks.catchvec_t.empty():
	
	        empty(self) -> bool
	        

ida_tryblks.catchvec_t.end():
	
	        end(self) -> catch_t
	        end(self) -> catch_t
	        

ida_tryblks.catchvec_t.erase():
	
	        erase(self, it) -> catch_t
	        erase(self, first, last) -> catch_t
	        

ida_tryblks.catchvec_t.extract():
	
	        extract(self) -> catch_t
	        

ida_tryblks.catchvec_t.find():
	
	        find(self, x) -> catch_t
	        find(self, x) -> catch_t
	        

ida_tryblks.catchvec_t.grow():
	
	        grow(self, x=catch_t())
	        

ida_tryblks.catchvec_t.has():
	
	        has(self, x) -> bool
	        

ida_tryblks.catchvec_t.inject():
	
	        inject(self, s, len)
	        

ida_tryblks.catchvec_t.insert():
	
	        insert(self, it, x) -> catch_t
	        

ida_tryblks.catchvec_t.pop_back():
	
	        pop_back(self)
	        

ida_tryblks.catchvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> catch_t
	        

ida_tryblks.catchvec_t.qclear():
	
	        qclear(self)
	        

ida_tryblks.catchvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_tryblks.catchvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_tryblks.catchvec_t.size():
	
	        size(self) -> size_t
	        

ida_tryblks.catchvec_t.swap():
	
	        swap(self, r)
	        

ida_tryblks.catchvec_t.truncate():
	
	        truncate(self)
	        

ida_tryblks.del_tryblks():
	
	  del_tryblks(range)
	
	
	  Delete try block information in the specified range.
	  
	  @param range: the range to be cleared (C++: const  range_t  &)
	  

ida_tryblks.find_syseh():
	
	  find_syseh(ea) -> ea_t
	
	
	  Find the start address of the system eh region including the argument.
	  
	  @param ea: search address (C++: ea_t)
	  @return: start address of surrounding tryblk, otherwise BADADDR
	  

ida_tryblks.get_tryblks():
	
	  get_tryblks(tbv, range) -> size_t
	
	
	  Retrieve try block information from the specified address range. Try
	  blocks are sorted by starting address and their nest levels
	  calculated.
	  
	  @param tbv: output buffer; may be NULL (C++: tryblks_t  *)
	  @param range: address range to change (C++: const  range_t  &)
	  @return: number of found try blocks
	  

class ida_tryblks.seh_t():
	
	    Proxy of C++ seh_t class
	    

ida_tryblks.seh_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_tryblks.seh_t.at():
	
	        at(self, _idx) -> range_t
	        

ida_tryblks.seh_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_tryblks.seh_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_tryblks.seh_t.clear():
	
	        clear(self)
	        

ida_tryblks.seh_t.disp:
	try_handler_t_disp_get(self) -> sval_t

ida_tryblks.seh_t.empty():
	
	        empty(self) -> bool
	        

ida_tryblks.seh_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_tryblks.seh_t.erase():
	
	        erase(self, it) -> range_t
	        erase(self, first, last) -> range_t
	        

ida_tryblks.seh_t.extract():
	
	        extract(self) -> range_t
	        

ida_tryblks.seh_t.filter:
	seh_t_filter_get(self) -> rangevec_t

ida_tryblks.seh_t.find():
	
	        find(self, x) -> range_t
	        find(self, x) -> range_t
	        

ida_tryblks.seh_t.fpreg:
	try_handler_t_fpreg_get(self) -> int

ida_tryblks.seh_t.grow():
	
	        grow(self, x=range_t())
	        

ida_tryblks.seh_t.has():
	
	        has(self, x) -> bool
	        

ida_tryblks.seh_t.inject():
	
	        inject(self, s, len)
	        

ida_tryblks.seh_t.insert():
	
	        insert(self, it, x) -> range_t
	        

ida_tryblks.seh_t.pop_back():
	
	        pop_back(self)
	        

ida_tryblks.seh_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> range_t
	        

ida_tryblks.seh_t.qclear():
	
	        qclear(self)
	        

ida_tryblks.seh_t.reserve():
	
	        reserve(self, cnt)
	        

ida_tryblks.seh_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_tryblks.seh_t.seh_code:
	seh_t_seh_code_get(self) -> ea_t

ida_tryblks.seh_t.size():
	
	        size(self) -> size_t
	        

ida_tryblks.seh_t.swap():
	
	        swap(self, r)
	        

ida_tryblks.seh_t.truncate():
	
	        truncate(self)
	        

class ida_tryblks.try_handler_t():
	
	    Proxy of C++ try_handler_t class
	    

ida_tryblks.try_handler_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_tryblks.try_handler_t.at():
	
	        at(self, _idx) -> range_t
	        

ida_tryblks.try_handler_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_tryblks.try_handler_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_tryblks.try_handler_t.clear():
	
	        clear(self)
	        

ida_tryblks.try_handler_t.disp:
	try_handler_t_disp_get(self) -> sval_t

ida_tryblks.try_handler_t.empty():
	
	        empty(self) -> bool
	        

ida_tryblks.try_handler_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_tryblks.try_handler_t.erase():
	
	        erase(self, it) -> range_t
	        erase(self, first, last) -> range_t
	        

ida_tryblks.try_handler_t.extract():
	
	        extract(self) -> range_t
	        

ida_tryblks.try_handler_t.find():
	
	        find(self, x) -> range_t
	        find(self, x) -> range_t
	        

ida_tryblks.try_handler_t.fpreg:
	try_handler_t_fpreg_get(self) -> int

ida_tryblks.try_handler_t.grow():
	
	        grow(self, x=range_t())
	        

ida_tryblks.try_handler_t.has():
	
	        has(self, x) -> bool
	        

ida_tryblks.try_handler_t.inject():
	
	        inject(self, s, len)
	        

ida_tryblks.try_handler_t.insert():
	
	        insert(self, it, x) -> range_t
	        

ida_tryblks.try_handler_t.pop_back():
	
	        pop_back(self)
	        

ida_tryblks.try_handler_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> range_t
	        

ida_tryblks.try_handler_t.qclear():
	
	        qclear(self)
	        

ida_tryblks.try_handler_t.reserve():
	
	        reserve(self, cnt)
	        

ida_tryblks.try_handler_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_tryblks.try_handler_t.size():
	
	        size(self) -> size_t
	        

ida_tryblks.try_handler_t.swap():
	
	        swap(self, r)
	        

ida_tryblks.try_handler_t.truncate():
	
	        truncate(self)
	        

class ida_tryblks.tryblk_t():
	
	    Proxy of C++ tryblk_t class
	    

ida_tryblks.tryblk_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_tryblks.tryblk_t.at():
	
	        at(self, _idx) -> range_t
	        

ida_tryblks.tryblk_t.begin():
	
	        begin(self) -> range_t
	        begin(self) -> range_t
	        

ida_tryblks.tryblk_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_tryblks.tryblk_t.clear():
	
	        clear(self)
	        

ida_tryblks.tryblk_t.cpp():
	
	        cpp(self) -> catchvec_t
	        

ida_tryblks.tryblk_t.empty():
	
	        empty(self) -> bool
	        

ida_tryblks.tryblk_t.end():
	
	        end(self) -> range_t
	        end(self) -> range_t
	        

ida_tryblks.tryblk_t.erase():
	
	        erase(self, it) -> range_t
	        erase(self, first, last) -> range_t
	        

ida_tryblks.tryblk_t.extract():
	
	        extract(self) -> range_t
	        

ida_tryblks.tryblk_t.find():
	
	        find(self, x) -> range_t
	        find(self, x) -> range_t
	        

ida_tryblks.tryblk_t.get_kind():
	
	        get_kind(self) -> uchar
	        

ida_tryblks.tryblk_t.grow():
	
	        grow(self, x=range_t())
	        

ida_tryblks.tryblk_t.has():
	
	        has(self, x) -> bool
	        

ida_tryblks.tryblk_t.inject():
	
	        inject(self, s, len)
	        

ida_tryblks.tryblk_t.insert():
	
	        insert(self, it, x) -> range_t
	        

ida_tryblks.tryblk_t.is_cpp():
	
	        is_cpp(self) -> bool
	        

ida_tryblks.tryblk_t.is_seh():
	
	        is_seh(self) -> bool
	        

ida_tryblks.tryblk_t.level:
	tryblk_t_level_get(self) -> uchar

ida_tryblks.tryblk_t.pop_back():
	
	        pop_back(self)
	        

ida_tryblks.tryblk_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> range_t
	        

ida_tryblks.tryblk_t.qclear():
	
	        qclear(self)
	        

ida_tryblks.tryblk_t.reserve():
	
	        reserve(self, cnt)
	        

ida_tryblks.tryblk_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_tryblks.tryblk_t.seh():
	
	        seh(self) -> seh_t
	        

ida_tryblks.tryblk_t.set_cpp():
	
	        set_cpp(self) -> catchvec_t
	        

ida_tryblks.tryblk_t.set_seh():
	
	        set_seh(self) -> seh_t
	        

ida_tryblks.tryblk_t.size():
	
	        size(self) -> size_t
	        

ida_tryblks.tryblk_t.swap():
	
	        swap(self, r)
	        

ida_tryblks.tryblk_t.truncate():
	
	        truncate(self)
	        

class ida_tryblks.tryblks_t():
	
	    Proxy of C++ qvector<(tryblk_t)> class
	    

ida_tryblks.tryblks_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_tryblks.tryblks_t.at():
	
	        at(self, _idx) -> tryblk_t
	        

ida_tryblks.tryblks_t.begin():
	
	        begin(self) -> tryblk_t
	        begin(self) -> tryblk_t
	        

ida_tryblks.tryblks_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_tryblks.tryblks_t.clear():
	
	        clear(self)
	        

ida_tryblks.tryblks_t.empty():
	
	        empty(self) -> bool
	        

ida_tryblks.tryblks_t.end():
	
	        end(self) -> tryblk_t
	        end(self) -> tryblk_t
	        

ida_tryblks.tryblks_t.erase():
	
	        erase(self, it) -> tryblk_t
	        erase(self, first, last) -> tryblk_t
	        

ida_tryblks.tryblks_t.extract():
	
	        extract(self) -> tryblk_t
	        

ida_tryblks.tryblks_t.find():
	
	        find(self, x) -> tryblk_t
	        find(self, x) -> tryblk_t
	        

ida_tryblks.tryblks_t.grow():
	
	        grow(self, x=tryblk_t())
	        

ida_tryblks.tryblks_t.has():
	
	        has(self, x) -> bool
	        

ida_tryblks.tryblks_t.inject():
	
	        inject(self, s, len)
	        

ida_tryblks.tryblks_t.insert():
	
	        insert(self, it, x) -> tryblk_t
	        

ida_tryblks.tryblks_t.pop_back():
	
	        pop_back(self)
	        

ida_tryblks.tryblks_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> tryblk_t
	        

ida_tryblks.tryblks_t.qclear():
	
	        qclear(self)
	        

ida_tryblks.tryblks_t.reserve():
	
	        reserve(self, cnt)
	        

ida_tryblks.tryblks_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_tryblks.tryblks_t.size():
	
	        size(self) -> size_t
	        

ida_tryblks.tryblks_t.swap():
	
	        swap(self, r)
	        

ida_tryblks.tryblks_t.truncate():
	
	        truncate(self)
	        


=== ida_tryblks EPYDOC INJECTIONS ===
ida_tryblks.TBERR_EMPTY
"""
empty try block
"""

ida_tryblks.TBERR_END
"""
bad end address
"""

ida_tryblks.TBERR_INTERSECT
"""
range would intersect inner tryblk
"""

ida_tryblks.TBERR_KIND
"""
illegal try block kind
"""

ida_tryblks.TBERR_NO_CATCHES
"""
no catch blocks at all
"""

ida_tryblks.TBERR_OK
"""
ok
"""

ida_tryblks.TBERR_ORDER
"""
bad address order
"""

ida_tryblks.TBERR_START
"""
bad start address
"""
=== ida_tryblks EPYDOC INJECTIONS END ===
ida_typeinf.add_til():
	
	  add_til(name, flags) -> int
	
	
	  Load a til file.
	  
	  @param name: til name (C++: const char *)
	  @param flags: combination of  Load TIL flags (C++: int)
	  @return: one of  Load TIL result codes
	  

ida_typeinf.alloc_type_ordinal():
	
	  alloc_type_ordinal(ti) -> uint32
	
	
	  {alloc_type_ordinals,ti,1}
	  
	  
	  @param ti (C++: til_t  *)
	  

ida_typeinf.alloc_type_ordinals():
	
	  alloc_type_ordinals(ti, qty) -> uint32
	
	
	  Allocate a range of ordinal numbers for new types.
	  
	  @param ti: type library (C++: til_t  *)
	  @param qty: number of ordinals to allocate (C++: int)
	  @return: the first ordinal. 0 means failure.
	  

class ida_typeinf.aloc_visitor_t():
	
	    Proxy of C++ aloc_visitor_t class
	    

ida_typeinf.aloc_visitor_t.visit_location():
	
	        visit_location(self, v, off, size) -> int
	        

ida_typeinf.append_abi_opts():
	
	  append_abi_opts(abi_opts, user_level=False) -> bool
	
	
	  Add/remove/check ABI option General form of full abi name: abiname-
	  opt1-opt2-... or -opt1-opt2-...
	  
	  @param abi_opts: - ABI options to add/remove in form opt1-opt2-...
	                   (C++: const char *)
	  @param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
	                     (C++: bool)
	  @return: success
	  

ida_typeinf.append_argloc():
	
	  append_argloc(out, vloc) -> bool
	
	
	  Serialize argument location.
	  
	  
	  @param out (C++: qtype  *)
	  @param vloc (C++: const  argloc_t  &)
	  

ida_typeinf.append_tinfo_covered():
	
	  append_tinfo_covered(out, typid, offset) -> bool
	  

ida_typeinf.apply_callee_tinfo():
	
	  apply_callee_tinfo(caller, tif) -> bool
	
	
	  Apply the type of the called function to the calling instruction. This
	  function will append parameter comments and rename the local variables
	  of the calling function. It also stores information about the
	  instructions that initialize call arguments in the database. Use
	  'get_arg_addrs()' to retrieve it if necessary. Alternatively it is
	  possible to hook to processor_t::arg_addrs_ready event.
	  
	  @param caller: linear address of the calling instruction. must belong
	                 to a function. (C++: ea_t)
	  @param tif: type info (C++: const  tinfo_t  &)
	  @return: success
	  

ida_typeinf.apply_cdecl():
	
	  apply_cdecl(til, ea, decl, flags=0) -> bool
	
	
	  Apply the specified type to the address. This function parses the
	  declaration and calls 'apply_tinfo()'
	  
	  @param til: type library (C++: til_t  *)
	  @param ea: linear address (C++: ea_t)
	  @param decl: type declaration in C form (C++: const char *)
	  @param flags: flags to pass to apply_tinfo ( TINFO_DEFINITE  is always
	                passed) (C++: int)
	  @return: success
	  

ida_typeinf.apply_named_type():
	
	  apply_named_type(ea, name) -> bool
	
	
	  Apply the specified named type to the address.
	  
	  @param ea: linear address (C++: ea_t)
	  @param name: the type name, e.g. "FILE" (C++: const char *)
	  @return: success
	  

ida_typeinf.apply_once_tinfo_and_name():
	
	  apply_once_tinfo_and_name(dea, tif, name) -> bool
	
	
	  Apply the specified type and name to the address. This function checks
	  if the address already has a type. If the old typedoes not exist or
	  the new type is 'better' than the old type, then thenew type will be
	  applied. A type is considered better if it has moreinformation (e.g.
	  'BTMT_STRUCT' is better than 'BT_INT' ).The same logic is with the
	  name: if the address already have a meaningfulname, it will be
	  preserved. Only if the old name does not exist or itis a dummy name
	  like byte_123, it will be replaced by the new name.
	  
	  @param dea: linear address (C++: ea_t)
	  @param tif: type string in the internal format (C++: const  tinfo_t
	              &)
	  @param name: new name for the address (C++: const char *)
	  @return: success
	  

ida_typeinf.apply_tinfo():
	
	  apply_tinfo(ea, tif, flags) -> bool
	
	
	  Apply the specified type to the specified address. This function sets
	  the type and tries to convert the item at the specified address to
	  conform the type.
	  
	  @param ea: linear address (C++: ea_t)
	  @param tif: type string in internal format (C++: const  tinfo_t  &)
	  @param flags: combination of  Apply tinfo flags (C++: uint32)
	  @return: success
	  

ida_typeinf.apply_tinfo_to_stkarg():
	
	  apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool
	
	
	  Helper function for the processor modules. to be called from
	  {use_stkarg_type}
	  
	  @param insn (C++: const  insn_t  &)
	  @param x (C++: const  op_t  &)
	  @param v (C++: uval_t)
	  @param tif (C++: const  tinfo_t  &)
	  @param name (C++: const char *)
	  

ida_typeinf.apply_type():
	
	  apply_type(ti, py_type, py_fields, ea, flags) -> bool
	
	
	  Apply the specified type to the address
	  @param ti: Type info library. 'None' can be used.
	  @param py_type: type string
	  @param py_fields: fields string (may be empty or None)
	  @param ea: the address of the object
	  @param flags: combination of TINFO_... constants or 0
	  @return: Boolean
	  

class ida_typeinf.argloc_t():
	
	    Proxy of C++ argloc_t class
	    

ida_typeinf.argloc_t.advance():
	
	        advance(self, delta) -> bool
	        

ida_typeinf.argloc_t.atype():
	
	        atype(self) -> argloc_type_t
	        

ida_typeinf.argloc_t.calc_offset():
	
	        calc_offset(self) -> sval_t
	        

ida_typeinf.argloc_t.compare():
	
	        compare(self, r) -> int
	        

ida_typeinf.argloc_t.consume_rrel():
	
	        consume_rrel(self, p)
	        

ida_typeinf.argloc_t.consume_scattered():
	
	        consume_scattered(self, p)
	        

ida_typeinf.argloc_t.get_biggest():
	
	        get_biggest(self) -> argloc_t::biggest_t
	        

ida_typeinf.argloc_t.get_custom():
	
	        get_custom(self) -> void *
	        

ida_typeinf.argloc_t.get_ea():
	
	        get_ea(self) -> ea_t
	        

ida_typeinf.argloc_t.get_reginfo():
	
	        get_reginfo(self) -> uint32
	        

ida_typeinf.argloc_t.get_rrel():
	
	        get_rrel(self) -> rrel_t
	        get_rrel(self) -> rrel_t
	        

ida_typeinf.argloc_t.is_badloc():
	
	        is_badloc(self) -> bool
	        

ida_typeinf.argloc_t.is_custom():
	
	        is_custom(self) -> bool
	        

ida_typeinf.argloc_t.is_ea():
	
	        is_ea(self) -> bool
	        

ida_typeinf.argloc_t.is_fragmented():
	
	        is_fragmented(self) -> bool
	        

ida_typeinf.argloc_t.is_mixed_scattered():
	
	        is_mixed_scattered(self) -> bool
	        

ida_typeinf.argloc_t.is_reg():
	
	        is_reg(self) -> bool
	        

ida_typeinf.argloc_t.is_reg1():
	
	        is_reg1(self) -> bool
	        

ida_typeinf.argloc_t.is_reg2():
	
	        is_reg2(self) -> bool
	        

ida_typeinf.argloc_t.is_rrel():
	
	        is_rrel(self) -> bool
	        

ida_typeinf.argloc_t.is_scattered():
	
	        is_scattered(self) -> bool
	        

ida_typeinf.argloc_t.is_stkoff():
	
	        is_stkoff(self) -> bool
	        

ida_typeinf.argloc_t.reg1():
	
	        reg1(self) -> int
	        

ida_typeinf.argloc_t.reg2():
	
	        reg2(self) -> int
	        

ida_typeinf.argloc_t.regoff():
	
	        regoff(self) -> int
	        

ida_typeinf.argloc_t.scattered():
	
	        scattered(self) -> scattered_aloc_t
	        scattered(self) -> scattered_aloc_t
	        

ida_typeinf.argloc_t.set_badloc():
	
	        set_badloc(self)
	        

ida_typeinf.argloc_t.set_ea():
	
	        set_ea(self, _ea)
	        

ida_typeinf.argloc_t.set_reg1():
	
	        set_reg1(self, reg, off=0)
	        

ida_typeinf.argloc_t.set_reg2():
	
	        set_reg2(self, _reg1, _reg2)
	        

ida_typeinf.argloc_t.set_stkoff():
	
	        set_stkoff(self, off)
	        

ida_typeinf.argloc_t.stkoff():
	
	        stkoff(self) -> sval_t
	        

ida_typeinf.argloc_t.swap():
	
	        swap(self, r)
	        

class ida_typeinf.argpart_t():
	
	    Proxy of C++ argpart_t class
	    

ida_typeinf.argpart_t.advance():
	
	        advance(self, delta) -> bool
	        

ida_typeinf.argpart_t.atype():
	
	        atype(self) -> argloc_type_t
	        

ida_typeinf.argpart_t.bad_offset():
	
	        bad_offset(self) -> bool
	        

ida_typeinf.argpart_t.bad_size():
	
	        bad_size(self) -> bool
	        

ida_typeinf.argpart_t.calc_offset():
	
	        calc_offset(self) -> sval_t
	        

ida_typeinf.argpart_t.compare():
	
	        compare(self, r) -> int
	        

ida_typeinf.argpart_t.consume_rrel():
	
	        consume_rrel(self, p)
	        

ida_typeinf.argpart_t.consume_scattered():
	
	        consume_scattered(self, p)
	        

ida_typeinf.argpart_t.get_biggest():
	
	        get_biggest(self) -> argloc_t::biggest_t
	        

ida_typeinf.argpart_t.get_custom():
	
	        get_custom(self) -> void *
	        

ida_typeinf.argpart_t.get_ea():
	
	        get_ea(self) -> ea_t
	        

ida_typeinf.argpart_t.get_reginfo():
	
	        get_reginfo(self) -> uint32
	        

ida_typeinf.argpart_t.get_rrel():
	
	        get_rrel(self) -> rrel_t
	        get_rrel(self) -> rrel_t
	        

ida_typeinf.argpart_t.is_badloc():
	
	        is_badloc(self) -> bool
	        

ida_typeinf.argpart_t.is_custom():
	
	        is_custom(self) -> bool
	        

ida_typeinf.argpart_t.is_ea():
	
	        is_ea(self) -> bool
	        

ida_typeinf.argpart_t.is_fragmented():
	
	        is_fragmented(self) -> bool
	        

ida_typeinf.argpart_t.is_mixed_scattered():
	
	        is_mixed_scattered(self) -> bool
	        

ida_typeinf.argpart_t.is_reg():
	
	        is_reg(self) -> bool
	        

ida_typeinf.argpart_t.is_reg1():
	
	        is_reg1(self) -> bool
	        

ida_typeinf.argpart_t.is_reg2():
	
	        is_reg2(self) -> bool
	        

ida_typeinf.argpart_t.is_rrel():
	
	        is_rrel(self) -> bool
	        

ida_typeinf.argpart_t.is_scattered():
	
	        is_scattered(self) -> bool
	        

ida_typeinf.argpart_t.is_stkoff():
	
	        is_stkoff(self) -> bool
	        

ida_typeinf.argpart_t.off:
	argpart_t_off_get(self) -> ushort

ida_typeinf.argpart_t.reg1():
	
	        reg1(self) -> int
	        

ida_typeinf.argpart_t.reg2():
	
	        reg2(self) -> int
	        

ida_typeinf.argpart_t.regoff():
	
	        regoff(self) -> int
	        

ida_typeinf.argpart_t.scattered():
	
	        scattered(self) -> scattered_aloc_t
	        scattered(self) -> scattered_aloc_t
	        

ida_typeinf.argpart_t.set_badloc():
	
	        set_badloc(self)
	        

ida_typeinf.argpart_t.set_ea():
	
	        set_ea(self, _ea)
	        

ida_typeinf.argpart_t.set_reg1():
	
	        set_reg1(self, reg, off=0)
	        

ida_typeinf.argpart_t.set_reg2():
	
	        set_reg2(self, _reg1, _reg2)
	        

ida_typeinf.argpart_t.set_stkoff():
	
	        set_stkoff(self, off)
	        

ida_typeinf.argpart_t.size:
	argpart_t_size_get(self) -> ushort

ida_typeinf.argpart_t.stkoff():
	
	        stkoff(self) -> sval_t
	        

ida_typeinf.argpart_t.swap():
	
	        swap(self, r)
	        

class ida_typeinf.array_type_data_t():
	
	    Proxy of C++ array_type_data_t class
	    

ida_typeinf.array_type_data_t.base:
	array_type_data_t_base_get(self) -> uint32

ida_typeinf.array_type_data_t.elem_type:
	array_type_data_t_elem_type_get(self) -> tinfo_t

ida_typeinf.array_type_data_t.nelems:
	array_type_data_t_nelems_get(self) -> uint32

ida_typeinf.array_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.begin_type_updating():
	
	  begin_type_updating(utp)
	
	
	  Mark the beginning of a large update operation on the types. Can be
	  used with 'add_enum_member()' , add_struc_member, etc... Also see
	  'end_type_updating()'
	  
	  @param utp (C++: update_type_t)
	  

class ida_typeinf.bitfield_type_data_t():
	
	    Proxy of C++ bitfield_type_data_t class
	    

ida_typeinf.bitfield_type_data_t.compare():
	
	        compare(self, r) -> int
	        

ida_typeinf.bitfield_type_data_t.is_unsigned:
	bitfield_type_data_t_is_unsigned_get(self) -> bool

ida_typeinf.bitfield_type_data_t.nbytes:
	bitfield_type_data_t_nbytes_get(self) -> uchar

ida_typeinf.bitfield_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.bitfield_type_data_t.width:
	bitfield_type_data_t_width_get(self) -> uchar

ida_typeinf.calc_c_cpp_name():
	
	  calc_c_cpp_name(name, type, ccn_flags) -> ssize_t
	
	
	  Get C or C++ form of the name.
	  
	  @param name: original (mangled or decorated) name (C++: const char *)
	  @param type: name type if known, otherwise NULL (C++: const  tinfo_t
	               *)
	  @param ccn_flags: one of  C/C++ naming flags (C++: int)
	  

ida_typeinf.calc_number_of_children():
	
	  calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int
	
	
	  Calculate max number of lines of a formatted c data, when expanded (
	  'PTV_EXPAND' ).
	  
	  @param loc: location of the data ( ALOC_STATIC  or  ALOC_CUSTOM )
	              (C++: const  argloc_t  &)
	  @param tif: type info (C++: const  tinfo_t  &)
	  @param dont_deref_ptr: consider 'ea' as the ptr value (C++: bool)
	  

ida_typeinf.calc_tinfo_gaps():
	
	  calc_tinfo_gaps(out, typid) -> bool
	  

ida_typeinf.calc_type_size():
	
	  calc_type_size(ti, tp) -> PyObject *
	
	
	  Returns the size of a type
	  @param ti: Type info. 'None' can be passed.
	  @param tp: type string
	  @return:
	      - None on failure
	      - The size of the type
	  

class ida_typeinf.callregs_t():
	
	    Proxy of C++ callregs_t class
	    

ida_typeinf.callregs_t.fpregs:
	callregs_t_fpregs_get(self) -> intvec_t *

ida_typeinf.callregs_t.gpregs:
	callregs_t_gpregs_get(self) -> intvec_t *

ida_typeinf.callregs_t.init_regs():
	
	        init_regs(self, cc)
	        

ida_typeinf.callregs_t.nregs:
	callregs_t_nregs_get(self) -> int

ida_typeinf.callregs_t.policy:
	callregs_t_policy_get(self) -> argreg_policy_t

ida_typeinf.callregs_t.regcount():
	
	        regcount(cc) -> int
	        

ida_typeinf.callregs_t.reginds():
	
	        reginds(self, gp_ind, fp_ind, r) -> bool
	        

ida_typeinf.callregs_t.reset():
	
	        reset(self)
	        

ida_typeinf.callregs_t.set():
	
	        set(self, _policy, gprs, fprs)
	        

ida_typeinf.callregs_t_regcount():
	
	  callregs_t_regcount(cc) -> int
	  

ida_typeinf.choose_local_tinfo():
	
	  choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32
	
	
	  Choose a type from the local type library.
	  
	  @param ti: pointer to til (C++: const  til_t  *)
	  @param title: title of listbox to display (C++: const char *)
	  @param func: predicate to select types to display (maybe NULL) (C++:
	               local_tinfo_predicate_t  *)
	  @param def_ord: ordinal to position cursor before choose (C++: uint32)
	  @param ud: user data (C++: void *)
	  @return: == 0 means nothing is chosen, otherwise an ordinal number
	  

ida_typeinf.choose_named_type():
	
	  choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool
	
	
	  Choose a type from a type library.
	  
	  @param out_sym: pointer to be filled with the chosen type (C++:
	                  til_symbol_t  *)
	  @param root_til: pointer to starting til (the function will inspect
	                   the base tils if allowed by flags) (C++: const  til_t
	                   *)
	  @param title: title of listbox to display (C++: const char *)
	  @param ntf_flags: combination of  Flags for named types (C++: int)
	  @param predicate: predicate to select types to display (maybe NULL)
	                    (C++: predicate_t  *)
	  @return: false if nothing is chosen, otherwise true
	  

ida_typeinf.clear_tinfo_t():
	
	  clear_tinfo_t(_this)
	  

ida_typeinf.compact_til():
	
	  compact_til(ti) -> bool
	
	
	  Collect garbage in til. Must be called before storing the til.
	  
	  @param ti (C++: til_t  *)
	  @return: true if any memory was freed
	  

ida_typeinf.compare():
	
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    compare(a, b) -> int
	    

ida_typeinf.compare_tinfo():
	
	  compare_tinfo(t1, t2, tcflags) -> bool
	  

class ida_typeinf.const_aloc_visitor_t():
	
	    Proxy of C++ const_aloc_visitor_t class
	    

ida_typeinf.const_aloc_visitor_t.visit_location():
	
	        visit_location(self, v, off, size) -> int
	        

ida_typeinf.convert_pt_flags_to_hti():
	
	  convert_pt_flags_to_hti(pt_flags) -> int
	
	
	  Convert 'Type parsing flags' to 'Type formatting flags' . Type parsing
	  flags lesser than 0x10 don't have stable meaning and will be ignored
	  (more on these flags can be seen in idc.idc)
	  
	  @param pt_flags (C++: int)
	  

ida_typeinf.copy_named_type():
	
	  copy_named_type(dsttil, srctil, name) -> uint32
	
	
	  Copy a named type from one til to another. This function will copy the
	  specified type and all dependent types from the source type library to
	  the destination library.
	  
	  @param dsttil: Destination til. It must have orginal types enabled
	                 (C++: til_t  *)
	  @param srctil: Source til. (C++: const  til_t  *)
	  @param name: name of the type to copy (C++: const char *)
	  @return: ordinal number of the copied type. 0 means error
	  

ida_typeinf.copy_tinfo_t():
	
	  copy_tinfo_t(_this, r)
	  

ida_typeinf.create_numbered_type_name():
	
	  create_numbered_type_name(ord) -> ssize_t
	
	
	  Create anonymous name for numbered type. This name can be used to
	  reference a numbered type by its ordinal Ordinal names have the
	  following format: '#' + set_de(ord) Returns: -1 if error, otherwise
	  the name length
	  
	  @param ord (C++: int32)
	  

ida_typeinf.create_tinfo():
	
	  create_tinfo(_this, bt, bt2, ptr) -> bool
	  

ida_typeinf.default_compiler():
	
	  default_compiler() -> comp_t
	
	
	  Get compiler specified by {inf,idainfo,cc}.
	  

ida_typeinf.del_named_type():
	
	  del_named_type(ti, name, ntf_flags) -> bool
	
	
	  Delete information about a symbol.
	  
	  @param ti: type library (C++: til_t  *)
	  @param name: name of symbol (C++: const char *)
	  @param ntf_flags: combination of  Flags for named types (C++: int)
	  @return: success
	  

ida_typeinf.del_numbered_type():
	
	  del_numbered_type(ti, ordinal) -> bool
	
	
	  Delete a numbered type.
	  
	  
	  @param ti (C++: til_t  *)
	  @param ordinal (C++: uint32)
	  

ida_typeinf.del_til():
	
	  del_til(name) -> bool
	
	
	  Unload a til file.
	  
	  
	  @param name (C++: const char *)
	  

ida_typeinf.del_tinfo_attr():
	
	  del_tinfo_attr(tif, key, make_copy) -> bool
	  

ida_typeinf.deref_ptr():
	
	  deref_ptr(ptr_ea, tif, closure_obj=None) -> bool
	
	
	  Dereference a pointer.
	  
	  @param ptr_ea: in/out parameter   in: address of the pointer out: the
	                 pointed address (C++: ea_t *)
	  @param tif: type of the pointer (C++: const  tinfo_t  &)
	  @param closure_obj: closure object (not used yet) (C++: ea_t *)
	  @return: success
	  

ida_typeinf.deserialize_tinfo():
	
	  deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -> bool
	  

ida_typeinf.dstr_tinfo():
	
	  dstr_tinfo(tif) -> char const *
	  

ida_typeinf.dump_func_type_data():
	
	  dump_func_type_data(fti, praloc_bits) -> bool
	
	
	  Use 'func_type_data_t::dump()'
	  
	  
	  @param fti (C++: const  func_type_data_t  &)
	  @param praloc_bits (C++: int)
	  

ida_typeinf.end_type_updating():
	
	  end_type_updating(utp)
	
	
	  Mark the end of a large update operation on the types (see
	  'begin_type_updating()' )
	  
	  
	  @param utp (C++: update_type_t)
	  

class ida_typeinf.enum_member_t():
	
	    Proxy of C++ enum_member_t class
	    

ida_typeinf.enum_member_t.cmt:
	enum_member_t_cmt_get(self) -> qstring *

ida_typeinf.enum_member_t.name:
	enum_member_t_name_get(self) -> qstring *

ida_typeinf.enum_member_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.enum_member_t.value:
	enum_member_t_value_get(self) -> uint64

class ida_typeinf.enum_type_data_t():
	
	    Proxy of C++ enum_type_data_t class
	    

ida_typeinf.enum_type_data_t.bte:
	enum_type_data_t_bte_get(self) -> bte_t

ida_typeinf.enum_type_data_t.calc_mask():
	
	        calc_mask(self) -> uint64
	        

ida_typeinf.enum_type_data_t.calc_nbytes():
	
	        calc_nbytes(self) -> int
	        

ida_typeinf.enum_type_data_t.group_sizes:
	enum_type_data_t_group_sizes_get(self) -> intvec_t *

ida_typeinf.enum_type_data_t.is_64bit():
	
	        is_64bit(self) -> bool
	        

ida_typeinf.enum_type_data_t.is_char():
	
	        is_char(self) -> bool
	        

ida_typeinf.enum_type_data_t.is_hex():
	
	        is_hex(self) -> bool
	        

ida_typeinf.enum_type_data_t.is_sdec():
	
	        is_sdec(self) -> bool
	        

ida_typeinf.enum_type_data_t.is_udec():
	
	        is_udec(self) -> bool
	        

ida_typeinf.enum_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.enum_type_data_t.taenum_bits:
	enum_type_data_t_taenum_bits_get(self) -> uint32

ida_typeinf.extract_argloc():
	
	  extract_argloc(vloc, ptype, is_retval) -> bool
	
	
	  Deserialize argument location.
	  
	  
	  @param vloc (C++: argloc_t  *)
	  @param ptype (C++: const  type_t  **)
	  @param is_retval (C++: bool)
	  

ida_typeinf.find_tinfo_udt_member():
	
	  find_tinfo_udt_member(udm, typid, strmem_flags) -> int
	  

ida_typeinf.first_named_type():
	
	  first_named_type(ti, ntf_flags) -> char const *
	
	
	  Enumerate types. Returns mangled names. Never returns anonymous types.
	  To include it, enumerate types by ordinals.
	  
	  @param ti (C++: const  til_t  *)
	  @param ntf_flags (C++: int)
	  

ida_typeinf.for_all_arglocs():
	
	  for_all_arglocs(vv, vloc, size, off=0) -> int
	
	
	  Compress larger argloc types and initiate the aloc visitor.
	  
	  
	  @param vv (C++: aloc_visitor_t  &)
	  @param vloc (C++: argloc_t  &)
	  @param size (C++: int)
	  @param off (C++: int)
	  

ida_typeinf.for_all_const_arglocs():
	
	  for_all_const_arglocs(vv, vloc, size, off=0) -> int
	
	
	  See 'for_all_arglocs()'
	  
	  
	  @param vv (C++: const_aloc_visitor_t  &)
	  @param vloc (C++: const  argloc_t  &)
	  @param size (C++: int)
	  @param off (C++: int)
	  

ida_typeinf.free_til():
	
	  free_til(ti)
	
	
	  Free memory allocated by til.
	  
	  
	  @param ti (C++: til_t  *)
	  

ida_typeinf.func_has_stkframe_hole():
	
	  func_has_stkframe_hole(ea, fti) -> bool
	
	
	  Looks for a hole at the beginning of the stack arguments. Will make
	  use of the IDB's 'func_t' function at that place (if present) to help
	  determine the presence of such a hole.
	  
	  @param ea (C++: ea_t)
	  @param fti (C++: const  func_type_data_t  &)
	  

class ida_typeinf.func_type_data_t():
	
	    Proxy of C++ func_type_data_t class
	    

ida_typeinf.func_type_data_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_typeinf.func_type_data_t.at():
	
	        at(self, _idx) -> funcarg_t
	        

ida_typeinf.func_type_data_t.begin():
	
	        begin(self) -> funcarg_t
	        begin(self) -> funcarg_t
	        

ida_typeinf.func_type_data_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_typeinf.func_type_data_t.cc:
	func_type_data_t_cc_get(self) -> cm_t

ida_typeinf.func_type_data_t.clear():
	
	        clear(self)
	        

ida_typeinf.func_type_data_t.dump():
	
	        dump(self, praloc_bits=0x02) -> bool
	        

ida_typeinf.func_type_data_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.func_type_data_t.end():
	
	        end(self) -> funcarg_t
	        end(self) -> funcarg_t
	        

ida_typeinf.func_type_data_t.erase():
	
	        erase(self, it) -> funcarg_t
	        erase(self, first, last) -> funcarg_t
	        

ida_typeinf.func_type_data_t.extract():
	
	        extract(self) -> funcarg_t
	        

ida_typeinf.func_type_data_t.find():
	
	        find(self, x) -> funcarg_t
	        find(self, x) -> funcarg_t
	        

ida_typeinf.func_type_data_t.flags:
	func_type_data_t_flags_get(self) -> int

ida_typeinf.func_type_data_t.get_call_method():
	
	        get_call_method(self) -> int
	        

ida_typeinf.func_type_data_t.grow():
	
	        grow(self, x=funcarg_t())
	        

ida_typeinf.func_type_data_t.guess_cc():
	
	        guess_cc(self, purged, cc_flags) -> cm_t
	        

ida_typeinf.func_type_data_t.has():
	
	        has(self, x) -> bool
	        

ida_typeinf.func_type_data_t.inject():
	
	        inject(self, s, len)
	        

ida_typeinf.func_type_data_t.insert():
	
	        insert(self, it, x) -> funcarg_t
	        

ida_typeinf.func_type_data_t.is_high():
	
	        is_high(self) -> bool
	        

ida_typeinf.func_type_data_t.is_noret():
	
	        is_noret(self) -> bool
	        

ida_typeinf.func_type_data_t.is_pure():
	
	        is_pure(self) -> bool
	        

ida_typeinf.func_type_data_t.is_vararg_cc():
	
	        is_vararg_cc(self) -> bool
	        

ida_typeinf.func_type_data_t.pop_back():
	
	        pop_back(self)
	        

ida_typeinf.func_type_data_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> funcarg_t
	        

ida_typeinf.func_type_data_t.qclear():
	
	        qclear(self)
	        

ida_typeinf.func_type_data_t.reserve():
	
	        reserve(self, cnt)
	        

ida_typeinf.func_type_data_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_typeinf.func_type_data_t.retloc:
	func_type_data_t_retloc_get(self) -> argloc_t

ida_typeinf.func_type_data_t.rettype:
	func_type_data_t_rettype_get(self) -> tinfo_t

ida_typeinf.func_type_data_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.func_type_data_t.spoiled:
	func_type_data_t_spoiled_get(self) -> reginfovec_t

ida_typeinf.func_type_data_t.stkargs:
	func_type_data_t_stkargs_get(self) -> uval_t

ida_typeinf.func_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.func_type_data_t.truncate():
	
	        truncate(self)
	        

class ida_typeinf.funcarg_t():
	
	    Proxy of C++ funcarg_t class
	    

ida_typeinf.funcarg_t.argloc:
	funcarg_t_argloc_get(self) -> argloc_t

ida_typeinf.funcarg_t.cmt:
	funcarg_t_cmt_get(self) -> qstring *

ida_typeinf.funcarg_t.flags:
	funcarg_t_flags_get(self) -> uint32

ida_typeinf.funcarg_t.name:
	funcarg_t_name_get(self) -> qstring *

ida_typeinf.funcarg_t.type:
	funcarg_t_type_get(self) -> tinfo_t

class ida_typeinf.funcargvec_t():
	
	    Proxy of C++ qvector<(funcarg_t)> class
	    

ida_typeinf.funcargvec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_typeinf.funcargvec_t.at():
	
	        at(self, _idx) -> funcarg_t
	        

ida_typeinf.funcargvec_t.begin():
	
	        begin(self) -> funcarg_t
	        begin(self) -> funcarg_t
	        

ida_typeinf.funcargvec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_typeinf.funcargvec_t.clear():
	
	        clear(self)
	        

ida_typeinf.funcargvec_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.funcargvec_t.end():
	
	        end(self) -> funcarg_t
	        end(self) -> funcarg_t
	        

ida_typeinf.funcargvec_t.erase():
	
	        erase(self, it) -> funcarg_t
	        erase(self, first, last) -> funcarg_t
	        

ida_typeinf.funcargvec_t.extract():
	
	        extract(self) -> funcarg_t
	        

ida_typeinf.funcargvec_t.find():
	
	        find(self, x) -> funcarg_t
	        find(self, x) -> funcarg_t
	        

ida_typeinf.funcargvec_t.grow():
	
	        grow(self, x=funcarg_t())
	        

ida_typeinf.funcargvec_t.has():
	
	        has(self, x) -> bool
	        

ida_typeinf.funcargvec_t.inject():
	
	        inject(self, s, len)
	        

ida_typeinf.funcargvec_t.insert():
	
	        insert(self, it, x) -> funcarg_t
	        

ida_typeinf.funcargvec_t.pop_back():
	
	        pop_back(self)
	        

ida_typeinf.funcargvec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> funcarg_t
	        

ida_typeinf.funcargvec_t.qclear():
	
	        qclear(self)
	        

ida_typeinf.funcargvec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_typeinf.funcargvec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_typeinf.funcargvec_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.funcargvec_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.funcargvec_t.truncate():
	
	        truncate(self)
	        

ida_typeinf.gcc_layout():
	
	  gcc_layout() -> bool
	
	
	  Should use the struct/union layout as done by gcc?
	  

ida_typeinf.gen_decorate_name():
	
	  gen_decorate_name(name, mangle, cc, type) -> bool
	
	
	  Generic function for 'decorate_name()' (may be used in IDP modules)
	  
	  
	  @param name (C++: const char *)
	  @param mangle (C++: bool)
	  @param cc (C++: cm_t)
	  @param type (C++: const  tinfo_t  *)
	  

ida_typeinf.gen_use_arg_tinfos():
	
	  gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)
	
	
	  The main function using these callbacks:
	  
	  
	  @param caller (C++: ea_t)
	  @param fti (C++: func_type_data_t  *)
	  @param rargs (C++: funcargvec_t  *)
	  @param set_optype (C++: set_op_tinfo_t  *)
	  @param is_stkarg_load (C++: is_stkarg_load_t  *)
	  @param has_delay_slot (C++: has_delay_slot_t  *)
	  

ida_typeinf.get_abi_name():
	
	  get_abi_name() -> ssize_t
	
	
	  Get ABI name.
	  
	  @return: length of the name (>=0)
	  

ida_typeinf.get_alias_target():
	
	  get_alias_target(ti, ordinal) -> uint32
	
	
	  Find the final alias destination. If the ordinal has not been aliased,
	  return the specified ordinal itself If failed, returns 0.
	  
	  @param ti (C++: const  til_t  *)
	  @param ordinal (C++: uint32)
	  

ida_typeinf.get_arg_addrs():
	
	  get_arg_addrs(caller) -> PyObject *
	
	
	  Retrieve addresses of argument initialization instructions
	  
	  @param caller: the address of the call instruction
	  @return: list of instruction addresses
	  

ida_typeinf.get_base_type():
	
	  get_base_type(t) -> type_t
	
	
	  Get get basic type bits ( 'TYPE_BASE_MASK' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.get_c_header_path():
	
	  get_c_header_path() -> ssize_t
	
	
	  Get the include directory path of the target compiler.
	  

ida_typeinf.get_c_macros():
	
	  get_c_macros() -> ssize_t
	
	
	  Get predefined macros for the target compiler.
	  

ida_typeinf.get_comp():
	
	  get_comp(comp) -> comp_t
	
	
	  Get compiler bits.
	  
	  
	  @param comp (C++: comp_t)
	  

ida_typeinf.get_compiler_abbr():
	
	  get_compiler_abbr(id) -> char const *
	
	
	  Get abbreviated compiler name.
	  
	  
	  @param id (C++: comp_t)
	  

ida_typeinf.get_compiler_name():
	
	  get_compiler_name(id) -> char const *
	
	
	  Get full compiler name.
	  
	  
	  @param id (C++: comp_t)
	  

ida_typeinf.get_compilers():
	
	  get_compilers(ids, names, abbrs)
	
	
	  Get names of all built-in compilers.
	  
	  
	  @param ids (C++: compvec_t  *)
	  @param names (C++: qstrvec_t  *)
	  @param abbrs (C++: qstrvec_t  *)
	  

ida_typeinf.get_enum_member_expr():
	
	  get_enum_member_expr(tif, serial, value) -> bool
	
	
	  Return a C expression that can be used to represent an enum member. If
	  the value does not correspond to any single enum member, this function
	  tries to find a bitwise combination of enum members that correspond to
	  it. If more than half of value bits do not match any enum members, it
	  fails.
	  
	  @param tif: enumeration type (C++: const  tinfo_t  &)
	  @param serial: which enumeration member to use (0 means the first with
	                 the given value) (C++: int)
	  @param value: value to search in the enumeration type. only 32-bit
	                number can be handled yet (C++: uint64)
	  @return: success
	  

ida_typeinf.get_full_type():
	
	  get_full_type(t) -> type_t
	
	
	  Get basic type bits + type flags ( 'TYPE_FULL_MASK' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.get_idainfo_by_type():
	
	  get_idainfo_by_type(tif) -> bool
	
	
	  Extract information from a 'tinfo_t' .
	  
	  @param tif: the type to inspect (C++: const  tinfo_t  &)
	  

ida_typeinf.get_idati():
	
	  get_idati() -> til_t
	
	
	  Pointer to the local type library - this til is private for each IDB
	  file Function that accepts til_t* uses local type library instead of
	  NULL.
	  

ida_typeinf.get_named_type():
	
	  get_named_type(til, name, ntf_flags) -> PyObject *
	
	
	  Get a type data by its name.
	  @param til: the type library
	  @param name: the type name
	  @param ntf_flags: a combination of NTF_* constants
	  @return:
	      None on failure
	      tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success
	  

ida_typeinf.get_named_type64():
	
	  get_named_type64(til, name, ntf_flags) -> PyObject *
	
	
	  See 'get_named_type()' above.If the value in the 'ti' library is
	  32-bit, it will be sign-extended before being stored in the 'value'
	  pointer.
	  
	  @param name (C++: const char *)
	  @param ntf_flags (C++: int)
	  

ida_typeinf.get_numbered_type():
	
	  get_numbered_type(til, ordinal) -> PyObject *
	
	
	  Retrieve a type by its ordinal number.
	  
	  
	  @param ordinal (C++: uint32)
	  

ida_typeinf.get_numbered_type_name():
	
	  get_numbered_type_name(ti, ordinal) -> char const *
	
	
	  Get type name (if exists) by its ordinal. If the type is anonymous,
	  returns "". If failed, returns NULL
	  
	  @param ti (C++: const  til_t  *)
	  @param ordinal (C++: uint32)
	  

ida_typeinf.get_ordinal_from_idb_type():
	
	  get_ordinal_from_idb_type(name, type) -> int
	
	
	  Get ordinal number of an idb type (struct/enum). The 'type' parameter
	  is used only to determine the kind of the type (struct or enum) Use
	  this function to find out the correspondence between idb types and til
	  types
	  
	  @param name (C++: const char *)
	  @param type (C++: const  type_t  *)
	  

ida_typeinf.get_ordinal_qty():
	
	  get_ordinal_qty(ti) -> uint32
	
	
	  Get number of allocated ordinals.
	  
	  @param ti (C++: const  til_t  *)
	  @return: uint32(-1) if failed
	  

ida_typeinf.get_scalar_bt():
	
	  get_scalar_bt(size) -> type_t
	  

ida_typeinf.get_stock_tinfo():
	
	  get_stock_tinfo(tif, id) -> bool
	  

ida_typeinf.get_tinfo_attr():
	
	  get_tinfo_attr(typid, key, bv, all_attrs) -> bool
	  

ida_typeinf.get_tinfo_attrs():
	
	  get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool
	  

ida_typeinf.get_tinfo_details():
	
	  get_tinfo_details(typid, bt2, buf) -> bool
	  

ida_typeinf.get_tinfo_pdata():
	
	  get_tinfo_pdata(outptr, typid, what) -> size_t
	  

ida_typeinf.get_tinfo_property():
	
	  get_tinfo_property(typid, gta_prop) -> size_t
	  

ida_typeinf.get_tinfo_size():
	
	  get_tinfo_size(p_effalign, typid, gts_code) -> size_t
	  

ida_typeinf.get_type_flags():
	
	  get_type_flags(t) -> type_t
	
	
	  Get type flags ( 'TYPE_FLAGS_MASK' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.get_type_ordinal():
	
	  get_type_ordinal(ti, name) -> int32
	
	
	  Get type ordinal by its name.
	  
	  
	  @param ti (C++: const  til_t  *)
	  @param name (C++: const char *)
	  

ida_typeinf.guess_func_cc():
	
	  guess_func_cc(fti, npurged, cc_flags) -> cm_t
	
	
	  Use 'func_type_data_t::guess_cc()'
	  
	  
	  @param fti (C++: const  func_type_data_t  &)
	  @param npurged (C++: int)
	  @param cc_flags (C++: int)
	  

ida_typeinf.guess_tinfo():
	
	  guess_tinfo(tif, id) -> int
	
	
	  Generate a type information about the id from the disassembly. id can
	  be a structure/union/enum id or an address.
	  
	  @param tif (C++: tinfo_t  *)
	  @param id (C++: tid_t)
	  @return: one of  Guess tinfo codes
	  

class ida_typeinf.ida_lowertype_helper_t():
	
	    Proxy of C++ ida_lowertype_helper_t class
	    

ida_typeinf.ida_lowertype_helper_t.func_has_stkframe_hole():
	
	        func_has_stkframe_hole(self, candidate, candidate_data) -> bool
	        

ida_typeinf.ida_lowertype_helper_t.get_func_purged_bytes():
	
	        get_func_purged_bytes(self, candidate, arg3) -> int
	        

ida_typeinf.idc_get_local_type():
	
	  idc_get_local_type(ordinal, flags, buf, maxsize) -> int
	  

ida_typeinf.idc_get_local_type_name():
	
	  idc_get_local_type_name(ordinal) -> char
	  

ida_typeinf.idc_get_local_type_raw():
	
	  idc_get_local_type_raw(ordinal) -> PyObject *
	  

ida_typeinf.idc_get_type():
	
	  idc_get_type(ea) -> char *
	  

ida_typeinf.idc_get_type_raw():
	
	  idc_get_type_raw(ea) -> PyObject *
	  

ida_typeinf.idc_guess_type():
	
	  idc_guess_type(ea) -> char *
	  

ida_typeinf.idc_parse_decl():
	
	  idc_parse_decl(ti, decl, flags) -> PyObject *
	  

ida_typeinf.idc_parse_types():
	
	  idc_parse_types(input, flags) -> int
	  

ida_typeinf.idc_print_type():
	
	  idc_print_type(py_type, py_fields, name, flags) -> PyObject *
	  

ida_typeinf.idc_set_local_type():
	
	  idc_set_local_type(ordinal, dcl, flags) -> int
	  

ida_typeinf.import_type():
	
	  import_type(til, idx, name, flags=0) -> tid_t
	
	
	  Copy a named type from til to idb.
	  
	  @param til: type library (C++: const  til_t  *)
	  @param idx: the position of the new type in the list of types
	              (structures or enums). -1 means at the end of the list
	              (C++: int)
	  @param name: the type name (C++: const char *)
	  @param flags: combination of  Import type flags (C++: int)
	  @return: BADNODE  on error
	  

ida_typeinf.is_autosync():
	
	    is_autosync(name, type) -> bool
	    is_autosync(name, tif) -> bool
	
	
	  Is the specified idb type automatically synchronized?
	  
	  
	  @param name (C++: const char *)
	  @param type (C++: const  type_t  *)
	    

ida_typeinf.is_code_far():
	
	  is_code_far(cm) -> bool
	
	
	  Does the given model specify far code?.
	  
	  
	  @param cm (C++: cm_t)
	  

ida_typeinf.is_comp_unsure():
	
	  is_comp_unsure(comp) -> comp_t
	
	
	  See 'COMP_UNSURE' .
	  
	  
	  @param comp (C++: comp_t)
	  

ida_typeinf.is_data_far():
	
	  is_data_far(cm) -> bool
	
	
	  Does the given model specify far data?.
	  
	  
	  @param cm (C++: cm_t)
	  

ida_typeinf.is_gcc():
	
	  is_gcc() -> bool
	
	
	  Is the target compiler 'COMP_GNU' ?
	  

ida_typeinf.is_gcc32():
	
	  is_gcc32() -> bool
	
	
	  Is the target compiler 32 bit gcc?
	  

ida_typeinf.is_gcc64():
	
	  is_gcc64() -> bool
	
	
	  Is the target compiler 64 bit gcc?
	  

ida_typeinf.is_ordinal_name():
	
	  is_ordinal_name(name, ord=None) -> bool
	
	
	  Check if the name is an ordinal name. Ordinal names have the following
	  format: '#' + set_de(ord)
	  
	  @param name (C++: const char *)
	  @param ord (C++: uint32  *)
	  

ida_typeinf.is_purging_cc():
	
	  is_purging_cc(cm) -> bool
	
	
	  Does the calling convention clean the stack arguments upon
	  return?.this function is valid only for x86 code
	  
	  @param cm (C++: cm_t)
	  

ida_typeinf.is_restype_enum():
	
	  is_restype_enum(til, type) -> bool
	  

ida_typeinf.is_restype_struct():
	
	  is_restype_struct(til, type) -> bool
	  

ida_typeinf.is_restype_struni():
	
	  is_restype_struni(til, type) -> bool
	  

ida_typeinf.is_restype_void():
	
	  is_restype_void(til, type) -> bool
	  

ida_typeinf.is_sdacl_byte():
	
	  is_sdacl_byte(t) -> bool
	
	
	  Identify an sdacl byte. The first sdacl byte has the following format:
	  11xx000x. The sdacl bytes are appended to udt fields. They indicate
	  the start of type attributes (as the tah-bytes do). The sdacl bytes
	  are used in the udt headers instead of the tah-byte. This is done for
	  compatibility with old databases, they were already using sdacl bytes
	  in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in
	  the type bit definitions)
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_tah_byte():
	
	  is_tah_byte(t) -> bool
	
	
	  The TAH byte (type attribute header byte) denotes the start of type
	  attributes. (see "tah-typeattrs" in the type bit definitions)
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_arithmetic():
	
	  is_type_arithmetic(t) -> bool
	
	
	  Is the type an arithmetic type? (floating or integral)
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_array():
	
	  is_type_array(t) -> bool
	
	
	  See 'BT_ARRAY' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_bitfld():
	
	  is_type_bitfld(t) -> bool
	
	
	  See 'BT_BITFIELD' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_bool():
	
	  is_type_bool(t) -> bool
	
	
	  See 'BTF_BOOL' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_char():
	
	  is_type_char(t) -> bool
	
	
	  Does the type specify a char value? (signed or unsigned, see 'Basic
	  type: integer' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_complex():
	
	  is_type_complex(t) -> bool
	
	
	  See 'BT_COMPLEX' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_const():
	
	  is_type_const(t) -> bool
	
	
	  See 'BTM_CONST' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_double():
	
	  is_type_double(t) -> bool
	
	
	  See 'BTF_DOUBLE' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_enum():
	
	  is_type_enum(t) -> bool
	
	
	  See 'BTF_ENUM' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_ext_arithmetic():
	
	  is_type_ext_arithmetic(t) -> bool
	
	
	  Is the type an extended arithmetic type? (arithmetic or enum)
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_ext_integral():
	
	  is_type_ext_integral(t) -> bool
	
	
	  Is the type an extended integral type? (integral or enum)
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_float():
	
	  is_type_float(t) -> bool
	
	
	  See 'BTF_FLOAT' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_floating():
	
	  is_type_floating(t) -> bool
	
	
	  Is the type a floating point type?
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_func():
	
	  is_type_func(t) -> bool
	
	
	  See 'BT_FUNC' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_int():
	
	  is_type_int(bt) -> bool
	
	
	  Does the type_t specify one of the basic types in 'Basic type:
	  integer' ?
	  
	  
	  @param bt (C++: type_t)
	  

ida_typeinf.is_type_int128():
	
	  is_type_int128(t) -> bool
	
	
	  Does the type specify a 128-bit value? (signed or unsigned, see 'Basic
	  type: integer' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_int16():
	
	  is_type_int16(t) -> bool
	
	
	  Does the type specify a 16-bit value? (signed or unsigned, see 'Basic
	  type: integer' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_int32():
	
	  is_type_int32(t) -> bool
	
	
	  Does the type specify a 32-bit value? (signed or unsigned, see 'Basic
	  type: integer' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_int64():
	
	  is_type_int64(t) -> bool
	
	
	  Does the type specify a 64-bit value? (signed or unsigned, see 'Basic
	  type: integer' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_integral():
	
	  is_type_integral(t) -> bool
	
	
	  Is the type an integral type (char/short/int/long/bool)?
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_ldouble():
	
	  is_type_ldouble(t) -> bool
	
	
	  See 'BTF_LDOUBLE' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_paf():
	
	  is_type_paf(t) -> bool
	
	
	  Is the type a pointer, array, or function type?
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_partial():
	
	  is_type_partial(t) -> bool
	
	
	  Identifies an unknown or void type with a known size (see 'Basic type:
	  unknown & void' )
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_ptr():
	
	  is_type_ptr(t) -> bool
	
	
	  See 'BT_PTR' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_ptr_or_array():
	
	  is_type_ptr_or_array(t) -> bool
	
	
	  Is the type a pointer or array type?
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_struct():
	
	  is_type_struct(t) -> bool
	
	
	  See 'BTF_STRUCT' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_struni():
	
	  is_type_struni(t) -> bool
	
	
	  Is the type a struct or union?
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_sue():
	
	  is_type_sue(t) -> bool
	
	
	  Is the type a struct/union/enum?
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_tbyte():
	
	  is_type_tbyte(t) -> bool
	
	
	  See 'BTF_FLOAT' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_typedef():
	
	  is_type_typedef(t) -> bool
	
	
	  See 'BTF_TYPEDEF' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_uchar():
	
	  is_type_uchar(t) -> bool
	
	
	  See 'BTF_UCHAR' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_uint():
	
	  is_type_uint(t) -> bool
	
	
	  See 'BTF_UINT' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_uint128():
	
	  is_type_uint128(t) -> bool
	
	
	  See 'BTF_UINT128' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_uint16():
	
	  is_type_uint16(t) -> bool
	
	
	  See 'BTF_UINT16' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_uint32():
	
	  is_type_uint32(t) -> bool
	
	
	  See 'BTF_UINT32' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_uint64():
	
	  is_type_uint64(t) -> bool
	
	
	  See 'BTF_UINT64' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_union():
	
	  is_type_union(t) -> bool
	
	
	  See 'BTF_UNION' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_unknown():
	
	  is_type_unknown(t) -> bool
	
	
	  See 'BT_UNKNOWN' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_void():
	
	  is_type_void(t) -> bool
	
	
	  See 'BTF_VOID' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_type_volatile():
	
	  is_type_volatile(t) -> bool
	
	
	  See 'BTM_VOLATILE' .
	  
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_typeid_last():
	
	  is_typeid_last(t) -> bool
	
	
	  Is the type_t the last byte of type declaration? (there are no
	  additional bytes after a basic type, see '_BT_LAST_BASIC' )
	  
	  @param t (C++: type_t)
	  

ida_typeinf.is_user_cc():
	
	  is_user_cc(cm) -> bool
	
	
	  Does the calling convention specify argument locations explicitly?
	  
	  
	  @param cm (C++: cm_t)
	  

ida_typeinf.is_vararg_cc():
	
	  is_vararg_cc(cm) -> bool
	
	
	  Does the calling convention use ellipsis?
	  
	  
	  @param cm (C++: cm_t)
	  

ida_typeinf.lexcompare_tinfo():
	
	  lexcompare_tinfo(t1, t2, arg3) -> int
	  

ida_typeinf.load_til():
	
	  load_til(name, tildir) -> til_t
	
	
	  Load til from a file. Failure to load base tils are reported into
	  'errbuf'. They do not prevent loading of the main til.
	  
	  @param name: filename of the til. If it's an absolute path, tildir is
	               ignored.   NB: the file extension is forced to .til (C++:
	               const char *)
	  @param tildir: directory where to load the til from. NULL means
	                 default til subdirectories. (C++: const char *)
	  @return: pointer to resulting til, NULL if failed and error message is
	           in errbuf
	  

ida_typeinf.load_til_header():
	
	  load_til_header(tildir, name) -> til_t
	
	
	  Get human-readable til description.
	  
	  
	  @param tildir (C++: const char *)
	  @param name (C++: const char *)
	  

ida_typeinf.lower_type():
	
	  lower_type(til, tif, name=None, _helper=None) -> int
	
	
	  Lower type. Inspect the type and lower all function subtypes using
	  lower_func_type().We call the prototypes usually encountered in source
	  files "high level"They may have implicit arguments, array arguments,
	  big structure retvals, etcWe introduce explicit arguments (i.e. 'this'
	  pointer) and call the result"low level prototype". See 'FTI_HIGH' .In
	  order to improve heuristics for recognition of big structure
	  retvals,it is recommended to pass a helper that will be used to make
	  decisions.That helper will be used only for lowering 'tif', and not
	  for the childrentypes walked through by recursion.
	  
	  @param til (C++: til_t  *)
	  @param tif (C++: tinfo_t  *)
	  @param name (C++: const char *)
	  @param _helper (C++: lowertype_helper_t  *)
	  

class ida_typeinf.lowertype_helper_t():
	
	    Proxy of C++ lowertype_helper_t class
	    

ida_typeinf.lowertype_helper_t.func_has_stkframe_hole():
	
	        func_has_stkframe_hole(self, candidate, candidate_data) -> bool
	        

ida_typeinf.lowertype_helper_t.get_func_purged_bytes():
	
	        get_func_purged_bytes(self, candidate, candidate_data) -> int
	        

ida_typeinf.new_til():
	
	  new_til(name, desc) -> til_t
	
	
	  Initialize a til.
	  
	  
	  @param name (C++: const char *)
	  @param desc (C++: const char *)
	  

ida_typeinf.next_named_type():
	
	  next_named_type(ti, name, ntf_flags) -> char const *
	
	
	  Enumerate types. Returns mangled names. Never returns anonymous types.
	  To include it, enumerate types by ordinals.
	  
	  @param ti (C++: const  til_t  *)
	  @param name (C++: const char *)
	  @param ntf_flags (C++: int)
	  

ida_typeinf.optimize_argloc():
	
	  optimize_argloc(vloc, size, gaps) -> bool
	
	
	  Verify and optimize scattered argloc into simple form. All new arglocs
	  must be processed by this function.
	  
	  @param vloc (C++: argloc_t  *)
	  @param size (C++: int)
	  @param gaps (C++: const  rangeset_t  *)
	  

ida_typeinf.pack_idcobj_to_bv():
	
	  pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t
	
	
	  Write a typed idc object to the byte vector. Byte vector may be non-
	  empty, this function will append data to it
	  
	  @param obj (C++: const  idc_value_t  *)
	  @param tif (C++: const  tinfo_t  &)
	  @param bytes (C++: relobj_t  *)
	  @param objoff (C++: void *)
	  @param pio_flags (C++: int)
	  

ida_typeinf.pack_idcobj_to_idb():
	
	  pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t
	
	
	  Write a typed idc object to the database.
	  
	  
	  @param obj (C++: const  idc_value_t  *)
	  @param tif (C++: const  tinfo_t  &)
	  @param ea (C++: ea_t)
	  @param pio_flags (C++: int)
	  

ida_typeinf.pack_object_to_bv():
	
	  pack_object_to_bv(py_obj, ti, py_type, py_fields, base_ea, pio_flags=0) -> PyObject *
	
	
	  Packs a typed object to a string
	  @param ti: Type info. 'None' can be passed.
	  @param tp: type string
	  @param fields: fields string (may be empty or None)
	  @param base_ea: base ea used to relocate the pointers in the packed object
	  @param pio_flags: flags used while unpacking
	  @return:
	      tuple(0, err_code) on failure
	      tuple(1, packed_buf) on success
	  

ida_typeinf.pack_object_to_idb():
	
	  pack_object_to_idb(py_obj, ti, py_type, py_fields, ea, pio_flags=0) -> PyObject *
	
	
	  Write a typed object to the database.
	  Raises an exception if wrong parameters were passed or conversion fails
	  Returns the error_t returned by idaapi.pack_object_to_idb
	  @param ti: Type info. 'None' can be passed.
	  @param tp: type string
	  @param fields: fields string (may be empty or None)
	  @param ea: ea to be used while packing
	  @param pio_flags: flags used while unpacking
	  

ida_typeinf.parse_decl():
	
	  parse_decl(tif, til, decl, flags) -> bool
	
	
	  Parse ONE declaration. If the input string contains more than one
	  declaration, the first complete type declaration ( 'PT_TYP' ) or the
	  last variable declaration ( 'PT_VAR' ) will be used.name & tif may be
	  empty after the call!
	  
	  @param tif: type info (C++: tinfo_t  *)
	  @param til: type library to use. may be NULL (C++: til_t  *)
	  @param decl: C declaration to parse (C++: const char *)
	  @param flags: combination of  Type parsing flags  bits (C++: int)
	  

ida_typeinf.parse_decls():
	
	  parse_decls(til, input, printer, hti_flags) -> int
	
	
	  Parse many declarations and store them in a til. If there are any
	  errors, they will be printed using 'printer'. This function uses
	  default include path and predefined macros from the database settings.
	  It always uses the 'HTI_DCL' bit.
	  
	  @param til: type library to store the result (C++: til_t  *)
	  @param input: input string or file name (see hti_flags) (C++: const
	                char *)
	  @param printer: function to output error messages (use msg or NULL or
	                  your own callback) (C++: printer_t  *)
	  @param hti_flags: combination of  Type formatting flags (C++: int)
	  @return: number of errors, 0 means ok.
	  

class ida_typeinf.predicate_t():
	
	    Proxy of C++ predicate_t class
	    

ida_typeinf.predicate_t.should_display():
	
	        should_display(self, til, name, type, fields) -> bool
	        

ida_typeinf.print_argloc():
	
	  print_argloc(vloc, size=0, vflags=0) -> size_t
	
	
	  Convert an argloc to human readable form.
	  
	  
	  @param vloc (C++: const  argloc_t  &)
	  @param size (C++: int)
	  @param vflags (C++: int)
	  

ida_typeinf.print_decls():
	
	  print_decls(printer, til, py_ordinals, flags) -> int
	
	
	  Print types (and possibly their dependencies) in a format suitable for
	  use in a header file. This is the reverse 'parse_decls()' .
	  
	  @param printer: a handler for printing text (C++: text_sink_t  &)
	  @param til: the type library holding the ordinals (C++: til_t  *)
	  @param flags: flags for the algorithm. A combination of PDF_*
	                constants (C++: uint32)
	  

ida_typeinf.print_tinfo():
	
	  print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> bool
	  

ida_typeinf.print_type():
	
	  print_type(ea, prtype_flags) -> bool
	
	
	  Get type declaration for the specified address.
	  
	  @param ea: address (C++: ea_t)
	  @param prtype_flags: combination of  Type printing flags (C++: int)
	  @return: success
	  

class ida_typeinf.ptr_type_data_t():
	
	    Proxy of C++ ptr_type_data_t class
	    

ida_typeinf.ptr_type_data_t.based_ptr_size:
	ptr_type_data_t_based_ptr_size_get(self) -> uchar

ida_typeinf.ptr_type_data_t.closure:
	ptr_type_data_t_closure_get(self) -> tinfo_t

ida_typeinf.ptr_type_data_t.delta:
	ptr_type_data_t_delta_get(self) -> int32

ida_typeinf.ptr_type_data_t.is_code_ptr():
	
	        is_code_ptr(self) -> bool
	        

ida_typeinf.ptr_type_data_t.is_shifted():
	
	        is_shifted(self) -> bool
	        

ida_typeinf.ptr_type_data_t.obj_type:
	ptr_type_data_t_obj_type_get(self) -> tinfo_t

ida_typeinf.ptr_type_data_t.parent:
	ptr_type_data_t_parent_get(self) -> tinfo_t

ida_typeinf.ptr_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.ptr_type_data_t.taptr_bits:
	ptr_type_data_t_taptr_bits_get(self) -> uchar

ida_typeinf.read_tinfo_bitfield_value():
	
	  read_tinfo_bitfield_value(typid, v, bitoff) -> uint64
	  

class ida_typeinf.reginfovec_t():
	
	    Proxy of C++ qvector<(reg_info_t)> class
	    

ida_typeinf.reginfovec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_typeinf.reginfovec_t.at():
	
	        __getitem__(self, i) -> reg_info_t
	        

ida_typeinf.reginfovec_t.begin():
	
	        begin(self) -> reg_info_t
	        begin(self) -> reg_info_t
	        

ida_typeinf.reginfovec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_typeinf.reginfovec_t.clear():
	
	        clear(self)
	        

ida_typeinf.reginfovec_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.reginfovec_t.end():
	
	        end(self) -> reg_info_t
	        end(self) -> reg_info_t
	        

ida_typeinf.reginfovec_t.erase():
	
	        erase(self, it) -> reg_info_t
	        erase(self, first, last) -> reg_info_t
	        

ida_typeinf.reginfovec_t.extract():
	
	        extract(self) -> reg_info_t
	        

ida_typeinf.reginfovec_t.find():
	
	        find(self, x) -> reg_info_t
	        find(self, x) -> reg_info_t
	        

ida_typeinf.reginfovec_t.grow():
	
	        grow(self, x=reg_info_t())
	        

ida_typeinf.reginfovec_t.has():
	
	        has(self, x) -> bool
	        

ida_typeinf.reginfovec_t.inject():
	
	        inject(self, s, len)
	        

ida_typeinf.reginfovec_t.insert():
	
	        insert(self, it, x) -> reg_info_t
	        

ida_typeinf.reginfovec_t.pop_back():
	
	        pop_back(self)
	        

ida_typeinf.reginfovec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> reg_info_t
	        

ida_typeinf.reginfovec_t.qclear():
	
	        qclear(self)
	        

ida_typeinf.reginfovec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_typeinf.reginfovec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_typeinf.reginfovec_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.reginfovec_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.reginfovec_t.truncate():
	
	        truncate(self)
	        

class ida_typeinf.regobj_t():
	
	    Proxy of C++ regobj_t class
	    

ida_typeinf.regobj_t.regidx:
	regobj_t_regidx_get(self) -> int

ida_typeinf.regobj_t.relocate:
	regobj_t_relocate_get(self) -> int

ida_typeinf.regobj_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.regobj_t.value:
	regobj_t_value_get(self) -> bytevec_t *

class ida_typeinf.regobjs_t():
	
	    Proxy of C++ regobjs_t class
	    

ida_typeinf.remove_abi_opts():
	
	  remove_abi_opts(abi_opts, user_level=False) -> bool
	  

ida_typeinf.remove_pointer():
	
	  remove_pointer(tif) -> tinfo_t
	
	
	   'BT_PTR' : If the current type is a pointer, return the pointed
	  object. If the current type is not a pointer, return the current type.
	  See also get_ptrarr_object() and get_pointed_object()
	  
	  @param tif (C++: const  tinfo_t  &)
	  

ida_typeinf.remove_tinfo_pointer():
	
	  remove_tinfo_pointer(tif, name, til) -> PyObject *
	
	
	  Remove pointer of a type. (i.e. convert "char *" into "char").
	  Optionally remove the "lp" (or similar) prefix of the input name. If
	  the input type is not a pointer, then fail.
	  
	  @param tif (C++: tinfo_t  *)
	  @param til (C++: const  til_t  *)
	  

ida_typeinf.replace_ordinal_typerefs():
	
	  replace_ordinal_typerefs(til, tif) -> int
	
	
	  Replace references to ordinal types by name references. This function
	  'unties' the type from the current local type library and makes it
	  easier to export it.
	  
	  @param til: type library to use. may be NULL. (C++: til_t  *)
	  @param tif: type to modify (in/out) (C++: tinfo_t  *)
	  

ida_typeinf.resolve_typedef():
	
	  resolve_typedef(til, type) -> type_t const *
	  

class ida_typeinf.rrel_t():
	
	    Proxy of C++ rrel_t class
	    

ida_typeinf.rrel_t.off:
	rrel_t_off_get(self) -> sval_t

ida_typeinf.rrel_t.reg:
	rrel_t_reg_get(self) -> int

ida_typeinf.save_tinfo():
	
	  save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t
	  

class ida_typeinf.scattered_aloc_t():
	
	    Proxy of C++ scattered_aloc_t class
	    

ida_typeinf.score_tinfo():
	
	  score_tinfo(tif) -> uint32
	  

ida_typeinf.serialize_tinfo():
	
	  serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool
	  

ida_typeinf.set_abi_name():
	
	  set_abi_name(abiname, user_level=False) -> bool
	
	
	  Set abi name (see 'Compiler IDs' )
	  
	  
	  @param abiname (C++: const char *)
	  @param user_level (C++: bool)
	  

ida_typeinf.set_c_header_path():
	
	  set_c_header_path(incdir)
	
	
	  Set include directory path the target compiler.
	  
	  
	  @param incdir (C++: const char *)
	  

ida_typeinf.set_c_macros():
	
	  set_c_macros(macros)
	
	
	  Set predefined macros for the target compiler.
	  
	  
	  @param macros (C++: const char *)
	  

ida_typeinf.set_compiler():
	
	  set_compiler(cc, flags, abiname=None) -> bool
	
	
	  Change current compiler.
	  
	  @param cc: compiler to switch to (C++: const  compiler_info_t  &)
	  @param flags: Set compiler flags (C++: int)
	  @param abiname: ABI name (C++: const char *)
	  @return: success
	  

ida_typeinf.set_compiler_id():
	
	  set_compiler_id(id, abiname=None) -> bool
	
	
	  Set the compiler id (see 'Compiler IDs' )
	  
	  
	  @param id (C++: comp_t)
	  @param abiname (C++: const char *)
	  

ida_typeinf.set_compiler_string():
	
	  set_compiler_string(compstr, user_level) -> bool
	  

ida_typeinf.set_numbered_type():
	
	  set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t
	
	
	  Store a type in the til. 'name' may be NULL for anonymous types. The
	  specified ordinal must be free (no other type is using it). For
	  ntf_flags, only 'NTF_REPLACE' is consulted.
	  
	  @param ti (C++: til_t  *)
	  @param ordinal (C++: uint32)
	  @param ntf_flags (C++: int)
	  @param name (C++: const char *)
	  @param type (C++: const  type_t  *)
	  @param fields (C++: const  p_list  *)
	  @param cmt (C++: const char *)
	  @param fldcmts (C++: const  p_list  *)
	  @param sclass (C++: const  sclass_t  *)
	  

ida_typeinf.set_tinfo_attr():
	
	  set_tinfo_attr(tif, ta, may_overwrite) -> bool
	  

ida_typeinf.set_tinfo_attrs():
	
	  set_tinfo_attrs(tif, ta) -> bool
	  

ida_typeinf.set_tinfo_property():
	
	  set_tinfo_property(tif, sta_prop, x) -> size_t
	  

ida_typeinf.set_type_alias():
	
	  set_type_alias(ti, src_ordinal, dst_ordinal) -> bool
	
	
	  Create a type alias. Redirects all references to source type to the
	  destination type. This is equivalent to instantaneous replacement all
	  reference to srctype by dsttype.
	  
	  @param ti (C++: til_t  *)
	  @param src_ordinal (C++: uint32)
	  @param dst_ordinal (C++: uint32)
	  

class ida_typeinf.simd_info_t():
	
	    Proxy of C++ simd_info_t class
	    

ida_typeinf.simd_info_t.match_pattern():
	
	        match_pattern(self, pattern) -> bool
	        

ida_typeinf.simd_info_t.memtype:
	simd_info_t_memtype_get(self) -> type_t

ida_typeinf.simd_info_t.name:
	simd_info_t_name_get(self) -> char const *

ida_typeinf.simd_info_t.size:
	simd_info_t_size_get(self) -> uint16

ida_typeinf.simd_info_t.tif:
	simd_info_t_tif_get(self) -> tinfo_t

ida_typeinf.store_til():
	
	  store_til(ti, tildir, name) -> bool
	
	
	  Store til to a file. If the til contains garbage, it will be collected
	  before storing the til. Your plugin should call 'compact_til()' before
	  calling 'store_til()' .
	  
	  @param ti: type library to store (C++: til_t  *)
	  @param tildir: directory where to store the til. NULL means current
	                 directory. (C++: const char *)
	  @param name: filename of the til. If it's an absolute path, tildir is
	               ignored.   NB: the file extension is forced to .til (C++:
	               const char *)
	  @return: success
	  

class ida_typeinf.text_sink_t():
	
	    Proxy of C++ text_sink_t class
	    

ida_typeinf.text_sink_t._print():
	
	        _print(self, str) -> int
	        

class ida_typeinf.til_symbol_t():
	
	    Proxy of C++ til_symbol_t class
	    

ida_typeinf.til_symbol_t.name:
	til_symbol_t_name_get(self) -> char const *

ida_typeinf.til_symbol_t.til:
	til_symbol_t_til_get(self) -> til_t

class ida_typeinf.til_t():
	
	    Proxy of C++ til_t class
	    

ida_typeinf.til_t.base():
	
	        base(self, n) -> til_t
	        

ida_typeinf.til_t.cc:
	til_t_cc_get(self) -> compiler_info_t

ida_typeinf.til_t.desc:
	til_t_desc_get(self) -> char *

ida_typeinf.til_t.flags:
	til_t_flags_get(self) -> uint32

ida_typeinf.til_t.is_dirty():
	
	        is_dirty(self) -> bool
	        

ida_typeinf.til_t.name:
	til_t_name_get(self) -> char *

ida_typeinf.til_t.nbases:
	til_t_nbases_get(self) -> int

ida_typeinf.til_t.nrefs:
	til_t_nrefs_get(self) -> int

ida_typeinf.til_t.nstreams:
	til_t_nstreams_get(self) -> int

ida_typeinf.til_t.set_dirty():
	
	        set_dirty(self)
	        

ida_typeinf.til_t.streams:
	til_t_streams_get(self) -> til_stream_t **

class ida_typeinf.tinfo_t():
	
	    Proxy of C++ tinfo_t class
	    

ida_typeinf.tinfo_t._print():
	
	        _print(self, name=None, prtype_flags=0x0000, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
	        

ida_typeinf.tinfo_t.append_covered():
	
	        append_covered(self, out, offset=0) -> bool
	        

ida_typeinf.tinfo_t.calc_gaps():
	
	        calc_gaps(self, out) -> bool
	        

ida_typeinf.tinfo_t.calc_purged_bytes():
	
	        calc_purged_bytes(self) -> int
	        

ida_typeinf.tinfo_t.calc_score():
	
	        calc_score(self) -> uint32
	        

ida_typeinf.tinfo_t.calc_udt_aligns():
	
	        calc_udt_aligns(self, sudt_flags=0x0004) -> bool
	        

ida_typeinf.tinfo_t.change_sign():
	
	        change_sign(self, sign) -> bool
	        

ida_typeinf.tinfo_t.clear():
	
	        clear(self)
	        

ida_typeinf.tinfo_t.clr_const():
	
	        clr_const(self)
	        

ida_typeinf.tinfo_t.clr_const_volatile():
	
	        clr_const_volatile(self)
	        

ida_typeinf.tinfo_t.clr_volatile():
	
	        clr_volatile(self)
	        

ida_typeinf.tinfo_t.compare():
	
	        compare(self, r) -> int
	        

ida_typeinf.tinfo_t.compare_with():
	
	        compare_with(self, r, tcflags=0) -> bool
	        

ida_typeinf.tinfo_t.convert_array_to_ptr():
	
	        convert_array_to_ptr(self) -> bool
	        

ida_typeinf.tinfo_t.create_array():
	
	        create_array(self, p, decl_type=BT_ARRAY) -> bool
	        create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
	        

ida_typeinf.tinfo_t.create_bitfield():
	
	        create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
	        create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
	        

ida_typeinf.tinfo_t.create_enum():
	
	        create_enum(self, p, decl_type=BTF_ENUM) -> bool
	        

ida_typeinf.tinfo_t.create_forward_decl():
	
	        create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
	        

ida_typeinf.tinfo_t.create_func():
	
	        create_func(self, p, decl_type=BT_FUNC) -> bool
	        

ida_typeinf.tinfo_t.create_ptr():
	
	        create_ptr(self, p, decl_type=BT_PTR) -> bool
	        create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
	        

ida_typeinf.tinfo_t.create_simple_type():
	
	        create_simple_type(self, decl_type) -> bool
	        

ida_typeinf.tinfo_t.create_typedef():
	
	        create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
	        create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
	        create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
	        

ida_typeinf.tinfo_t.create_udt():
	
	        create_udt(self, p, decl_type) -> bool
	        

ida_typeinf.tinfo_t.del_attr():
	
	        del_attr(self, key, make_copy=True) -> bool
	        

ida_typeinf.tinfo_t.del_attrs():
	
	        del_attrs(self)
	        

ida_typeinf.tinfo_t.deserialize():
	
	        deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
	        deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
	        deserialize(self, til, type, fields, cmts=None) -> bool
	        

ida_typeinf.tinfo_t.dstr():
	
	        dstr(self) -> char const *
	        

ida_typeinf.tinfo_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.tinfo_t.equals_to():
	
	        equals_to(self, r) -> bool
	        

ida_typeinf.tinfo_t.find_udt_member():
	
	        find_udt_member(self, udm, strmem_flags) -> int
	        

ida_typeinf.tinfo_t.get_array_details():
	
	        get_array_details(self, ai) -> bool
	        

ida_typeinf.tinfo_t.get_array_element():
	
	        get_array_element(self) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_array_nelems():
	
	        get_array_nelems(self) -> int
	        

ida_typeinf.tinfo_t.get_attr():
	
	        get_attr(self, key, all_attrs=True) -> PyObject *
	        

ida_typeinf.tinfo_t.get_attrs():
	
	        get_attrs(self, tav, all_attrs=False) -> bool
	        

ida_typeinf.tinfo_t.get_bitfield_details():
	
	        get_bitfield_details(self, bi) -> bool
	        

ida_typeinf.tinfo_t.get_declalign():
	
	        get_declalign(self) -> uchar
	        

ida_typeinf.tinfo_t.get_decltype():
	
	        get_decltype(self) -> type_t
	        

ida_typeinf.tinfo_t.get_enum_base_type():
	
	        get_enum_base_type(self) -> type_t
	        

ida_typeinf.tinfo_t.get_enum_details():
	
	        get_enum_details(self, ei) -> bool
	        

ida_typeinf.tinfo_t.get_final_ordinal():
	
	        get_final_ordinal(self) -> uint32
	        

ida_typeinf.tinfo_t.get_final_type_name():
	
	        get_final_type_name(self) -> bool
	        

ida_typeinf.tinfo_t.get_func_details():
	
	        get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
	        

ida_typeinf.tinfo_t.get_modifiers():
	
	        get_modifiers(self) -> type_t
	        

ida_typeinf.tinfo_t.get_named_type():
	
	        get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
	        

ida_typeinf.tinfo_t.get_nargs():
	
	        get_nargs(self) -> int
	        

ida_typeinf.tinfo_t.get_next_type_name():
	
	        get_next_type_name(self) -> bool
	        

ida_typeinf.tinfo_t.get_nth_arg():
	
	        get_nth_arg(self, n) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_numbered_type():
	
	        get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
	        

ida_typeinf.tinfo_t.get_onemember_type():
	
	        get_onemember_type(self) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_ordinal():
	
	        get_ordinal(self) -> uint32
	        

ida_typeinf.tinfo_t.get_pointed_object():
	
	        get_pointed_object(self) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_ptr_details():
	
	        get_ptr_details(self, pi) -> bool
	        

ida_typeinf.tinfo_t.get_ptrarr_object():
	
	        get_ptrarr_object(self) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_ptrarr_objsize():
	
	        get_ptrarr_objsize(self) -> int
	        

ida_typeinf.tinfo_t.get_realtype():
	
	        get_realtype(self, full=False) -> type_t
	        

ida_typeinf.tinfo_t.get_rettype():
	
	        get_rettype(self) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_sign():
	
	        get_sign(self) -> type_sign_t
	        

ida_typeinf.tinfo_t.get_size():
	
	        get_size(self, p_effalign=None, gts_code=0) -> size_t
	        

ida_typeinf.tinfo_t.get_stock():
	
	        get_stock(id) -> tinfo_t
	        

ida_typeinf.tinfo_t.get_til():
	
	        get_til(self) -> til_t
	        

ida_typeinf.tinfo_t.get_type_name():
	
	        get_type_name(self) -> bool
	        

ida_typeinf.tinfo_t.get_udt_details():
	
	        get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
	        

ida_typeinf.tinfo_t.get_udt_nmembers():
	
	        get_udt_nmembers(self) -> int
	        

ida_typeinf.tinfo_t.get_unpadded_size():
	
	        get_unpadded_size(self) -> size_t
	        

ida_typeinf.tinfo_t.has_details():
	
	        has_details(self) -> bool
	        

ida_typeinf.tinfo_t.has_vftable():
	
	        has_vftable(self) -> bool
	        

ida_typeinf.tinfo_t.is_anonymous_udt():
	
	        is_anonymous_udt(self) -> bool
	        

ida_typeinf.tinfo_t.is_arithmetic():
	
	        is_arithmetic(self) -> bool
	        

ida_typeinf.tinfo_t.is_array():
	
	        is_array(self) -> bool
	        

ida_typeinf.tinfo_t.is_bitfield():
	
	        is_bitfield(self) -> bool
	        

ida_typeinf.tinfo_t.is_bool():
	
	        is_bool(self) -> bool
	        

ida_typeinf.tinfo_t.is_castable_to():
	
	        is_castable_to(self, target) -> bool
	        

ida_typeinf.tinfo_t.is_char():
	
	        is_char(self) -> bool
	        

ida_typeinf.tinfo_t.is_complex():
	
	        is_complex(self) -> bool
	        

ida_typeinf.tinfo_t.is_const():
	
	        is_const(self) -> bool
	        

ida_typeinf.tinfo_t.is_correct():
	
	        is_correct(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_array():
	
	        is_decl_array(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_bitfield():
	
	        is_decl_bitfield(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_bool():
	
	        is_decl_bool(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_char():
	
	        is_decl_char(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_complex():
	
	        is_decl_complex(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_const():
	
	        is_decl_const(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_double():
	
	        is_decl_double(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_enum():
	
	        is_decl_enum(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_float():
	
	        is_decl_float(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_floating():
	
	        is_decl_floating(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_func():
	
	        is_decl_func(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_int():
	
	        is_decl_int(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_int128():
	
	        is_decl_int128(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_int16():
	
	        is_decl_int16(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_int32():
	
	        is_decl_int32(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_int64():
	
	        is_decl_int64(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_last():
	
	        is_decl_last(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_ldouble():
	
	        is_decl_ldouble(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_paf():
	
	        is_decl_paf(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_partial():
	
	        is_decl_partial(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_ptr():
	
	        is_decl_ptr(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_struct():
	
	        is_decl_struct(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_sue():
	
	        is_decl_sue(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_tbyte():
	
	        is_decl_tbyte(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_typedef():
	
	        is_decl_typedef(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_uchar():
	
	        is_decl_uchar(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_udt():
	
	        is_decl_udt(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_uint():
	
	        is_decl_uint(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_uint128():
	
	        is_decl_uint128(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_uint16():
	
	        is_decl_uint16(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_uint32():
	
	        is_decl_uint32(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_uint64():
	
	        is_decl_uint64(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_union():
	
	        is_decl_union(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_unknown():
	
	        is_decl_unknown(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_void():
	
	        is_decl_void(self) -> bool
	        

ida_typeinf.tinfo_t.is_decl_volatile():
	
	        is_decl_volatile(self) -> bool
	        

ida_typeinf.tinfo_t.is_double():
	
	        is_double(self) -> bool
	        

ida_typeinf.tinfo_t.is_empty_udt():
	
	        is_empty_udt(self) -> bool
	        

ida_typeinf.tinfo_t.is_enum():
	
	        is_enum(self) -> bool
	        

ida_typeinf.tinfo_t.is_ext_arithmetic():
	
	        is_ext_arithmetic(self) -> bool
	        

ida_typeinf.tinfo_t.is_ext_integral():
	
	        is_ext_integral(self) -> bool
	        

ida_typeinf.tinfo_t.is_float():
	
	        is_float(self) -> bool
	        

ida_typeinf.tinfo_t.is_floating():
	
	        is_floating(self) -> bool
	        

ida_typeinf.tinfo_t.is_forward_decl():
	
	        is_forward_decl(self) -> bool
	        

ida_typeinf.tinfo_t.is_from_subtil():
	
	        is_from_subtil(self) -> bool
	        

ida_typeinf.tinfo_t.is_func():
	
	        is_func(self) -> bool
	        

ida_typeinf.tinfo_t.is_funcptr():
	
	        is_funcptr(self) -> bool
	        

ida_typeinf.tinfo_t.is_high_func():
	
	        is_high_func(self) -> bool
	        

ida_typeinf.tinfo_t.is_int():
	
	        is_int(self) -> bool
	        

ida_typeinf.tinfo_t.is_int128():
	
	        is_int128(self) -> bool
	        

ida_typeinf.tinfo_t.is_int16():
	
	        is_int16(self) -> bool
	        

ida_typeinf.tinfo_t.is_int32():
	
	        is_int32(self) -> bool
	        

ida_typeinf.tinfo_t.is_int64():
	
	        is_int64(self) -> bool
	        

ida_typeinf.tinfo_t.is_integral():
	
	        is_integral(self) -> bool
	        

ida_typeinf.tinfo_t.is_ldouble():
	
	        is_ldouble(self) -> bool
	        

ida_typeinf.tinfo_t.is_manually_castable_to():
	
	        is_manually_castable_to(self, target) -> bool
	        

ida_typeinf.tinfo_t.is_one_fpval():
	
	        is_one_fpval(self) -> bool
	        

ida_typeinf.tinfo_t.is_paf():
	
	        is_paf(self) -> bool
	        

ida_typeinf.tinfo_t.is_partial():
	
	        is_partial(self) -> bool
	        

ida_typeinf.tinfo_t.is_ptr():
	
	        is_ptr(self) -> bool
	        

ida_typeinf.tinfo_t.is_ptr_or_array():
	
	        is_ptr_or_array(self) -> bool
	        

ida_typeinf.tinfo_t.is_purging_cc():
	
	        is_purging_cc(self) -> bool
	        

ida_typeinf.tinfo_t.is_pvoid():
	
	        is_pvoid(self) -> bool
	        

ida_typeinf.tinfo_t.is_scalar():
	
	        is_scalar(self) -> bool
	        

ida_typeinf.tinfo_t.is_shifted_ptr():
	
	        is_shifted_ptr(self) -> bool
	        

ida_typeinf.tinfo_t.is_signed():
	
	        is_signed(self) -> bool
	        

ida_typeinf.tinfo_t.is_small_udt():
	
	        is_small_udt(self) -> bool
	        

ida_typeinf.tinfo_t.is_sse_type():
	
	        is_sse_type(self) -> bool
	        

ida_typeinf.tinfo_t.is_struct():
	
	        is_struct(self) -> bool
	        

ida_typeinf.tinfo_t.is_sue():
	
	        is_sue(self) -> bool
	        

ida_typeinf.tinfo_t.is_tbyte():
	
	        is_tbyte(self) -> bool
	        

ida_typeinf.tinfo_t.is_typeref():
	
	        is_typeref(self) -> bool
	        

ida_typeinf.tinfo_t.is_uchar():
	
	        is_uchar(self) -> bool
	        

ida_typeinf.tinfo_t.is_udt():
	
	        is_udt(self) -> bool
	        

ida_typeinf.tinfo_t.is_uint():
	
	        is_uint(self) -> bool
	        

ida_typeinf.tinfo_t.is_uint128():
	
	        is_uint128(self) -> bool
	        

ida_typeinf.tinfo_t.is_uint16():
	
	        is_uint16(self) -> bool
	        

ida_typeinf.tinfo_t.is_uint32():
	
	        is_uint32(self) -> bool
	        

ida_typeinf.tinfo_t.is_uint64():
	
	        is_uint64(self) -> bool
	        

ida_typeinf.tinfo_t.is_union():
	
	        is_union(self) -> bool
	        

ida_typeinf.tinfo_t.is_unknown():
	
	        is_unknown(self) -> bool
	        

ida_typeinf.tinfo_t.is_unsigned():
	
	        is_unsigned(self) -> bool
	        

ida_typeinf.tinfo_t.is_user_cc():
	
	        is_user_cc(self) -> bool
	        

ida_typeinf.tinfo_t.is_vararg_cc():
	
	        is_vararg_cc(self) -> bool
	        

ida_typeinf.tinfo_t.is_vftable():
	
	        is_vftable(self) -> bool
	        

ida_typeinf.tinfo_t.is_void():
	
	        is_void(self) -> bool
	        

ida_typeinf.tinfo_t.is_volatile():
	
	        is_volatile(self) -> bool
	        

ida_typeinf.tinfo_t.is_well_defined():
	
	        is_well_defined(self) -> bool
	        

ida_typeinf.tinfo_t.present():
	
	        present(self) -> bool
	        

ida_typeinf.tinfo_t.read_bitfield_value():
	
	        read_bitfield_value(self, v, bitoff) -> uint64
	        

ida_typeinf.tinfo_t.remove_ptr_or_array():
	
	        remove_ptr_or_array(self) -> bool
	        

ida_typeinf.tinfo_t.requires_qualifier():
	
	        requires_qualifier(self, name, offset) -> bool
	        

ida_typeinf.tinfo_t.serialize():
	
	        serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> PyObject *
	        

ida_typeinf.tinfo_t.set_attr():
	
	        set_attr(self, ta, may_overwrite=True) -> bool
	        

ida_typeinf.tinfo_t.set_attrs():
	
	        set_attrs(self, tav) -> bool
	        

ida_typeinf.tinfo_t.set_const():
	
	        set_const(self)
	        

ida_typeinf.tinfo_t.set_declalign():
	
	        set_declalign(self, declalign) -> bool
	        

ida_typeinf.tinfo_t.set_modifiers():
	
	        set_modifiers(self, mod)
	        

ida_typeinf.tinfo_t.set_named_type():
	
	        set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
	        

ida_typeinf.tinfo_t.set_numbered_type():
	
	        set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
	        

ida_typeinf.tinfo_t.set_symbol_type():
	
	        set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
	        

ida_typeinf.tinfo_t.set_volatile():
	
	        set_volatile(self)
	        

ida_typeinf.tinfo_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.tinfo_t.write_bitfield_value():
	
	        write_bitfield_value(self, dst, v, bitoff) -> uint64
	        

ida_typeinf.tinfo_t_get_stock():
	
	  tinfo_t_get_stock(id) -> tinfo_t
	  

class ida_typeinf.tinfo_visitor_t():
	
	    Proxy of C++ tinfo_visitor_t class
	    

ida_typeinf.tinfo_visitor_t.apply_to():
	
	        apply_to(self, tif, out=None, name=None, cmt=None) -> int
	        

ida_typeinf.tinfo_visitor_t.prune_now():
	
	        prune_now(self)
	        

ida_typeinf.tinfo_visitor_t.state:
	tinfo_visitor_t_state_get(self) -> int

ida_typeinf.tinfo_visitor_t.visit_type():
	
	        visit_type(self, out, tif, name, cmt) -> int
	        

class ida_typeinf.type_attr_t():
	
	    Proxy of C++ type_attr_t class
	    

ida_typeinf.type_attr_t.key:
	type_attr_t_key_get(self) -> qstring *

ida_typeinf.type_attr_t.value:
	type_attr_t_value_get(self) -> bytevec_t *

class ida_typeinf.type_attrs_t():
	
	    Proxy of C++ qvector<(type_attr_t)> class
	    

ida_typeinf.type_attrs_t.at():
	
	        at(self, _idx) -> type_attr_t
	        

ida_typeinf.type_attrs_t.begin():
	
	        begin(self) -> type_attr_t
	        begin(self) -> type_attr_t
	        

ida_typeinf.type_attrs_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_typeinf.type_attrs_t.clear():
	
	        clear(self)
	        

ida_typeinf.type_attrs_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.type_attrs_t.end():
	
	        end(self) -> type_attr_t
	        end(self) -> type_attr_t
	        

ida_typeinf.type_attrs_t.erase():
	
	        erase(self, it) -> type_attr_t
	        erase(self, first, last) -> type_attr_t
	        

ida_typeinf.type_attrs_t.extract():
	
	        extract(self) -> type_attr_t
	        

ida_typeinf.type_attrs_t.grow():
	
	        grow(self, x=type_attr_t())
	        

ida_typeinf.type_attrs_t.inject():
	
	        inject(self, s, len)
	        

ida_typeinf.type_attrs_t.insert():
	
	        insert(self, it, x) -> type_attr_t
	        

ida_typeinf.type_attrs_t.pop_back():
	
	        pop_back(self)
	        

ida_typeinf.type_attrs_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> type_attr_t
	        

ida_typeinf.type_attrs_t.qclear():
	
	        qclear(self)
	        

ida_typeinf.type_attrs_t.reserve():
	
	        reserve(self, cnt)
	        

ida_typeinf.type_attrs_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_typeinf.type_attrs_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.type_attrs_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.type_attrs_t.truncate():
	
	        truncate(self)
	        

class ida_typeinf.type_mods_t():
	
	    Proxy of C++ type_mods_t class
	    

ida_typeinf.type_mods_t.clear():
	
	        clear(self)
	        

ida_typeinf.type_mods_t.cmt:
	type_mods_t_cmt_get(self) -> qstring *

ida_typeinf.type_mods_t.flags:
	type_mods_t_flags_get(self) -> int

ida_typeinf.type_mods_t.has_cmt():
	
	        has_cmt(self) -> bool
	        

ida_typeinf.type_mods_t.has_info():
	
	        has_info(self) -> bool
	        

ida_typeinf.type_mods_t.has_name():
	
	        has_name(self) -> bool
	        

ida_typeinf.type_mods_t.has_type():
	
	        has_type(self) -> bool
	        

ida_typeinf.type_mods_t.name:
	type_mods_t_name_get(self) -> qstring *

ida_typeinf.type_mods_t.set_new_cmt():
	
	        set_new_cmt(self, c)
	        

ida_typeinf.type_mods_t.set_new_name():
	
	        set_new_name(self, n)
	        

ida_typeinf.type_mods_t.set_new_type():
	
	        set_new_type(self, t)
	        

ida_typeinf.type_mods_t.type:
	type_mods_t_type_get(self) -> tinfo_t

class ida_typeinf.typedef_type_data_t():
	
	    Proxy of C++ typedef_type_data_t class
	    

ida_typeinf.typedef_type_data_t.is_ordref:
	typedef_type_data_t_is_ordref_get(self) -> bool

ida_typeinf.typedef_type_data_t.resolve:
	typedef_type_data_t_resolve_get(self) -> bool

ida_typeinf.typedef_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.typedef_type_data_t.til:
	typedef_type_data_t_til_get(self) -> til_t

class ida_typeinf.udt_member_t():
	
	    Proxy of C++ udt_member_t class
	    

ida_typeinf.udt_member_t.begin():
	
	        begin(self) -> uint64
	        

ida_typeinf.udt_member_t.clr_baseclass():
	
	        clr_baseclass(self)
	        

ida_typeinf.udt_member_t.clr_unaligned():
	
	        clr_unaligned(self)
	        

ida_typeinf.udt_member_t.clr_vftable():
	
	        clr_vftable(self)
	        

ida_typeinf.udt_member_t.clr_virtbase():
	
	        clr_virtbase(self)
	        

ida_typeinf.udt_member_t.cmt:
	udt_member_t_cmt_get(self) -> qstring *

ida_typeinf.udt_member_t.effalign:
	udt_member_t_effalign_get(self) -> int

ida_typeinf.udt_member_t.end():
	
	        end(self) -> uint64
	        

ida_typeinf.udt_member_t.fda:
	udt_member_t_fda_get(self) -> uchar

ida_typeinf.udt_member_t.is_anonymous_udm():
	
	        is_anonymous_udm(self) -> bool
	        

ida_typeinf.udt_member_t.is_baseclass():
	
	        is_baseclass(self) -> bool
	        

ida_typeinf.udt_member_t.is_bitfield():
	
	        is_bitfield(self) -> bool
	        

ida_typeinf.udt_member_t.is_unaligned():
	
	        is_unaligned(self) -> bool
	        

ida_typeinf.udt_member_t.is_vftable():
	
	        is_vftable(self) -> bool
	        

ida_typeinf.udt_member_t.is_virtbase():
	
	        is_virtbase(self) -> bool
	        

ida_typeinf.udt_member_t.is_zero_bitfield():
	
	        is_zero_bitfield(self) -> bool
	        

ida_typeinf.udt_member_t.name:
	udt_member_t_name_get(self) -> qstring *

ida_typeinf.udt_member_t.offset:
	udt_member_t_offset_get(self) -> uint64

ida_typeinf.udt_member_t.set_baseclass():
	
	        set_baseclass(self)
	        

ida_typeinf.udt_member_t.set_unaligned():
	
	        set_unaligned(self)
	        

ida_typeinf.udt_member_t.set_vftable():
	
	        set_vftable(self)
	        

ida_typeinf.udt_member_t.set_virtbase():
	
	        set_virtbase(self)
	        

ida_typeinf.udt_member_t.size:
	udt_member_t_size_get(self) -> uint64

ida_typeinf.udt_member_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.udt_member_t.tafld_bits:
	udt_member_t_tafld_bits_get(self) -> uint32

ida_typeinf.udt_member_t.type:
	udt_member_t_type_get(self) -> tinfo_t

class ida_typeinf.udt_type_data_t():
	
	    Proxy of C++ udt_type_data_t class
	    

ida_typeinf.udt_type_data_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_typeinf.udt_type_data_t.at():
	
	        at(self, _idx) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.begin():
	
	        begin(self) -> udt_member_t
	        begin(self) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_typeinf.udt_type_data_t.clear():
	
	        clear(self)
	        

ida_typeinf.udt_type_data_t.effalign:
	udt_type_data_t_effalign_get(self) -> uint32

ida_typeinf.udt_type_data_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.udt_type_data_t.end():
	
	        end(self) -> udt_member_t
	        end(self) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.erase():
	
	        erase(self, it) -> udt_member_t
	        erase(self, first, last) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.extract():
	
	        extract(self) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.find():
	
	        find(self, x) -> udt_member_t
	        find(self, x) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.grow():
	
	        grow(self, x=udt_member_t())
	        

ida_typeinf.udt_type_data_t.has():
	
	        has(self, x) -> bool
	        

ida_typeinf.udt_type_data_t.inject():
	
	        inject(self, s, len)
	        

ida_typeinf.udt_type_data_t.insert():
	
	        insert(self, it, x) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.is_cppobj():
	
	        is_cppobj(self) -> bool
	        

ida_typeinf.udt_type_data_t.is_last_baseclass():
	
	        is_last_baseclass(self, idx) -> bool
	        

ida_typeinf.udt_type_data_t.is_msstruct():
	
	        is_msstruct(self) -> bool
	        

ida_typeinf.udt_type_data_t.is_unaligned():
	
	        is_unaligned(self) -> bool
	        

ida_typeinf.udt_type_data_t.is_union:
	udt_type_data_t_is_union_get(self) -> bool

ida_typeinf.udt_type_data_t.is_vftable():
	
	        is_vftable(self) -> bool
	        

ida_typeinf.udt_type_data_t.pack:
	udt_type_data_t_pack_get(self) -> uchar

ida_typeinf.udt_type_data_t.pop_back():
	
	        pop_back(self)
	        

ida_typeinf.udt_type_data_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> udt_member_t
	        

ida_typeinf.udt_type_data_t.qclear():
	
	        qclear(self)
	        

ida_typeinf.udt_type_data_t.reserve():
	
	        reserve(self, cnt)
	        

ida_typeinf.udt_type_data_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_typeinf.udt_type_data_t.sda:
	udt_type_data_t_sda_get(self) -> uchar

ida_typeinf.udt_type_data_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.udt_type_data_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.udt_type_data_t.taudt_bits:
	udt_type_data_t_taudt_bits_get(self) -> uint32

ida_typeinf.udt_type_data_t.total_size:
	udt_type_data_t_total_size_get(self) -> size_t

ida_typeinf.udt_type_data_t.truncate():
	
	        truncate(self)
	        

ida_typeinf.udt_type_data_t.unpadded_size:
	udt_type_data_t_unpadded_size_get(self) -> size_t

class ida_typeinf.udtmembervec_t():
	
	    Proxy of C++ qvector<(udt_member_t)> class
	    

ida_typeinf.udtmembervec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_typeinf.udtmembervec_t.at():
	
	        at(self, _idx) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.begin():
	
	        begin(self) -> udt_member_t
	        begin(self) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_typeinf.udtmembervec_t.clear():
	
	        clear(self)
	        

ida_typeinf.udtmembervec_t.empty():
	
	        empty(self) -> bool
	        

ida_typeinf.udtmembervec_t.end():
	
	        end(self) -> udt_member_t
	        end(self) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.erase():
	
	        erase(self, it) -> udt_member_t
	        erase(self, first, last) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.extract():
	
	        extract(self) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.find():
	
	        find(self, x) -> udt_member_t
	        find(self, x) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.grow():
	
	        grow(self, x=udt_member_t())
	        

ida_typeinf.udtmembervec_t.has():
	
	        has(self, x) -> bool
	        

ida_typeinf.udtmembervec_t.inject():
	
	        inject(self, s, len)
	        

ida_typeinf.udtmembervec_t.insert():
	
	        insert(self, it, x) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.pop_back():
	
	        pop_back(self)
	        

ida_typeinf.udtmembervec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> udt_member_t
	        

ida_typeinf.udtmembervec_t.qclear():
	
	        qclear(self)
	        

ida_typeinf.udtmembervec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_typeinf.udtmembervec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_typeinf.udtmembervec_t.size():
	
	        size(self) -> size_t
	        

ida_typeinf.udtmembervec_t.swap():
	
	        swap(self, r)
	        

ida_typeinf.udtmembervec_t.truncate():
	
	        truncate(self)
	        

ida_typeinf.unpack_idcobj_from_bv():
	
	  unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t
	
	
	  Read a typed idc object from the byte vector.
	  
	  
	  @param obj (C++: idc_value_t  *)
	  @param tif (C++: const  tinfo_t  &)
	  @param bytes (C++: const  bytevec_t  &)
	  @param pio_flags (C++: int)
	  

ida_typeinf.unpack_idcobj_from_idb():
	
	  unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t
	
	
	  Read a typed idc object from the database.
	  
	  
	  @param obj (C++: idc_value_t  *)
	  @param tif (C++: const  tinfo_t  &)
	  @param ea (C++: ea_t)
	  @param off0 (C++: const  bytevec_t  *)
	  @param pio_flags (C++: int)
	  

ida_typeinf.unpack_object_from_bv():
	
	  unpack_object_from_bv(ti, py_type, py_fields, py_bytes, pio_flags=0) -> PyObject *
	
	
	  Unpacks a buffer into an object.
	  Returns the error_t returned by idaapi.pack_object_to_idb
	  @param ti: Type info. 'None' can be passed.
	  @param tp: type string
	  @param fields: fields string (may be empty or None)
	  @param bytes: the bytes to unpack
	  @param pio_flags: flags used while unpacking
	  @return:
	      - tuple(0, err) on failure
	      - tuple(1, obj) on success
	  

ida_typeinf.unpack_object_from_idb():
	
	  unpack_object_from_idb(ti, py_type, py_fields, ea, pio_flags=0) -> PyObject *
	  

class ida_typeinf.valstr_t():
	
	    Proxy of C++ valstr_t class
	    

ida_typeinf.valstr_t.info:
	valstr_t_info_get(self) -> valinfo_t *

ida_typeinf.valstr_t.length:
	valstr_t_length_get(self) -> size_t

ida_typeinf.valstr_t.members:
	valstr_t_members_get(self) -> valstrs_t

ida_typeinf.valstr_t.oneline:
	valstr_t_oneline_get(self) -> qstring *

ida_typeinf.valstr_t.props:
	valstr_t_props_get(self) -> int

class ida_typeinf.valstrs_t():
	
	    Proxy of C++ valstrs_t class
	    

ida_typeinf.verify_argloc():
	
	  verify_argloc(vloc, size, gaps) -> int
	
	
	  Verify 'argloc_t' .
	  
	  @param vloc (C++: const  argloc_t  &)
	  @param size: total size of the variable (C++: int)
	  @param gaps: if not NULL, specifies gaps in structure definition.
	               these gaps should not map to any argloc, but everything
	               else must be covered (C++: const  rangeset_t  *)
	  @return: 0 if ok, otherwise an interr code.
	  

ida_typeinf.verify_tinfo():
	
	  verify_tinfo(typid) -> int
	  

ida_typeinf.visit_subtypes():
	
	  visit_subtypes(visitor, out, tif, name, cmt) -> int
	  

ida_typeinf.write_tinfo_bitfield_value():
	
	  write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64
	  


=== ida_typeinf EPYDOC INJECTIONS ===
ida_typeinf.ADDTIL_COMP
"""
ok, but til is not compatible with the current compiler
"""

ida_typeinf.ADDTIL_DEFAULT
"""
default behavior
"""

ida_typeinf.ADDTIL_FAILED
"""
something bad, the warning is displayed
"""

ida_typeinf.ADDTIL_INCOMP
"""
load incompatible tils
"""

ida_typeinf.ADDTIL_OK
"""
ok, til is loaded
"""

ida_typeinf.ADDTIL_SILENT
"""
do not ask any questions
"""

ida_typeinf.CC_ALLOW_ARGPERM
"""
disregard argument order?
"""

ida_typeinf.CC_ALLOW_REGHOLES
"""
allow holes in register argument list?
"""

ida_typeinf.CC_CDECL_OK
"""
can use __cdecl calling convention?
"""

ida_typeinf.CC_HAS_ELLIPSIS
"""
function has a variable list of arguments?
"""

ida_typeinf.FAH_BYTE
"""
function argument attribute header byte
"""

ida_typeinf.FAI_ARRAY
"""
was initially an array see "__org_typedef" or "__org_arrdim" type
attributes to determine the original type
"""

ida_typeinf.FAI_HIDDEN
"""
hidden argument
"""

ida_typeinf.FAI_RETPTR
"""
pointer to return value. implies hidden
"""

ida_typeinf.FAI_STRUCT
"""
was initially a structure
"""

ida_typeinf.FTI_ALL
"""
all defined bits
"""

ida_typeinf.FTI_ARGLOCS
"""
(stkargs and retloc too)

info about argument locations has been calculated
"""

ida_typeinf.FTI_CALLTYPE
"""
mask for FTI_*CALL
"""

ida_typeinf.FTI_DEFCALL
"""
default call
"""

ida_typeinf.FTI_FARCALL
"""
far call
"""

ida_typeinf.FTI_HIGH
"""
high level prototype (with possibly hidden args)
"""

ida_typeinf.FTI_INTCALL
"""
interrupt call
"""

ida_typeinf.FTI_NEARCALL
"""
near call
"""

ida_typeinf.FTI_NORET
"""
noreturn
"""

ida_typeinf.FTI_PURE
"""
__pure
"""

ida_typeinf.FTI_SPOILED
"""
information about spoiled registers is present
"""

ida_typeinf.FTI_STATIC
"""
static
"""

ida_typeinf.FTI_VIRTUAL
"""
virtual
"""

ida_typeinf.GUESS_FUNC_FAILED
"""
couldn't guess the function type
"""

ida_typeinf.GUESS_FUNC_OK
"""
ok, some non-trivial information is gathered
"""

ida_typeinf.GUESS_FUNC_TRIVIAL
"""
the function type doesn't have interesting info
"""

ida_typeinf.HTI_CPP
"""
C++ mode (not implemented)
"""

ida_typeinf.HTI_DCL
"""
don't complain about redeclarations
"""

ida_typeinf.HTI_EXT
"""
debug: print external representation of types
"""

ida_typeinf.HTI_FIL
"""
otherwise "input" contains a C declaration

"input" is file name,
"""

ida_typeinf.HTI_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

ida_typeinf.HTI_INT
"""
debug: print internal representation of types
"""

ida_typeinf.HTI_LEX
"""
debug: print tokens
"""

ida_typeinf.HTI_LOWER
"""
lower the function prototypes
"""

ida_typeinf.HTI_MAC
"""
define macros from the base tils
"""

ida_typeinf.HTI_NDC
"""
don't decorate names
"""

ida_typeinf.HTI_NER
"""
ignore all errors but display them
"""

ida_typeinf.HTI_NWR
"""
no warning messages
"""

ida_typeinf.HTI_PAK
"""
explicit structure pack value (#pragma pack)
"""

ida_typeinf.HTI_PAK1
"""
#pragma pack(1)
"""

ida_typeinf.HTI_PAK16
"""
#pragma pack(16)
"""

ida_typeinf.HTI_PAK2
"""
#pragma pack(2)
"""

ida_typeinf.HTI_PAK4
"""
#pragma pack(4)
"""

ida_typeinf.HTI_PAK8
"""
#pragma pack(8)
"""

ida_typeinf.HTI_PAKDEF
"""
default pack value
"""

ida_typeinf.HTI_PAK_SHIFT
"""
shift for 'HTI_PAK' . This field should be used if you want to
remember an explicit pack value for each structure/union type. See
'HTI_PAK' ... definitions
"""

ida_typeinf.HTI_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

ida_typeinf.HTI_TST
"""
test mode: discard the result
"""

ida_typeinf.HTI_UNP
"""
debug: check the result by unpacking it
"""

ida_typeinf.IMPTYPE_LOCAL
"""
the type is local, the struct/enum won't be marked as til type. there
is no need to specify this bit if til==idati, the kernel will set it
automatically
"""

ida_typeinf.IMPTYPE_OVERRIDE
"""
override existing type
"""

ida_typeinf.IMPTYPE_VERBOSE
"""
more verbose output (dialog boxes may appear)
"""

ida_typeinf.MAX_FUNC_ARGS
"""
max number of function arguments
"""

ida_typeinf.NTF_64BIT
"""
value is 64bit
"""

ida_typeinf.NTF_CHKSYNC
"""
(set_numbered_type, set_named_type)

check that synchronization to IDB passed OK
"""

ida_typeinf.NTF_FIXNAME
"""
(set_named_type, set_numbered_type only)

force-validate the name of the type when setting
"""

ida_typeinf.NTF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly (set_named_type, set_numbered_type only)
"""

ida_typeinf.NTF_NOBASE
"""
don't inspect base tils (for get_named_type)
"""

ida_typeinf.NTF_NOCUR
"""
don't inspect current til file (for get_named_type)
"""

ida_typeinf.NTF_REPLACE
"""
replace original type (for set_named_type)
"""

ida_typeinf.NTF_SYMM
"""
only one of 'NTF_TYPE' and 'NTF_SYMU' , 'NTF_SYMM' can be used

symbol, name is mangled ('_func')
"""

ida_typeinf.NTF_SYMU
"""
symbol, name is unmangled ('func')
"""

ida_typeinf.NTF_TYPE
"""
type name
"""

ida_typeinf.NTF_UMANGLED
"""
name is unmangled (don't use this flag)
"""

ida_typeinf.PCN_CHR
"""
character
"""

ida_typeinf.PCN_DEC
"""
decimal
"""

ida_typeinf.PCN_HEX
"""
hexadecimal
"""

ida_typeinf.PCN_LZHEX
"""
print leading zeroes for hexdecimal number
"""

ida_typeinf.PCN_NEGSIGN
"""
print negated value (-N) for negative numbers
"""

ida_typeinf.PCN_OCT
"""
octal
"""

ida_typeinf.PCN_RADIX
"""
number base to use
"""

ida_typeinf.PCN_UNSIGNED
"""
add 'u' suffix
"""

ida_typeinf.PDF_DEF_BASE
"""
Include base types: __int8, __int16, etc..
"""

ida_typeinf.PDF_DEF_FWD
"""
Allow forward declarations.
"""

ida_typeinf.PDF_HEADER_CMT
"""
Prepend output with a descriptive comment.
"""

ida_typeinf.PDF_INCL_DEPS
"""
Include all type dependencies.
"""

ida_typeinf.PIO_IGNORE_PTRS
"""
do not follow pointers
"""

ida_typeinf.PIO_NOATTR_FAIL
"""
missing attributes are not ok
"""

ida_typeinf.PRALOC_STKOFF
"""
print stack offsets
"""

ida_typeinf.PRALOC_VERIFY
"""
interr if illegal argloc
"""

ida_typeinf.PRTYPE_1LINE
"""
print to one line
"""

ida_typeinf.PRTYPE_CPP
"""
use c++ name (only for 'print_type()' )
"""

ida_typeinf.PRTYPE_DEF
"""
 'tinfo_t' : print definition, if available
"""

ida_typeinf.PRTYPE_MULTI
"""
print to many lines
"""

ida_typeinf.PRTYPE_NOARGS
"""
 'tinfo_t' : do not print function argument names
"""

ida_typeinf.PRTYPE_NOARRS
"""
 'tinfo_t' : print arguments with 'FAI_ARRAY' as pointers
"""

ida_typeinf.PRTYPE_NORES
"""
 'tinfo_t' : never resolve types (meaningful with PRTYPE_DEF)
"""

ida_typeinf.PRTYPE_PRAGMA
"""
print pragmas for alignment
"""

ida_typeinf.PRTYPE_RESTORE
"""
 'tinfo_t' : print restored types for 'FAI_ARRAY' and 'FAI_STRUCT'
"""

ida_typeinf.PRTYPE_SEMI
"""
append ; to the end
"""

ida_typeinf.PRTYPE_TYPE
"""
print type declaration (not variable declaration)
"""

ida_typeinf.PT_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

ida_typeinf.PT_LOWER
"""
lower the function prototypes
"""

ida_typeinf.PT_NDC
"""
don't decorate names
"""

ida_typeinf.PT_PACKMASK
"""
mask for pack alignment values
"""

ida_typeinf.PT_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

ida_typeinf.PT_REPLACE
"""
replace the old type (used in idc)
"""

ida_typeinf.PT_SIL
"""
silent, no messages
"""

ida_typeinf.PT_TYP
"""
return declared type information
"""

ida_typeinf.PT_VAR
"""
return declared object information
"""

ida_typeinf.RESERVED_BYTE
"""
multifunctional purpose
"""

ida_typeinf.SETCOMP_BY_USER
"""
invoked by user, can not be replaced by module/loader
"""

ida_typeinf.SETCOMP_ONLY_ABI
"""
ignore cc field complete, use only abiname
"""

ida_typeinf.SETCOMP_ONLY_ID
"""
cc has only 'id' field the rest will be set to defaults corresponding
to the program bitness
"""

ida_typeinf.SETCOMP_OVERRIDE
"""
may override old compiler info
"""

ida_typeinf.STRMEM_ANON
"""
can be combined with 'STRMEM_NAME' : look inside anonymous members
too.
"""

ida_typeinf.STRMEM_AUTO
"""
get member by offset if struct, or get member by index if union - nb:
union: index is stored in the udm->offset field!nb: struct: offset is
in bytes (not in bits)!
"""

ida_typeinf.STRMEM_CASTABLE_TO
"""
can be combined with 'STRMEM_TYPE' : member type must be castable to
the specified type
"""

ida_typeinf.STRMEM_INDEX
"""
get member by number- in: udm->offset - is a member number
"""

ida_typeinf.STRMEM_MAXS
"""
get biggest member by size.
"""

ida_typeinf.STRMEM_MINS
"""
get smallest member by size.
"""

ida_typeinf.STRMEM_NAME
"""
get member by name- in: udm->name - the desired member name.
"""

ida_typeinf.STRMEM_OFFSET
"""
get member by offset- in: udm->offset - is a member offset in bits
"""

ida_typeinf.STRMEM_SIZE
"""
get member by size.- in: udm->size - the desired member size.
"""

ida_typeinf.STRMEM_SKIP_EMPTY
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' skip empty
members (i.e. having zero size) only last empty member can be returned
"""

ida_typeinf.STRMEM_TYPE
"""
get member by type. - in: udm->type - the desired member type. member
types are compared with tinfo_t::equals_to()
"""

ida_typeinf.STRMEM_VFTABLE
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' get vftable
instead of the base class
"""

ida_typeinf.SUDT_ALIGN
"""
to match the offsets and size info

recalculate field alignments, struct packing, etc
"""

ida_typeinf.SUDT_CONST
"""
only for serialize_udt: make type const
"""

ida_typeinf.SUDT_FAST
"""
serialize without verifying offsets and alignments
"""

ida_typeinf.SUDT_GAPS
"""
allow to fill gaps with additional members (_BYTE[])
"""

ida_typeinf.SUDT_SORT
"""
fields are not sorted by offset, sort them first
"""

ida_typeinf.SUDT_TRUNC
"""
serialize: truncate useless strings from fields, fldcmts
"""

ida_typeinf.SUDT_UNEX
"""
references to nonexistent member types are acceptable in this case it
is better to set the corresponding 'udt_member_t::fda' field to the
type alignment. if this field is not set, ida will try to guess the
alignment.
"""

ida_typeinf.SUDT_VOLATILE
"""
only for serialize_udt: make type volatile
"""

ida_typeinf.TAENUM_64BIT
"""
enum: store 64-bit values
"""

ida_typeinf.TAFLD_BASECLASS
"""
field: do not include but inherit from the current field
"""

ida_typeinf.TAFLD_UNALIGNED
"""
field: unaligned field
"""

ida_typeinf.TAFLD_VFTABLE
"""
field: ptr to virtual function table
"""

ida_typeinf.TAFLD_VIRTBASE
"""
field: virtual base (not supported yet)
"""

ida_typeinf.TAH_ALL
"""
all defined bits
"""

ida_typeinf.TAH_BYTE
"""
type attribute header byte
"""

ida_typeinf.TAH_HASATTRS
"""
has extended attributes
"""

ida_typeinf.TAPTR_PTR32
"""
ptr: __ptr32
"""

ida_typeinf.TAPTR_PTR64
"""
ptr: __ptr64
"""

ida_typeinf.TAPTR_RESTRICT
"""
ptr: __restrict
"""

ida_typeinf.TAPTR_SHIFTED
"""
ptr: __shifted(parent_struct, delta)
"""

ida_typeinf.TAUDT_CPPOBJ
"""
struct: a c++ object, not simple pod type
"""

ida_typeinf.TAUDT_MSSTRUCT
"""
struct: gcc msstruct attribute
"""

ida_typeinf.TAUDT_UNALIGNED
"""
struct: unaligned struct
"""

ida_typeinf.TAUDT_VFTABLE
"""
struct: is virtual function table
"""

ida_typeinf.TA_ORG_ARRDIM
"""
the original array dimension (append_dd)
"""

ida_typeinf.TA_ORG_TYPEDEF
"""
the original typedef name (simple string)
"""

ida_typeinf.TCMP_ANYBASE
"""
accept any base class when casting
"""

ida_typeinf.TCMP_AUTOCAST
"""
can t1 be cast into t2 automatically?
"""

ida_typeinf.TCMP_CALL
"""
can t1 be called with t2 type?
"""

ida_typeinf.TCMP_DECL
"""
compare declarations without resolving them
"""

ida_typeinf.TCMP_DELPTR
"""
remove pointer from types before comparing
"""

ida_typeinf.TCMP_EQUAL
"""
are types equal?
"""

ida_typeinf.TCMP_IGNMODS
"""
ignore const/volatile modifiers
"""

ida_typeinf.TCMP_MANCAST
"""
can t1 be cast into t2 manually?
"""

ida_typeinf.TCMP_SKIPTHIS
"""
skip the first function argument in comparison
"""

ida_typeinf.TIL_ADD_ALREADY
"""
the base til was already added
"""

ida_typeinf.TIL_ADD_FAILED
"""
see errbuf
"""

ida_typeinf.TIL_ADD_OK
"""
some tils were added
"""

ida_typeinf.TIL_ALI
"""
type aliases are present (this bit is used only on the disk)
"""

ida_typeinf.TIL_ESI
"""
extended sizeof info (short, long, longlong)
"""

ida_typeinf.TIL_MAC
"""
til has macro table
"""

ida_typeinf.TIL_MOD
"""
til has been modified, should be saved
"""

ida_typeinf.TIL_ORD
"""
type ordinal numbers are present
"""

ida_typeinf.TIL_SLD
"""
sizeof(long double)
"""

ida_typeinf.TIL_STM
"""
til has extra streams
"""

ida_typeinf.TIL_UNI
"""
universal til for any compiler
"""

ida_typeinf.TIL_ZIP
"""
pack buckets using zip
"""

ida_typeinf.TINFO_DEFINITE
"""
this is a definite type
"""

ida_typeinf.TINFO_DELAYFUNC
"""
if type is a function and no function exists at ea, schedule its
creation and argument renaming to auto-analysis otherwise try to
create it immediately
"""

ida_typeinf.TINFO_GUESSED
"""
this is a guessed type
"""

ida_typeinf.TINFO_STRICT
"""
never convert given type to another one before applying
"""

ida_typeinf.TVIS_CMT
"""
new comment is present
"""

ida_typeinf.TVIS_NAME
"""
new name is present
"""

ida_typeinf.TVIS_TYPE
"""
new type info is present
"""

ida_typeinf.TVST_DEF
"""
visit type definition (meaningful for typerefs)
"""

ida_typeinf.TVST_PRUNE
"""
don't visit children of current type
"""

ida_typeinf.VALSTR_OPEN
"""
printed opening curly brace '{'
"""
=== ida_typeinf EPYDOC INJECTIONS END ===
ida_ua.calc_dataseg():
	
	  calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t
	
	
	  Get data segment for the instruction operand. 'opnum' and 'rgnum' are
	  meaningful only if the processor has segment registers.
	  
	  @param insn (C++: const  insn_t  &)
	  @param n (C++: int)
	  @param rgnum (C++: int)
	  

ida_ua.can_decode():
	
	  can_decode(ea) -> bool
	
	
	  Can the bytes at address 'ea' be decoded as instruction?
	  
	  @param ea: linear address (C++: ea_t)
	  @return: whether or not the contents at that address could be a valid
	           instruction
	  

ida_ua.construct_macro():
	
	  construct_macro(insn, enable, build_macro) -> bool
	
	
	  See ua.hpp's construct_macro().
	  

ida_ua.create_insn():
	
	  create_insn(ea, out=None) -> int
	
	
	  Create an instruction at the specified address. This function checks
	  if an instruction is present at the specified address and will try to
	  create one if there is none. It will fail if there is a data item or
	  other items hindering the creation of the new instruction. This
	  function will also fill the 'out' structure.
	  
	  @param ea: linear address (C++: ea_t)
	  @param out: the resulting instruction (C++: insn_t  *)
	  @return: the length of the instruction or 0
	  

ida_ua.create_outctx():
	
	  create_outctx(ea, F=0, suspop=0) -> outctx_base_t
	
	
	  Create a new output context. To delete it, just use "delete pctx"
	  
	  @param ea (C++: ea_t)
	  @param F (C++: flags_t)
	  @param suspop (C++: int)
	  

ida_ua.decode_insn():
	
	  decode_insn(out, ea) -> int
	
	
	  Analyze the specified address and fill 'out'. This function does not
	  modify the database. It just tries to interpret the specified address
	  as an instruction and fills the 'out' structure.
	  
	  @param out: the resulting instruction (C++: insn_t  *)
	  @param ea: linear address (C++: ea_t)
	  @return: the length of the (possible) instruction or 0
	  

ida_ua.decode_preceding_insn():
	
	  decode_preceding_insn(out, ea) -> PyObject *
	
	
	  Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
	  @param ea: current ea
	  @param out: instruction storage
	  @return: tuple(preceeding_ea or BADADDR, farref = Boolean)
	  

ida_ua.decode_prev_insn():
	
	  decode_prev_insn(out, ea) -> ea_t
	
	
	  Decode previous instruction if it exists, fill 'out'.
	  
	  @param out: the resulting instruction (C++: insn_t  *)
	  @param ea: the address to decode the previous instruction from (C++:
	             ea_t)
	  @return: the previous instruction address ( BADADDR -no such insn)
	  

ida_ua.get_dtype_by_size():
	
	  get_dtype_by_size(size) -> int
	
	
	  Get 'op_t::dtype' from size.
	  
	  
	  @param size (C++: asize_t)
	  

ida_ua.get_dtype_flag():
	
	  get_dtype_flag(dtype) -> flags_t
	
	
	  Get flags for 'op_t::dtype' field.
	  
	  
	  @param dtype (C++: op_dtype_t)
	  

ida_ua.get_dtype_size():
	
	  get_dtype_size(dtype) -> size_t
	
	
	  Get size of opt_::dtype field.
	  
	  
	  @param dtype (C++: op_dtype_t)
	  

ida_ua.get_immvals():
	
	  get_immvals(ea, n, F=0) -> PyObject *
	
	
	  Get immediate values at the specified address. This function decodes
	  instruction at the specified address or inspects the data item. It
	  finds immediate values and copies them to 'out'. This function will
	  store the original value of the operands in 'out', unless the last
	  bits of 'F' are "...0 11111111", in which case the transformed values
	  (as needed for printing) will be stored instead.
	  
	  @param ea: address to analyze (C++: ea_t)
	  @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
	            (C++: int)
	  @param F: flags for the specified address (C++: flags_t)
	  @return: number of immediate values (0..2* UA_MAXOP )
	  

ida_ua.get_lookback():
	
	  get_lookback() -> int
	
	
	  Number of instructions to look back. This variable is not used by the
	  kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>.
	  IDP may use it as you like it. (TMS module uses it)
	  

ida_ua.get_printable_immvals():
	
	  get_printable_immvals(ea, n, F=0) -> PyObject *
	
	
	  Get immediate ready-to-print values at the specified address
	  
	  @param ea: address to analyze (C++: ea_t)
	  @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
	            (C++: int)
	  @param F: flags for the specified address (C++: flags_t)
	  @return: number of immediate values (0..2* UA_MAXOP )
	  

ida_ua.guess_table_address():
	
	  guess_table_address(insn) -> ea_t
	
	
	  Guess the jump table address (ibm pc specific)
	  
	  
	  @param insn (C++: const  insn_t  &)
	  

ida_ua.guess_table_size():
	
	  guess_table_size(insn, jump_table) -> asize_t
	
	
	  Guess the jump table size.
	  
	  
	  @param insn (C++: const  insn_t  &)
	  @param jump_table (C++: ea_t)
	  

ida_ua.insn_add_cref():
	
	  insn_add_cref(insn, to, opoff, type)
	  

ida_ua.insn_add_dref():
	
	  insn_add_dref(insn, to, opoff, type)
	  

ida_ua.insn_add_off_drefs():
	
	  insn_add_off_drefs(insn, x, type, outf) -> ea_t
	  

ida_ua.insn_create_stkvar():
	
	  insn_create_stkvar(insn, x, v, flags) -> bool
	  

class ida_ua.insn_t():
	
	    Proxy of C++ insn_t class
	    

ida_ua.insn_t.add_cref():
	
	        add_cref(self, to, opoff, type)
	        

ida_ua.insn_t.add_dref():
	
	        add_dref(self, to, opoff, type)
	        

ida_ua.insn_t.add_off_drefs():
	
	        add_off_drefs(self, x, type, outf) -> ea_t
	        

ida_ua.insn_t.assign():
	
	        assign(self, other)
	        

ida_ua.insn_t.auxpref:
	
	        __get_auxpref__(self) -> uint16
	        

ida_ua.insn_t.create_op_data():
	
	        create_op_data(self, ea_, opoff, dtype) -> bool
	        create_op_data(self, ea_, op) -> bool
	        

ida_ua.insn_t.create_stkvar():
	
	        create_stkvar(self, x, v, flags_) -> bool
	        

ida_ua.insn_t.cs:
	insn_t_cs_get(self) -> ea_t

ida_ua.insn_t.ea:
	insn_t_ea_get(self) -> ea_t

ida_ua.insn_t.flags:
	insn_t_flags_get(self) -> int16

ida_ua.insn_t.get_canon_feature():
	
	        get_canon_feature(self) -> uint32
	        

ida_ua.insn_t.get_canon_mnem():
	
	        get_canon_mnem(self) -> char const *
	        

ida_ua.insn_t.get_next_byte():
	
	        get_next_byte(self) -> uint8
	        

ida_ua.insn_t.get_next_dword():
	
	        get_next_dword(self) -> uint32
	        

ida_ua.insn_t.get_next_qword():
	
	        get_next_qword(self) -> uint64
	        

ida_ua.insn_t.get_next_word():
	
	        get_next_word(self) -> uint16
	        

ida_ua.insn_t.insnpref:
	insn_t_insnpref_get(self) -> char

ida_ua.insn_t.ip:
	insn_t_ip_get(self) -> ea_t

ida_ua.insn_t.is_64bit():
	
	        is_64bit(self) -> bool
	        

ida_ua.insn_t.is_canon_insn():
	
	        is_canon_insn(self) -> bool
	        

ida_ua.insn_t.is_macro():
	
	        is_macro(self) -> bool
	        

ida_ua.insn_t.itype:
	insn_t_itype_get(self) -> uint16

ida_ua.insn_t.ops:
	
	        __get_ops__(self) -> operands_array
	        

ida_ua.insn_t.segpref:
	insn_t_segpref_get(self) -> char

ida_ua.insn_t.size:
	insn_t_size_get(self) -> uint16

ida_ua.insn_t__from_ptrval__():
	
	  insn_t__from_ptrval__(ptrval) -> insn_t
	  

ida_ua.map_code_ea():
	
	    map_code_ea(insn, addr, opnum) -> ea_t
	    map_code_ea(insn, op) -> ea_t
	
	
	  Map a code address. This function takes into account the segment
	  translations.
	  
	  @param insn: the current instruction (C++: const  insn_t  &)
	  @param addr: the referenced address to map (C++: ea_t)
	  @param opnum: operand number (C++: int)
	    

ida_ua.map_data_ea():
	
	    map_data_ea(insn, addr, opnum=-1) -> ea_t
	    map_data_ea(insn, op) -> ea_t
	
	
	  Map a data address.
	  
	  @param insn: the current instruction (C++: const  insn_t  &)
	  @param addr: the referenced address to map (C++: ea_t)
	  @param opnum: operand number (C++: int)
	    

ida_ua.map_ea():
	
	    map_ea(insn, op, iscode) -> ea_t
	    map_ea(insn, addr, opnum, iscode) -> ea_t
	    

class ida_ua.op_t():
	
	    Proxy of C++ op_t class
	    

ida_ua.op_t.addr:
	
	        __get_addr__(self) -> ea_t
	        

ida_ua.op_t.assign():
	
	        assign(self, other)
	        

ida_ua.op_t.clr_shown():
	
	        clr_shown(self)
	        

ida_ua.op_t.dtype:
	op_t_dtype_get(self) -> op_dtype_t

ida_ua.op_t.flags:
	op_t_flags_get(self) -> uchar

ida_ua.op_t.has_reg():
	
	        Checks if the operand accesses the given processor register
	        

ida_ua.op_t.is_imm():
	
	        is_imm(self, v) -> bool
	        

ida_ua.op_t.is_reg():
	
	        is_reg(self, r) -> bool
	        

ida_ua.op_t.n:
	op_t_n_get(self) -> uchar

ida_ua.op_t.offb:
	op_t_offb_get(self) -> char

ida_ua.op_t.offo:
	op_t_offo_get(self) -> char

ida_ua.op_t.phrase:
	
	        __get_reg_phrase__(self) -> uint16
	        

ida_ua.op_t.reg:
	
	        __get_reg_phrase__(self) -> uint16
	        

ida_ua.op_t.set_shown():
	
	        set_shown(self)
	        

ida_ua.op_t.shown():
	
	        shown(self) -> bool
	        

ida_ua.op_t.specflag1:
	op_t_specflag1_get(self) -> char

ida_ua.op_t.specflag2:
	op_t_specflag2_get(self) -> char

ida_ua.op_t.specflag3:
	op_t_specflag3_get(self) -> char

ida_ua.op_t.specflag4:
	op_t_specflag4_get(self) -> char

ida_ua.op_t.specval:
	
	        __get_specval__(self) -> ea_t
	        

ida_ua.op_t.type:
	op_t_type_get(self) -> optype_t

ida_ua.op_t.value:
	
	        __get_value__(self) -> ea_t
	        

ida_ua.op_t__from_ptrval__():
	
	  op_t__from_ptrval__(ptrval) -> op_t
	  

class ida_ua.operands_array():
	
	    Proxy of C++ wrapped_array_t<(op_t,8)> class
	    

ida_ua.operands_array.data:
	operands_array_data_get(self) -> op_t (&)[8]

class ida_ua.outctx_base_t():
	
	    Proxy of C++ outctx_base_t class
	    

ida_ua.outctx_base_t.close_comment():
	
	        close_comment(self)
	        

ida_ua.outctx_base_t.clr_gen_label():
	
	        clr_gen_label(self)
	        

ida_ua.outctx_base_t.default_lnnum:
	outctx_base_t_default_lnnum_get(self) -> int

ida_ua.outctx_base_t.display_voids():
	
	        display_voids(self) -> bool
	        

ida_ua.outctx_base_t.flush_buf():
	
	        flush_buf(self, buf, indent=-1) -> bool
	        

ida_ua.outctx_base_t.flush_outbuf():
	
	        flush_outbuf(self, indent=-1) -> bool
	        

ida_ua.outctx_base_t.forbid_annotations():
	
	        forbid_annotations(self) -> int
	        

ida_ua.outctx_base_t.force_code():
	
	        force_code(self) -> bool
	        

ida_ua.outctx_base_t.gen_block_cmt():
	
	        gen_block_cmt(self, cmt, color) -> bool
	        

ida_ua.outctx_base_t.gen_border_line():
	
	        gen_border_line(self, solid=False) -> bool
	        

ida_ua.outctx_base_t.gen_cmt_line():
	
	        gen_cmt_line(self, format) -> bool
	        

ida_ua.outctx_base_t.gen_collapsed_line():
	
	        gen_collapsed_line(self, format) -> bool
	        

ida_ua.outctx_base_t.gen_empty_line():
	
	        gen_empty_line(self) -> bool
	        

ida_ua.outctx_base_t.gen_empty_line_without_annotations():
	
	        gen_empty_line_without_annotations(self)
	        

ida_ua.outctx_base_t.gen_printf():
	
	        gen_printf(self, indent, format) -> bool
	        

ida_ua.outctx_base_t.gen_xref_lines():
	
	        gen_xref_lines(self) -> bool
	        

ida_ua.outctx_base_t.get_stkvar():
	
	        get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
	        

ida_ua.outctx_base_t.init_lines_array():
	
	        init_lines_array(self, answers, maxsize)
	        

ida_ua.outctx_base_t.insn_ea:
	outctx_base_t_insn_ea_get(self) -> ea_t

ida_ua.outctx_base_t.multiline():
	
	        multiline(self) -> bool
	        

ida_ua.outctx_base_t.only_main_line():
	
	        only_main_line(self) -> bool
	        

ida_ua.outctx_base_t.out_addr_tag():
	
	        out_addr_tag(self, ea)
	        

ida_ua.outctx_base_t.out_btoa():
	
	        out_btoa(self, Word, radix=0)
	        

ida_ua.outctx_base_t.out_char():
	
	        out_char(self, c)
	        

ida_ua.outctx_base_t.out_chars():
	
	        out_chars(self, c, n)
	        

ida_ua.outctx_base_t.out_colored_register_line():
	
	        out_colored_register_line(self, str)
	        

ida_ua.outctx_base_t.out_keyword():
	
	        out_keyword(self, str)
	        

ida_ua.outctx_base_t.out_line():
	
	        out_line(self, str, color=0)
	        

ida_ua.outctx_base_t.out_long():
	
	        out_long(self, v, radix)
	        

ida_ua.outctx_base_t.out_name_expr():
	
	        out_name_expr(self, x, ea, off=BADADDR) -> bool
	        

ida_ua.outctx_base_t.out_printf():
	
	        out_printf(self, format)
	        

ida_ua.outctx_base_t.out_register():
	
	        out_register(self, str)
	        

ida_ua.outctx_base_t.out_spaces():
	
	        out_spaces(self, len)
	        

ida_ua.outctx_base_t.out_symbol():
	
	        out_symbol(self, c)
	        

ida_ua.outctx_base_t.out_tagoff():
	
	        out_tagoff(self, tag)
	        

ida_ua.outctx_base_t.out_tagon():
	
	        out_tagon(self, tag)
	        

ida_ua.outctx_base_t.out_value():
	
	        out_value(self, x, outf=0) -> flags_t
	        

ida_ua.outctx_base_t.outbuf:
	outctx_base_t_outbuf_get(self) -> qstring *

ida_ua.outctx_base_t.print_label_now():
	
	        print_label_now(self) -> bool
	        

ida_ua.outctx_base_t.restore_ctxflags():
	
	        restore_ctxflags(self, saved_flags)
	        

ida_ua.outctx_base_t.retrieve_cmt():
	
	        retrieve_cmt(self) -> ssize_t
	        

ida_ua.outctx_base_t.retrieve_name():
	
	        retrieve_name(self, arg2, arg3) -> ssize_t
	        

ida_ua.outctx_base_t.set_comment_addr():
	
	        set_comment_addr(self, ea)
	        

ida_ua.outctx_base_t.set_dlbind_opnd():
	
	        set_dlbind_opnd(self)
	        

ida_ua.outctx_base_t.set_gen_cmt():
	
	        set_gen_cmt(self, on=True)
	        

ida_ua.outctx_base_t.set_gen_demangled_label():
	
	        set_gen_demangled_label(self)
	        

ida_ua.outctx_base_t.set_gen_label():
	
	        set_gen_label(self)
	        

ida_ua.outctx_base_t.set_gen_xrefs():
	
	        set_gen_xrefs(self, on=True)
	        

ida_ua.outctx_base_t.setup_outctx():
	
	        setup_outctx(self, prefix, makeline_flags)
	        

ida_ua.outctx_base_t.stack_view():
	
	        stack_view(self) -> bool
	        

ida_ua.outctx_base_t.term_outctx():
	
	        term_outctx(self, prefix=None) -> int
	        

ida_ua.outctx_base_t__from_ptrval__():
	
	  outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t
	  

class ida_ua.outctx_t():
	
	    Proxy of C++ outctx_t class
	    

ida_ua.outctx_t.bin_ea:
	outctx_t_bin_ea_get(self) -> ea_t

ida_ua.outctx_t.bin_state:
	outctx_t_bin_state_get(self) -> char

ida_ua.outctx_t.bin_width:
	outctx_t_bin_width_get(self) -> int

ida_ua.outctx_t.close_comment():
	
	        close_comment(self)
	        

ida_ua.outctx_t.clr_gen_label():
	
	        clr_gen_label(self)
	        

ida_ua.outctx_t.curlabel:
	outctx_t_curlabel_get(self) -> qstring *

ida_ua.outctx_t.default_lnnum:
	outctx_base_t_default_lnnum_get(self) -> int

ida_ua.outctx_t.display_voids():
	
	        display_voids(self) -> bool
	        

ida_ua.outctx_t.flush_buf():
	
	        flush_buf(self, buf, indent=-1) -> bool
	        

ida_ua.outctx_t.flush_outbuf():
	
	        flush_outbuf(self, indent=-1) -> bool
	        

ida_ua.outctx_t.forbid_annotations():
	
	        forbid_annotations(self) -> int
	        

ida_ua.outctx_t.force_code():
	
	        force_code(self) -> bool
	        

ida_ua.outctx_t.gen_block_cmt():
	
	        gen_block_cmt(self, cmt, color) -> bool
	        

ida_ua.outctx_t.gen_border_line():
	
	        gen_border_line(self, solid=False) -> bool
	        

ida_ua.outctx_t.gen_cmt_line():
	
	        gen_cmt_line(self, format) -> bool
	        

ida_ua.outctx_t.gen_collapsed_line():
	
	        gen_collapsed_line(self, format) -> bool
	        

ida_ua.outctx_t.gen_empty_line():
	
	        gen_empty_line(self) -> bool
	        

ida_ua.outctx_t.gen_empty_line_without_annotations():
	
	        gen_empty_line_without_annotations(self)
	        

ida_ua.outctx_t.gen_func_footer():
	
	        gen_func_footer(self, pfn)
	        

ida_ua.outctx_t.gen_func_header():
	
	        gen_func_header(self, pfn)
	        

ida_ua.outctx_t.gen_header():
	
	        gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
	        

ida_ua.outctx_t.gen_header_extra():
	
	        gen_header_extra(self)
	        

ida_ua.outctx_t.gen_printf():
	
	        gen_printf(self, indent, format) -> bool
	        

ida_ua.outctx_t.gen_xref_lines():
	
	        gen_xref_lines(self) -> bool
	        

ida_ua.outctx_t.get_stkvar():
	
	        get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
	        

ida_ua.outctx_t.gl_bpsize:
	outctx_t_gl_bpsize_get(self) -> int

ida_ua.outctx_t.init_lines_array():
	
	        init_lines_array(self, answers, maxsize)
	        

ida_ua.outctx_t.insn:
	outctx_t_insn_get(self) -> insn_t

ida_ua.outctx_t.insn_ea:
	outctx_base_t_insn_ea_get(self) -> ea_t

ida_ua.outctx_t.multiline():
	
	        multiline(self) -> bool
	        

ida_ua.outctx_t.only_main_line():
	
	        only_main_line(self) -> bool
	        

ida_ua.outctx_t.out_addr_tag():
	
	        out_addr_tag(self, ea)
	        

ida_ua.outctx_t.out_btoa():
	
	        out_btoa(self, Word, radix=0)
	        

ida_ua.outctx_t.out_char():
	
	        out_char(self, c)
	        

ida_ua.outctx_t.out_chars():
	
	        out_chars(self, c, n)
	        

ida_ua.outctx_t.out_colored_register_line():
	
	        out_colored_register_line(self, str)
	        

ida_ua.outctx_t.out_custom_mnem():
	
	        out_custom_mnem(self, mnem, width=8, postfix=None)
	        

ida_ua.outctx_t.out_data():
	
	        out_data(self, analyze_only)
	        

ida_ua.outctx_t.out_immchar_cmts():
	
	        out_immchar_cmts(self)
	        

ida_ua.outctx_t.out_keyword():
	
	        out_keyword(self, str)
	        

ida_ua.outctx_t.out_line():
	
	        out_line(self, str, color=0)
	        

ida_ua.outctx_t.out_long():
	
	        out_long(self, v, radix)
	        

ida_ua.outctx_t.out_mnem():
	
	        out_mnem(self, width=8, postfix=None)
	        

ida_ua.outctx_t.out_mnemonic():
	
	        out_mnemonic(self)
	        

ida_ua.outctx_t.out_name_expr():
	
	        out_name_expr(self, x, ea, off=BADADDR) -> bool
	        

ida_ua.outctx_t.out_one_operand():
	
	        out_one_operand(self, n) -> bool
	        

ida_ua.outctx_t.out_printf():
	
	        out_printf(self, format)
	        

ida_ua.outctx_t.out_register():
	
	        out_register(self, str)
	        

ida_ua.outctx_t.out_spaces():
	
	        out_spaces(self, len)
	        

ida_ua.outctx_t.out_specea():
	
	        out_specea(self, segtype) -> bool
	        

ida_ua.outctx_t.out_symbol():
	
	        out_symbol(self, c)
	        

ida_ua.outctx_t.out_tagoff():
	
	        out_tagoff(self, tag)
	        

ida_ua.outctx_t.out_tagon():
	
	        out_tagon(self, tag)
	        

ida_ua.outctx_t.out_value():
	
	        out_value(self, x, outf=0) -> flags_t
	        

ida_ua.outctx_t.outbuf:
	outctx_base_t_outbuf_get(self) -> qstring *

ida_ua.outctx_t.print_label_now():
	
	        print_label_now(self) -> bool
	        

ida_ua.outctx_t.restore_ctxflags():
	
	        restore_ctxflags(self, saved_flags)
	        

ida_ua.outctx_t.retrieve_cmt():
	
	        retrieve_cmt(self) -> ssize_t
	        

ida_ua.outctx_t.retrieve_name():
	
	        retrieve_name(self, arg2, arg3) -> ssize_t
	        

ida_ua.outctx_t.set_comment_addr():
	
	        set_comment_addr(self, ea)
	        

ida_ua.outctx_t.set_dlbind_opnd():
	
	        set_dlbind_opnd(self)
	        

ida_ua.outctx_t.set_gen_cmt():
	
	        set_gen_cmt(self, on=True)
	        

ida_ua.outctx_t.set_gen_demangled_label():
	
	        set_gen_demangled_label(self)
	        

ida_ua.outctx_t.set_gen_label():
	
	        set_gen_label(self)
	        

ida_ua.outctx_t.set_gen_xrefs():
	
	        set_gen_xrefs(self, on=True)
	        

ida_ua.outctx_t.setup_outctx():
	
	        setup_outctx(self, prefix, flags)
	        

ida_ua.outctx_t.stack_view():
	
	        stack_view(self) -> bool
	        

ida_ua.outctx_t.term_outctx():
	
	        term_outctx(self, prefix=None) -> int
	        

ida_ua.outctx_t.wif:
	outctx_t_wif_get(self) -> printop_t

ida_ua.outctx_t__from_ptrval__():
	
	  outctx_t__from_ptrval__(ptrval) -> outctx_t
	  

ida_ua.print_insn_mnem():
	
	  print_insn_mnem(ea) -> bool
	
	
	  Print instruction mnemonics.
	  
	  @param ea: linear address of the instruction (C++: ea_t)
	  @return: success
	  

ida_ua.print_operand():
	
	  print_operand(ea, n, getn_flags=0, newtype=None) -> bool
	
	
	  Generate text representation for operand #n. This function will
	  generate the text representation of the specified operand (includes
	  color codes.)
	  
	  @param ea: the item address (instruction or data) (C++: ea_t)
	  @param n: operand number (0,1,2...). meaningful only for instructions
	            (C++: int)
	  @param getn_flags (C++: int)
	  @param newtype: if specified, print the operand using the specified
	                  type (C++: struct  printop_t  *)
	  @return: success
	  

ida_ua.ua_mnem():
	
	  print_insn_mnem(ea) -> bool
	
	
	  Print instruction mnemonics.
	  
	  @param ea: linear address of the instruction (C++: ea_t)
	  @return: success
	  


=== ida_ua EPYDOC INJECTIONS ===
ida_ua.FCBF_CONT
"""
don't stop on decoding, or any other kind of error
"""

ida_ua.FCBF_DELIM
"""
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error
"""

ida_ua.FCBF_ERR_REPL
"""
of a hex representation of the problematic byte

in case of an error, use a CP_REPLCHAR instead
"""

ida_ua.FCBF_FF_LIT
"""
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence
"""

ida_ua.INSN_64BIT
"""
belongs to 64bit segment?
"""

ida_ua.INSN_MACRO
"""
macro instruction
"""

ida_ua.INSN_MODMAC
"""
may modify the database to make room for the macro insn
"""

ida_ua.OF_NO_BASE_DISP
"""
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.
"""

ida_ua.OF_NUMBER
"""
the operand can be converted to a number only
"""

ida_ua.OF_OUTER_DISP
"""
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.
"""

ida_ua.OF_SHOW
"""
should the operand be displayed?
"""

ida_ua.OOFS_IFSIGN
"""
output sign if needed
"""

ida_ua.OOFS_NEEDSIGN
"""
always out sign (+-)
"""

ida_ua.OOFS_NOSIGN
"""
don't output sign, forbid the user to change the sign
"""

ida_ua.OOFW_16
"""
16 bit width
"""

ida_ua.OOFW_24
"""
24 bit width
"""

ida_ua.OOFW_32
"""
32 bit width
"""

ida_ua.OOFW_64
"""
64 bit width
"""

ida_ua.OOFW_8
"""
8 bit width
"""

ida_ua.OOFW_IMM
"""
take from x.dtype
"""

ida_ua.OOF_ADDR
"""
output x.addr, otherwise x.value
"""

ida_ua.OOF_ANYSERIAL
"""
if enum: select first available serial
"""

ida_ua.OOF_NOBNOT
"""
prohibit use of binary not
"""

ida_ua.OOF_NUMBER
"""
always as a number
"""

ida_ua.OOF_OUTER
"""
output outer operand
"""

ida_ua.OOF_SIGNED
"""
output as signed if < 0
"""

ida_ua.OOF_SIGNMASK
"""
sign symbol (+/-) output
"""

ida_ua.OOF_SPACES
"""
currently works only for floating point numbers

do not suppress leading spaces
"""

ida_ua.OOF_WIDTHMASK
"""
width of value in bits
"""

ida_ua.OOF_ZSTROFF
"""
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.
"""

ida_ua.PACK_FORM_DEF
"""
(! 'o_reg' + 'dt_packreal' )

packed factor defined.
"""

ida_ua.dt_bitfild
"""
bit field (mc680x0)
"""

ida_ua.dt_byte
"""
8 bit
"""

ida_ua.dt_byte16
"""
128 bit
"""

ida_ua.dt_byte32
"""
256 bit
"""

ida_ua.dt_byte64
"""
512 bit
"""

ida_ua.dt_code
"""
ptr to code (not used?)
"""

ida_ua.dt_double
"""
8 byte
"""

ida_ua.dt_dword
"""
32 bit
"""

ida_ua.dt_float
"""
4 byte
"""

ida_ua.dt_fword
"""
48 bit
"""

ida_ua.dt_ldbl
"""
long double (which may be different from tbyte)
"""

ida_ua.dt_packreal
"""
packed real format for mc68040
"""

ida_ua.dt_qword
"""
64 bit
"""

ida_ua.dt_string
"""
pointer to asciiz string
"""

ida_ua.dt_tbyte
"""
variable size ({tbyte_size})
"""

ida_ua.dt_unicode
"""
pointer to unicode string
"""

ida_ua.dt_void
"""
none
"""

ida_ua.dt_word
"""
16 bit
"""
=== ida_ua EPYDOC INJECTIONS END ===
ida_xref.add_cref():
	
	  add_cref(frm, to, type) -> bool
	
	
	  Create a code cross-reference.
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @param type: cross-reference type (C++: cref_t)
	  @return: success
	  

ida_xref.add_dref():
	
	  add_dref(frm, to, type) -> bool
	
	
	  Create a data cross-reference.
	  
	  @param to: linear address of referenced data (C++: ea_t)
	  @param type: cross-reference type (C++: dref_t)
	  @return: success (may fail if user-defined xref exists from->to)
	  

ida_xref.calc_switch_cases():
	
	  calc_switch_cases(ea, si) -> cases_and_targets_t
	
	
	  Get information about a switch's cases.
	  
	  The returned information can be used as follows:
	  
	      for idx in xrange(len(results.cases)):
	          cur_case = results.cases[idx]
	          for cidx in xrange(len(cur_case)):
	              print "case: %d" % cur_case[cidx]
	          print "  goto 0x%x" % results.targets[idx]
	  
	  @param ea: address of the 'indirect jump' instruction
	  @param si: switch information
	  
	  @return: a structure with 2 members: 'cases', and 'targets'.
	  

class ida_xref.cases_and_targets_t():
	
	    Proxy of C++ cases_and_targets_t class
	    

ida_xref.cases_and_targets_t.cases:
	cases_and_targets_t_cases_get(self) -> casevec_t

ida_xref.cases_and_targets_t.targets:
	cases_and_targets_t_targets_get(self) -> eavec_t *

class ida_xref.casevec_t():
	
	    Proxy of C++ qvector<(qvector<(sval_t)>)> class
	    

ida_xref.casevec_t.add_unique():
	
	        add_unique(self, x) -> bool
	        

ida_xref.casevec_t.at():
	
	        __getitem__(self, i) -> qvector< signed-ea-like-numeric-type > const &
	        

ida_xref.casevec_t.begin():
	
	        begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
	        begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
	        

ida_xref.casevec_t.capacity():
	
	        capacity(self) -> size_t
	        

ida_xref.casevec_t.clear():
	
	        clear(self)
	        

ida_xref.casevec_t.empty():
	
	        empty(self) -> bool
	        

ida_xref.casevec_t.end():
	
	        end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
	        end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
	        

ida_xref.casevec_t.erase():
	
	        erase(self, it) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
	        erase(self, first, last) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
	        

ida_xref.casevec_t.extract():
	
	        extract(self) -> qvector< signed-ea-like-numeric-type > *
	        

ida_xref.casevec_t.find():
	
	        find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
	        find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
	        

ida_xref.casevec_t.grow():
	
	        grow(self, x=qvector< signed-ea-like-numeric-type >())
	        

ida_xref.casevec_t.has():
	
	        has(self, x) -> bool
	        

ida_xref.casevec_t.inject():
	
	        inject(self, s, len)
	        

ida_xref.casevec_t.insert():
	
	        insert(self, it, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
	        

ida_xref.casevec_t.pop_back():
	
	        pop_back(self)
	        

ida_xref.casevec_t.push_back():
	
	        push_back(self, x)
	        push_back(self) -> qvector< signed-ea-like-numeric-type > &
	        

ida_xref.casevec_t.qclear():
	
	        qclear(self)
	        

ida_xref.casevec_t.reserve():
	
	        reserve(self, cnt)
	        

ida_xref.casevec_t.resize():
	
	        resize(self, _newsize, x)
	        resize(self, _newsize)
	        

ida_xref.casevec_t.size():
	
	        size(self) -> size_t
	        

ida_xref.casevec_t.swap():
	
	        swap(self, r)
	        

ida_xref.casevec_t.truncate():
	
	        truncate(self)
	        

ida_xref.create_switch_table():
	
	  create_switch_table(ea, si) -> bool
	
	
	  Create switch table from the switch information
	  
	  @param ea: address of the 'indirect jump' instruction
	  @param si: switch information
	  
	  @return: Boolean
	  

ida_xref.create_switch_xrefs():
	
	  create_switch_xrefs(ea, si) -> bool
	
	
	  This function creates xrefs from the indirect jump.
	  
	  Usually there is no need to call this function directly because the kernel
	  will call it for switch tables
	  
	  Note: Custom switch information are not supported yet.
	  
	  @param ea: address of the 'indirect jump' instruction
	  @param si: switch information
	  
	  @return: Boolean
	  

ida_xref.del_cref():
	
	  del_cref(frm, to, expand) -> int
	
	
	  Delete a code cross-reference.
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @param expand: policy to delete the referenced instruction   1: plan
	                 to delete the referenced instruction if it has no more
	                 references. 0: don't delete the referenced instruction
	                 even if no more cross-references point to it (C++:
	                 bool)
	  

ida_xref.del_dref():
	
	  del_dref(frm, to)
	
	
	  Delete a data cross-reference.
	  
	  @param to: linear address of referenced data (C++: ea_t)
	  

ida_xref.delete_switch_table():
	
	  delete_switch_table(jump_ea, si)
	  

ida_xref.get_first_cref_from():
	
	  get_first_cref_from(frm) -> ea_t
	
	
	  Get first instruction referenced from the specified instruction. If
	  the specified instruction passes execution to the next instruction
	  then the next instruction is returned. Otherwise the lowest referenced
	  address is returned (remember that xrefs are kept sorted!).
	  
	  @return: first referenced address. The  lastXR  variable contains type
	           of the reference. If the specified instruction doesn't
	           reference to other instructions then returns  BADADDR .
	  

ida_xref.get_first_cref_to():
	
	  get_first_cref_to(to) -> ea_t
	
	
	  Get first instruction referencing to the specified instruction. If the
	  specified instruction may be executed immediately after its previous
	  instruction then the previous instruction is returned. Otherwise the
	  lowest referencing address is returned. (remember that xrefs are kept
	  sorted!).
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @return: linear address of the first referencing instruction or
	           BADADDR . The  lastXR  variable contains type of the
	           reference.
	  

ida_xref.get_first_dref_from():
	
	  get_first_dref_from(frm) -> ea_t
	
	
	  Get first data referenced from the specified address.
	  
	  @return: linear address of first (lowest) data referenced from the
	           specified address. The  lastXR  variable contains type of the
	           reference. Return  BADADDR  if the specified instruction/data
	           doesn't reference to anything.
	  

ida_xref.get_first_dref_to():
	
	  get_first_dref_to(to) -> ea_t
	
	
	  Get address of instruction/data referencing to the specified data.
	  
	  @param to: linear address of referencing instruction or data (C++:
	             ea_t)
	  @return: BADADDR  if nobody refers to the specified data. The  lastXR
	           variable contains type of the reference.
	  

ida_xref.get_first_fcref_from():
	
	  get_first_fcref_from(frm) -> ea_t
	  

ida_xref.get_first_fcref_to():
	
	  get_first_fcref_to(to) -> ea_t
	  

ida_xref.get_next_cref_from():
	
	  get_next_cref_from(frm, current) -> ea_t
	
	
	  Get next instruction referenced from the specified instruction.
	  
	  @param current: linear address of current referenced instruction This
	                  value is returned by  get_first_cref_from()  or
	                  previous call to  get_next_cref_from()  functions.
	                  (C++: ea_t)
	  @return: next referenced address or  BADADDR . The  lastXR  variable
	           contains type of the reference.
	  

ida_xref.get_next_cref_to():
	
	  get_next_cref_to(to, current) -> ea_t
	
	
	  Get next instruction referencing to the specified instruction.
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @param current: linear address of current referenced instruction This
	                  value is returned by  get_first_cref_to()  or previous
	                  call to  get_next_cref_to()  functions. (C++: ea_t)
	  @return: linear address of the next referencing instruction or
	           BADADDR . The  lastXR  variable contains type of the
	           reference.
	  

ida_xref.get_next_dref_from():
	
	  get_next_dref_from(frm, current) -> ea_t
	
	
	  Get next data referenced from the specified address.
	  
	  @param current: linear address of current referenced data. This value
	                  is returned by  get_first_dref_from()  or previous
	                  call to  get_next_dref_from()  functions. (C++: ea_t)
	  @return: linear address of next data or  BADADDR . The  lastXR
	           variable contains type of the reference
	  

ida_xref.get_next_dref_to():
	
	  get_next_dref_to(to, current) -> ea_t
	
	
	  Get address of instruction/data referencing to the specified data
	  
	  @param to: linear address of referencing instruction or data (C++:
	             ea_t)
	  @param current: current linear address. This value is returned by
	                  get_first_dref_to()  or previous call to
	                  get_next_dref_to()  functions. (C++: ea_t)
	  @return: BADADDR  if nobody refers to the specified data. The  lastXR
	           variable contains type of the reference.
	  

ida_xref.get_next_fcref_from():
	
	  get_next_fcref_from(frm, current) -> ea_t
	  

ida_xref.get_next_fcref_to():
	
	  get_next_fcref_to(to, current) -> ea_t
	  

ida_xref.has_external_refs():
	
	  has_external_refs(pfn, ea) -> bool
	
	
	  Has a location external to the function references?
	  
	  
	  @param pfn (C++: func_t  *)
	  @param ea (C++: ea_t)
	  

class ida_xref.xrefblk_t():
	
	    Proxy of C++ xrefblk_t class
	    

ida_xref.xrefblk_t.first_from():
	
	        first_from(self, _from, flags) -> bool
	        

ida_xref.xrefblk_t.first_to():
	
	        first_to(self, _to, flags) -> bool
	        

ida_xref.xrefblk_t.frm:
	xrefblk_t_frm_get(self) -> ea_t

ida_xref.xrefblk_t.iscode:
	xrefblk_t_iscode_get(self) -> uchar

ida_xref.xrefblk_t.next_from():
	
	        next_from(self) -> bool
	        next_from(self, _from, _to, flags) -> bool
	        

ida_xref.xrefblk_t.next_to():
	
	        next_to(self) -> bool
	        next_to(self, _from, _to, flags) -> bool
	        

ida_xref.xrefblk_t.to:
	xrefblk_t_to_get(self) -> ea_t

ida_xref.xrefblk_t.type:
	xrefblk_t_type_get(self) -> uchar

ida_xref.xrefblk_t.user:
	xrefblk_t_user_get(self) -> uchar

ida_xref.xrefchar():
	
	  xrefchar(xrtype) -> char
	
	
	  Get character describing the xref type.
	  
	  @param xrtype: combination of  Cross-Reference type flags  and a
	                 cref_t  of  dref_t  value (C++: char)
	  


=== ida_xref EPYDOC INJECTIONS ===
ida_xref.XREF_ALL
"""
return all references
"""

ida_xref.XREF_BASE
"""
Reference to the base part of an offset.
"""

ida_xref.XREF_DATA
"""
return data references only
"""

ida_xref.XREF_FAR
"""
don't return ordinary flow xrefs
"""

ida_xref.XREF_MASK
"""
Mask to get xref type.
"""

ida_xref.XREF_PASTEND
"""
Reference is past item. This bit may be passed to 'add_dref()'
functions but it won't be saved in the database. It will prevent the
destruction of eventual alignment directives.
"""

ida_xref.XREF_TAIL
"""
Reference to tail byte in extrn symbols.
"""

ida_xref.XREF_USER
"""
User specified xref. This xref will not be deleted by IDA. This bit
should be combined with the existing xref types ( 'cref_t' & 'dref_t'
) Can not be used for fl_F xrefs
"""
=== ida_xref EPYDOC INJECTIONS END ===
idc.AutoMark():
	
	    Plan to analyze an address
	    

class idc.DeprecatedIDCError():
	
	    Exception for deprecated function calls
	    

idc.EVAL_FAILURE():
	
	    Check the result of eval_idc() for evaluation failures
	
	    @param code: result of eval_idc()
	
	    @return: True if there was an evaluation error
	    

idc.GetCommentEx():
	
	  get_cmt(ea, rptble) -> ssize_t
	
	
	  Get an indented comment.
	  
	  @param ea: linear address. may point to tail byte, the function will
	             find start of the item (C++: ea_t)
	  @param rptble: get repeatable comment? (C++: bool)
	  @return: size of comment or -1
	  

idc.GetDisasm():
	
	    Get disassembly line
	
	    @param ea: linear address of instruction
	
	    @return: "" - could not decode instruction at the specified location
	
	    @note: this function may not return exactly the same mnemonics
	           as you see on the screen.
	    

idc.GetDouble():
	
	    Get value of a floating point number (8 bytes)
	    This function assumes number stored using IEEE format
	    and in the same endianness as integers.
	
	    @param ea: linear address
	
	    @return: double
	    

idc.GetFloat():
	
	    Get value of a floating point number (4 bytes)
	    This function assumes number stored using IEEE format
	    and in the same endianness as integers.
	
	    @param ea: linear address
	
	    @return: float
	    

idc.GetLocalType():
	
	    Retrieve a local type declaration
	    @param flags: any of PRTYPE_* constants
	    @return: local type as a C declaration or ""
	    

idc.LoadFile():
	
	    Load file into IDA database
	
	    @param filepath: path to input file
	    @param pos: position in the file
	    @param ea: linear address to load
	    @param size: number of bytes to load
	
	    @return: 0 - error, 1 - ok
	    

idc.MakeVar():
	
	    Mark the location as "variable"
	
	    @param ea: address to mark
	
	    @return: None
	
	    @note: All that IDA does is to mark the location as "variable".
	    Nothing else, no additional analysis is performed.
	    This function may disappear in the future.
	    

idc.SaveFile():
	
	    Save from IDA database to file
	
	    @param filepath: path to output file
	    @param pos: position in the file
	    @param ea: linear address to save from
	    @param size: number of bytes to save
	
	    @return: 0 - error, 1 - ok
	    

idc.SetType():
	
	    Set type of function/variable
	
	    @param ea: the address of the object
	    @param newtype: the type string in C declaration form.
	                Must contain the closing ';'
	                if specified as an empty string, then the
	                item associated with 'ea' will be deleted.
	
	    @return: 1-ok, 0-failed.
	    

idc.SizeOf():
	
	    Returns the size of the type. It is equivalent to IDC's sizeof().
	    Use name, tp, fld = idc.parse_decl() ; SizeOf(tp) to retrieve the size
	    @return: -1 if typestring is not valid otherwise the size of the type
	    

idc.add_auto_stkpnt():
	
	    Add automatical SP register change point
	    @param func_ea: function start
	    @param ea: linear address where SP changes
	               usually this is the end of the instruction which
	               modifies the stack pointer (insn.ea+insn.size)
	    @param delta: difference between old and new values of SP
	    @return: 1-ok, 0-failed
	    

idc.add_bpt():
	
	    Add a new breakpoint
	
	    @param ea: any address in the process memory space:
	    @param size: size of the breakpoint (irrelevant for software breakpoints):
	    @param bpttype: type of the breakpoint (one of BPT_... constants)
	
	    @return: success
	
	    @note: Only one breakpoint can exist at a given address.
	    

idc.add_cref():
	
	  add_cref(frm, to, type) -> bool
	
	
	  Create a code cross-reference.
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @param type: cross-reference type (C++: cref_t)
	  @return: success
	  

idc.add_default_til():
	
	    Load a type library
	
	    @param name: name of type library.
	    @return: 1-ok, 0-failed.
	    

idc.add_dref():
	
	  add_dref(frm, to, type) -> bool
	
	
	  Create a data cross-reference.
	  
	  @param to: linear address of referenced data (C++: ea_t)
	  @param type: cross-reference type (C++: dref_t)
	  @return: success (may fail if user-defined xref exists from->to)
	  

idc.add_entry():
	
	  add_entry(ord, ea, name, makecode, flags=0x0) -> bool
	
	
	  Add an entry point to the list of entry points.
	  
	  @param ord: ordinal number if ordinal number is equal to 'ea' then
	              ordinal is not used (C++: uval_t)
	  @param ea: linear address (C++: ea_t)
	  @param name: name of entry point. If the specified location already
	               has a name, the old name will be appended to the regular
	               comment. If name == NULL, then the old name will be
	               retained. (C++: const char *)
	  @param makecode: should the kernel convert bytes at the entry point to
	                   instruction(s) (C++: bool)
	  @param flags: See AEF_* (C++: int)
	  @return: success (currently always true)
	  

idc.add_enum():
	
	    Add a new enum type
	
	    @param idx: serial number of the new enum.
	            If another enum with the same serial number
	            exists, then all enums with serial
	            numbers >= the specified idx get their
	            serial numbers incremented (in other words,
	            the new enum is put in the middle of the list of enums).
	
	            If idx >= get_enum_qty() or idx == idaapi.BADNODE
	            then the new enum is created at the end of
	            the list of enums.
	
	    @param name: name of the enum.
	    @param flag: flags for representation of numeric constants
	                 in the definition of enum.
	
	    @return: id of new enum or BADADDR
	    

idc.add_enum_member():
	
	    Add a member of enum - a symbolic constant
	
	    @param enum_id: id of enum
	    @param name: name of symbolic constant. Must be unique in the program.
	    @param value: value of symbolic constant.
	    @param bmask: bitmask of the constant
	        ordinary enums accept only ida_enum.DEFMASK as a bitmask
	        all bits set in value should be set in bmask too
	
	    @return: 0-ok, otherwise error code (one of ENUM_MEMBER_ERROR_*)
	    

idc.add_func():
	
	    Create a function
	
	    @param start: function bounds
	    @param end: function bounds
	
	    If the function end address is BADADDR, then
	    IDA will try to determine the function bounds
	    automatically. IDA will define all necessary
	    instructions to determine the function bounds.
	
	    @return: !=0 - ok
	
	    @note: an instruction should be present at the start address
	    

idc.add_hidden_range():
	
	  add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
	
	
	  Mark a range of addresses as hidden. The range will be created in the
	  invisible state with the default color
	  
	  @param ea1: linear address of start of the address range (C++: ea_t)
	  @param ea2: linear address of end of the address range (C++: ea_t)
	  @param description: range parameters (C++: const char *)
	  @param header: range parameters (C++: const char *)
	  @param footer: range parameters (C++: const char *)
	  @param color (C++: bgcolor_t)
	  @return: success
	  

idc.add_idc_hotkey():
	
	  add_idc_hotkey(hotkey, idcfunc) -> int
	
	
	  Add hotkey for IDC function ( 'ui_add_idckey' ).
	  
	  @param hotkey: hotkey name (C++: const char *)
	  @param idcfunc: IDC function name (C++: const char *)
	  @return: IDC hotkey error codes
	  

idc.add_segm_ex():
	
	    Create a new segment
	
	    @param startea: linear address of the start of the segment
	    @param endea: linear address of the end of the segment
	               this address will not belong to the segment
	               'endea' should be higher than 'startea'
	    @param base: base paragraph or selector of the segment.
	               a paragraph is 16byte memory chunk.
	               If a selector value is specified, the selector should be
	               already defined.
	    @param use32: 0: 16bit segment, 1: 32bit segment, 2: 64bit segment
	    @param align: segment alignment. see below for alignment values
	    @param comb: segment combination. see below for combination values.
	    @param flags: combination of ADDSEG_... bits
	
	    @return: 0-failed, 1-ok
	    

idc.add_sourcefile():
	
	  add_sourcefile(ea1, ea2, filename) -> bool
	
	
	  Mark a range of address as belonging to a source file. An address
	  range may belong only to one source file. A source file may be
	  represented by several address ranges.
	  
	  @param ea1: linear address of start of the address range (C++: ea_t)
	  @param ea2: linear address of end of the address range (excluded)
	              (C++: ea_t)
	  @param filename: name of source file. (C++: const char *)
	  @return: success
	  

idc.add_struc():
	
	    Define a new structure type
	
	    @param index: index of new structure type
	                  If another structure has the specified index,
	                  then index of that structure and all other
	                  structures will be incremented, freeing the specifed
	                  index. If index is == -1, then the biggest index
	                  number will be used.
	                  See get_first_struc_idx() for the explanation of
	                  structure indices and IDs.
	    @param name: name of the new structure type.
	    @param is_union: 0: structure
	                     1: union
	
	    @return: -1 if can't define structure type because of
	             bad structure name: the name is ill-formed or is
	             already used in the program.
	             otherwise returns ID of the new structure type
	    

idc.add_struc_member():
	
	    Add structure member
	
	    @param sid: structure type ID
	    @param name: name of the new member
	    @param offset: offset of the new member
	                   -1 means to add at the end of the structure
	    @param flag: type of the new member. Should be one of
	                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
	    @param typeid: if isStruc(flag) then typeid specifies the structure id for the member
	                   if is_off0(flag) then typeid specifies the offset base.
	                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
	                   if is_stroff(flag) then typeid specifies the structure id
	                   if is_enum(flag) then typeid specifies the enum id
	                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
	                   Otherwise typeid should be -1.
	    @param nbytes: number of bytes in the new member
	
	    @param target: target address of the offset expr. You may specify it as
	                   -1, ida will calculate it itself
	    @param tdelta: offset target delta. usually 0
	    @param reftype: see REF_... definitions
	
	    @note: The remaining arguments are allowed only if is_off0(flag) and you want
	           to specify a complex offset expression
	
	    @return: 0 - ok, otherwise error code (one of STRUC_ERROR_*)
	
	    

idc.add_user_stkpnt():
	
	  add_user_stkpnt(ea, delta) -> bool
	
	
	  Add user-defined SP register change point.
	  
	  @param ea: linear address where SP changes (C++: ea_t)
	  @param delta: difference between old and new values of SP (C++:
	                sval_t)
	  @return: success
	  

idc.append_func_tail():
	
	    Append a function chunk to the function
	
	    @param funcea: any address in the function
	    @param ea1: start of function tail
	    @param ea2: end of function tail
	    @return: 0 if failed, 1 if success
	
	    @note: If a chunk exists at the specified addresses, it must have exactly
	           the specified boundaries
	    

idc.apply_type():
	
	    Apply the specified type to the address
	
	    @param ea: the address of the object
	    @param py_type: typeinfo tuple (type, fields) as get_tinfo() returns
	                 or tuple (name, type, fields) as parse_decl() returns
	                 or None
	                if specified as None, then the
	                item associated with 'ea' will be deleted.
	    @param flags: combination of TINFO_... constants or 0
	    @return: Boolean
	    

idc.ask_yn():
	
	  ask_yn(deflt, format) -> int
	
	
	  Display a dialog box and get choice from "Yes", "No", "Cancel".
	  
	  @param deflt: default choice: one of  Button IDs (C++: int)
	  @param format: The question in printf() style format (C++: const char
	                 *)
	  @return: the selected button (one of  Button IDs ). Esc key returns
	           ASKBTN_CANCEL .
	  

idc.atoa():
	
	    Convert address value to a string
	    Return address in the form 'seg000:1234'
	    (the same as in line prefixes)
	
	    @param ea: address to format
	    

idc.attach_process():
	
	  attach_process(pid=pid_t(-1), event_id=-1) -> int
	
	
	  Attach the debugger to a running process. {Type, Asynchronous function
	  - available as Request, Notification, 'dbg_process_attach' }This
	  function shouldn't be called as a request if 'NO_PROCESS' is used.
	  
	  @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
	              box will interactively ask the user for the process to
	              attach to. (C++: pid_t)
	  @param event_id (C++: int)
	  

idc.auto_mark_range():
	
	  auto_mark_range(start, end, type)
	
	
	  Put range of addresses into a queue. 'start' may be higher than 'end',
	  the kernel will swap them in this case. 'end' doesn't belong to the
	  range.
	  
	  @param start (C++: ea_t)
	  @param end (C++: ea_t)
	  @param type (C++: atype_t)
	  

idc.auto_unmark():
	
	  auto_unmark(start, end, type)
	
	
	  Remove range of addresses from a queue. 'start' may be higher than
	  'end', the kernel will swap them in this case. 'end' doesn't belong to
	  the range.
	  
	  @param start (C++: ea_t)
	  @param end (C++: ea_t)
	  @param type (C++: atype_t)
	  

idc.auto_wait():
	
	  auto_wait() -> bool
	
	
	  Process everything in the queues and return true. Return false if
	  Ctrl-Break was pressed.
	  

idc.batch():
	
	    Enable/disable batch mode of operation
	
	    @param batch: batch mode
	            0 - ida will display dialog boxes and wait for the user input
	            1 - ida will not display dialog boxes, warnings, etc.
	
	    @return: old balue of batch flag
	    

idc.byte_value():
	
	    Get byte value from flags
	    Get value of byte provided that the byte is initialized.
	    This macro works ok only for 8-bit byte machines.
	    

idc.calc_gtn_flags():
	
	    Calculate flags for get_ea_name() function
	
	    @param fromaddr: the referring address. May be BADADDR.
	    @param ea: linear address
	
	    @return: flags
	    

idc.call_system():
	
	    Execute an OS command.
	
	    @param command: command line to execute
	
	    @return: error code from OS
	
	    @note:
	    IDA will wait for the started program to finish.
	    In order to start the command in parallel, use OS methods.
	    For example, you may start another program in parallel using
	    "start" command.
	    

idc.can_exc_continue():
	
	    Can it continue after EXCEPTION event?
	
	    @return: boolean
	    

idc.check_bpt():
	
	  check_bpt(ea) -> int
	
	
	  Check the breakpoint at the specified address.
	  
	  @param ea (C++: ea_t)
	  @return: one of  Breakpoint status codes
	  

idc.choose_func():
	
	    Ask the user to select a function
	
	    Arguments:
	
	    @param title: title of the dialog box
	
	    @return: -1 - user refused to select a function
	             otherwise returns the selected function start address
	    

idc.clear_trace():
	
	    Clear the current trace buffer
	    

idc.create_align():
	
	  create_align(ea, length, alignment) -> bool
	
	
	  Alignment: 0 or 2..32. If it is 0, is will be calculated.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  @param alignment (C++: int)
	  

idc.create_array():
	
	    Create array.
	
	    @param name: The array name.
	
	    @return: -1 in case of failure, a valid array_id otherwise.
	    

idc.create_byte():
	
	    Convert the current item to a byte
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_custom_data():
	
	  create_custdata(ea, length, dtid, fid) -> bool
	
	
	  Convert to custom data type.
	  
	  
	  @param ea (C++: ea_t)
	  @param length (C++: asize_t)
	  @param dtid (C++: int)
	  @param fid (C++: int)
	  

idc.create_data():
	
	  create_data(ea, dataflag, size, tid) -> bool
	
	
	  Convert to data (byte, word, dword, etc). This function may be used to
	  create arrays.
	  
	  @param ea: linear address (C++: ea_t)
	  @param dataflag: type of data. Value of function  byte_flag() ,
	                   word_flag() , etc. (C++: flags_t)
	  @param size: size of array in bytes. should be divisible by the size
	               of one item of the specified type. for variable sized
	               items it can be specified as 0, and the kernel will try
	               to calculate the size. (C++: asize_t)
	  @param tid: type id. If the specified type is a structure, then tid is
	              structure id. Otherwise should be  BADNODE . (C++: tid_t)
	  @return: success
	  

idc.create_double():
	
	    Convert the current item to a double floating point (8 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_dword():
	
	    Convert the current item to a double word (4 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_float():
	
	    Convert the current item to a floating point (4 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_insn():
	
	  create_insn(ea, out=None) -> int
	
	
	  Create an instruction at the specified address. This function checks
	  if an instruction is present at the specified address and will try to
	  create one if there is none. It will fail if there is a data item or
	  other items hindering the creation of the new instruction. This
	  function will also fill the 'out' structure.
	  
	  @param ea: linear address (C++: ea_t)
	  @param out: the resulting instruction (C++: insn_t  *)
	  @return: the length of the instruction or 0
	  

idc.create_oword():
	
	    Convert the current item to an octa word (16 bytes/128 bits)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_pack_real():
	
	    Convert the current item to a packed real (10 or 12 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_qword():
	
	    Convert the current item to a quadro word (8 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_strlit():
	
	    Create a string.
	
	    This function creates a string (the string type is determined by the
	    value of get_inf_attr(INF_STRTYPE))
	
	    @param ea: linear address
	    @param endea: ending address of the string (excluded)
	        if endea == BADADDR, then length of string will be calculated
	        by the kernel
	
	    @return: 1-ok, 0-failure
	
	    @note: The type of an existing string is returned by get_str_type()
	    

idc.create_struct():
	
	    Convert the current item to a structure instance
	
	    @param ea: linear address
	    @param size: structure size in bytes. -1 means that the size
	        will be calculated automatically
	    @param strname: name of a structure type
	
	    @return: 1-ok, 0-failure
	    

idc.create_tbyte():
	
	    Convert the current item to a tbyte (10 or 12 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_word():
	
	    Convert the current item to a word (2 bytes)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.create_yword():
	
	    Convert the current item to a ymm word (32 bytes/256 bits)
	
	    @param ea: linear address
	
	    @return: 1-ok, 0-failure
	    

idc.define_exception():
	
	  define_exception(code, name, desc, flags) -> char const *
	
	
	  Convenience function: define new exception code.
	  
	  @param code: exception code (can not be 0) (C++: uint)
	  @param name: exception name (can not be empty or NULL) (C++: const
	               char *)
	  @param desc: exception description (maybe NULL) (C++: const char *)
	  @param flags: combination of  Exception info flags (C++: int)
	  @return: failure message or NULL. You must call  store_exceptions()
	           if this function succeeds
	  

idc.define_local_var():
	
	    Create a local variable
	
	    @param start: start of address range for the local variable
	    @param end: end of address range for the local variable
	    @param location: the variable location in the "[bp+xx]" form where xx is
	                     a number. The location can also be specified as a
	                     register name.
	    @param name: name of the local variable
	
	    @return: 1-ok, 0-failure
	
	    @note: For the stack variables the end address is ignored.
	           If there is no function at 'start' then this function.
	           will fail.
	    

idc.del_array_element():
	
	    Delete an array element.
	
	    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
	    @param array_id: The array ID.
	    @param idx: Index of an element.
	
	    @return: 1 in case of success, 0 otherwise.
	    

idc.del_bpt():
	
	    Delete breakpoint
	
	    @param ea: any address in the process memory space:
	
	    @return: success
	    

idc.del_cref():
	
	  del_cref(frm, to, expand) -> int
	
	
	  Delete a code cross-reference.
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @param expand: policy to delete the referenced instruction   1: plan
	                 to delete the referenced instruction if it has no more
	                 references. 0: don't delete the referenced instruction
	                 even if no more cross-references point to it (C++:
	                 bool)
	  

idc.del_dref():
	
	  del_dref(frm, to)
	
	
	  Delete a data cross-reference.
	  
	  @param to: linear address of referenced data (C++: ea_t)
	  

idc.del_enum():
	
	  del_enum(id)
	
	
	  Delete an enum type.
	  
	  
	  @param id (C++: enum_t)
	  

idc.del_enum_member():
	
	    Delete a member of enum - a symbolic constant
	
	    @param enum_id: id of enum
	    @param value: value of symbolic constant.
	    @param serial: serial number of the constant in the
	        enumeration. See op_enum() for for details.
	    @param bmask: bitmask of the constant ordinary enums accept
	        only ida_enum.DEFMASK as a bitmask
	
	    @return: 1-ok, 0-failed
	    

idc.del_extra_cmt():
	
	  del_extra_cmt(ea, what)
	  

idc.del_fixup():
	
	  del_fixup(source)
	
	
	  Delete fixup information.
	  
	  
	  @param source (C++: ea_t)
	  

idc.del_func():
	
	  del_func(ea) -> bool
	
	
	  Delete a function.
	  
	  @param ea: any address in the function entry chunk (C++: ea_t)
	  @return: success
	  

idc.del_hash_string():
	
	    Delete a hash element.
	
	    @param hash_id: The hash ID.
	    @param key: Key of an element
	
	    @return: 1 upon success, 0 otherwise.
	    

idc.del_hidden_range():
	
	  del_hidden_range(ea) -> bool
	
	
	  Delete hidden range.
	  
	  @param ea: any address in the hidden range (C++: ea_t)
	  @return: success
	  

idc.del_idc_hotkey():
	
	  del_idc_hotkey(hotkey) -> bool
	
	
	  Delete IDC function hotkey ( 'ui_del_idckey' ).
	  
	  @param hotkey: hotkey name (C++: const char *)
	  

idc.del_items():
	
	    Convert the current item to an explored item
	
	    @param ea: linear address
	    @param flags: combination of DELIT_* constants
	    @param size: size of the range to undefine
	
	    @return: None
	    

idc.del_segm():
	
	    Delete a segment
	
	    @param ea: any address in the segment
	    @param flags: combination of SEGMOD_* flags
	
	    @return: boolean success
	    

idc.del_selector():
	
	  del_selector(selector)
	
	
	  Delete mapping of a selector. Be wary of deleting selectors that are
	  being used in the program, this can make a mess in the segments.
	  
	  @param selector: number of selector to remove from the translation
	                   table (C++: sel_t)
	  

idc.del_source_linnum():
	
	  del_source_linnum(ea)
	  

idc.del_sourcefile():
	
	  del_sourcefile(ea) -> bool
	
	
	  Delete information about the source file.
	  
	  @param ea: linear address (C++: ea_t)
	  @return: success
	  

idc.del_stkpnt():
	
	    Delete SP register change point
	
	    @param func_ea: function start
	    @param ea: linear address
	    @return: 1-ok, 0-failed
	    

idc.del_struc():
	
	    Delete a structure type
	
	    @param sid: structure type ID
	
	    @return: 0 if bad structure type ID is passed
	             1 otherwise the structure type is deleted. All data
	             and other structure types referencing to the
	             deleted structure type will be displayed as array
	             of bytes.
	    

idc.del_struc_member():
	
	    Delete structure member
	
	    @param sid: structure type ID
	    @param member_offset: offset of the member
	
	    @return: != 0 - ok.
	
	    @note: IDA allows 'holes' between members of a
	           structure. It treats these 'holes'
	           as unnamed arrays of bytes.
	    

idc.delete_all_segments():
	
	    Delete all segments, instructions, comments, i.e. everything
	    except values of bytes.
	    

idc.delete_array():
	
	    Delete array, by its ID.
	
	    @param array_id: The ID of the array to delete.
	    

idc.demangle_name():
	
	    demangle_name a name
	
	    @param name: name to demangle
	    @param disable_mask: a mask that tells how to demangle the name
	            it is a good idea to get this mask using
	            get_inf_attr(INF_SHORT_DN) or get_inf_attr(INF_LONG_DN)
	
	    @return: a demangled name
	        If the input name cannot be demangled, returns None
	    

idc.detach_process():
	
	  detach_process() -> bool
	
	
	  Detach the debugger from the debugged process. {Type, Asynchronous
	  function - available as Request, Notification, 'dbg_process_detach' }
	  

idc.diff_trace_file():
	
	  diff_trace_file(nonnul_filename) -> bool
	
	
	  Show difference between the current trace and the one from 'filename'.
	  

idc.enable_bpt():
	
	    enable_bpt(ea, enable=True) -> bool
	    enable_bpt(bptloc, enable=True) -> bool
	    

idc.enable_tracing():
	
	    Enable step tracing
	
	    @param trace_level:  what kind of trace to modify
	    @param enable: 0: turn off, 1: turn on
	
	    @return: success
	    

idc.error():
	
	  error(format)
	
	
	  Display a fatal message in a message box and quit IDA
	  
	  @param format: message to print
	  

idc.eval_idc():
	
	    Evaluate an IDC expression
	
	    @param expr: an expression
	
	    @return: the expression value. If there are problems, the returned value will be "IDC_FAILURE: xxx"
	             where xxx is the error description
	
	    @note: Python implementation evaluates IDC only, while IDC can call other registered languages
	    

idc.exit_process():
	
	  exit_process() -> bool
	
	
	  Terminate the debugging of the current process. {Type, Asynchronous
	  function - available as Request, Notification, 'dbg_process_exit' }
	  

idc.expand_struc():
	
	    Expand or shrink a structure type
	    @param id: structure type ID
	    @param offset: offset in the structure
	    @param delta: how many bytes to add or remove
	    @param recalc: recalculate the locations where the structure
	                               type is used
	    @return: != 0 - ok
	    

idc.find_func_end():
	
	    Determine a new function boundaries
	
	    @param ea: starting address of a new function
	
	    @return: if a function already exists, then return its end address.
	            If a function end cannot be determined, the return BADADDR
	            otherwise return the end address of the new function
	    

idc.find_selector():
	
	    Find a selector which has the specifed value
	
	    @param val: value to search for
	
	    @return: the selector number if found,
	             otherwise the input value (val & 0xFFFF)
	
	    @note: selector values are always in paragraphs
	    

idc.first_func_chunk():
	
	    Get the first function chunk of the specified function
	
	    @param funcea: any address in the function
	
	    @return: the function entry point or BADADDR
	
	    @note: This function returns the first (main) chunk of the specified function
	    

idc.force_bl_call():
	
	    Force BL instruction to be a call
	
	    @param ea: address of the BL instruction
	
	    @return: 1-ok, 0-failed
	    

idc.force_bl_jump():
	
	    Some ARM compilers in Thumb mode use BL (branch-and-link)
	    instead of B (branch) for long jumps, since BL has more range.
	    By default, IDA tries to determine if BL is a jump or a call.
	    You can override IDA's decision using commands in Edit/Other menu
	    (Force BL call/Force BL jump) or the following two functions.
	
	    Force BL instruction to be a jump
	
	    @param ea: address of the BL instruction
	
	    @return: 1-ok, 0-failed
	    

idc.func_contains():
	
	    Does the given function contain the given address?
	
	    @param func_ea: any address belonging to the function
	    @param ea: linear address
	
	    @return:  success
	    

idc.gen_file():
	
	    Generate an output file
	
	    @param filetype:  type of output file. One of OFILE_... symbols. See below.
	    @param path:  the output file path (will be overwritten!)
	    @param ea1:   start address. For some file types this argument is ignored
	    @param ea2:   end address. For some file types this argument is ignored
	    @param flags: bit combination of GENFLG_...
	
	    @returns: number of the generated lines.
	                -1 if an error occurred
	                OFILE_EXE: 0-can't generate exe file, 1-ok
	    

idc.gen_flow_graph():
	
	    Generate a flow chart GDL file
	
	    @param outfile: output file name. GDL extension will be used
	    @param title: graph title
	    @param ea1: beginning of the range to flow chart
	    @param ea2: end of the range to flow chart.
	    @param flags: combination of CHART_... constants
	
	    @note: If ea2 == BADADDR then ea1 is treated as an address within a function.
	           That function will be flow charted.
	    

idc.gen_simple_call_chart():
	
	    Generate a function call graph GDL file
	
	    @param outfile: output file name. GDL extension will be used
	    @param title:   graph title
	    @param flags:   combination of CHART_GEN_GDL, CHART_WINGRAPH, CHART_NOLIBFUNCS
	    

idc.generate_disasm_line():
	
	    Get disassembly line
	
	    @param ea: linear address of instruction
	
	    @param flags: combination of the GENDSM_ flags, or 0
	
	    @return: "" - could not decode instruction at the specified location
	
	    @note: this function may not return exactly the same mnemonics
	           as you see on the screen.
	    

idc.get_array_element():
	
	    Get value of array element.
	
	    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
	    @param array_id: The array ID.
	    @param idx: Index of an element.
	
	    @return: Value of the specified array element. Note that
	             this function may return char or long result. Unexistent
	             array elements give zero as a result.
	    

idc.get_array_id():
	
	    Get array array_id, by name.
	
	    @param name: The array name.
	
	    @return: -1 in case of failure (i.e., no array with that
	             name exists), a valid array_id otherwise.
	    

idc.get_bmask_cmt():
	
	    Get bitmask comment (only for bitfields)
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant
	    @param repeatable: type of comment, 0-regular, 1-repeatable
	
	    @return: comment attached to bitmask or None
	    

idc.get_bmask_name():
	
	    Get bitmask name (only for bitfields)
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant
	
	    @return: name of bitmask or None
	    

idc.get_bookmark():
	
	  get_marked_pos(slot) -> ea_t
	  

idc.get_bookmark_desc():
	
	  get_mark_comment(slot) -> PyObject *
	  

idc.get_bpt_attr():
	
	    Get the characteristics of a breakpoint
	
	    @param ea: any address in the breakpoint range
	    @param bptattr: the desired attribute code, one of BPTATTR_... constants
	
	    @return: the desired attribute value or -1
	    

idc.get_bpt_ea():
	
	    Get breakpoint address
	
	    @param n: number of breakpoint, is in range 0..get_bpt_qty()-1
	
	    @return: address of the breakpoint or BADADDR
	    

idc.get_bpt_qty():
	
	    Get number of breakpoints.
	
	    @return: number of breakpoints
	    

idc.get_bpt_tev_ea():
	
	  get_bpt_tev_ea(n) -> ea_t
	
	
	  Get the address associated to a read, read/write or execution trace
	  event. {Type, Synchronous function, Notification, none (synchronous
	  function)}Usually, a breakpoint is associated with a read, read/write
	  or execution trace event. However, the returned address could be any
	  address in the range of this breakpoint. If the breakpoint was deleted
	  after the trace event, the address no longer corresponds to a valid
	  breakpoint.
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @return: BADADDR  if not a read, read/write or execution trace event.
	  

idc.get_bytes():
	
	    Return the specified number of bytes of the program
	
	    @param ea: linear address
	
	    @param size: size of buffer in normal 8-bit bytes
	
	    @param use_dbg: if True, use debugger memory, otherwise just the database
	
	    @return: None on failure
	             otherwise a string containing the read bytes
	    

idc.get_call_tev_callee():
	
	  get_call_tev_callee(n) -> ea_t
	
	
	  Get the called function from a function call trace event. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @return: BADADDR  if not a function call event.
	  

idc.get_cmt():
	
	  get_cmt(ea, rptble) -> ssize_t
	
	
	  Get an indented comment.
	  
	  @param ea: linear address. may point to tail byte, the function will
	             find start of the item (C++: ea_t)
	  @param rptble: get repeatable comment? (C++: bool)
	  @return: size of comment or -1
	  

idc.get_color():
	
	    Get item color
	
	    @param ea: address of the item
	    @param what: type of the item (one of  CIC_* constants)
	
	    @return: color code in RGB (hex 0xBBGGRR)
	    

idc.get_curline():
	
	    Get the disassembly line at the cursor
	
	    @return: string
	    

idc.get_current_thread():
	
	  get_current_thread() -> thid_t
	
	
	  Get current thread ID. {Type, Synchronous function, Notification, none
	  (synchronous function)}
	  

idc.get_db_byte():
	
	  get_db_byte(ea) -> uchar
	
	
	  Get one byte (8-bit) of the program at 'ea' from the database. Works
	  even if the debugger is active. See also 'get_dbg_byte()' to read the
	  process memory directly. This function works only for 8bit byte
	  processors.
	  
	  @param ea (C++: ea_t)
	  

idc.get_debugger_event_cond():
	
	  get_debugger_event_cond() -> char const *
	  

idc.get_entry():
	
	  get_entry(ord) -> ea_t
	
	
	  Get entry point address by its ordinal
	  
	  @param ord: ordinal number of entry point (C++: uval_t)
	  @return: address or  BADADDR
	  

idc.get_entry_name():
	
	  get_entry_name(ord) -> ssize_t
	
	
	  Get name of the entry point by its ordinal.
	  
	  @param ord: ordinal number of entry point (C++: uval_t)
	  @return: size of entry name or -1
	  

idc.get_entry_ordinal():
	
	  get_entry_ordinal(idx) -> uval_t
	
	
	  Get ordinal number of an entry point.
	  
	  @param idx: internal number of entry point. Should be in the range 0..
	              get_entry_qty() -1 (C++: size_t)
	  @return: ordinal number or 0.
	  

idc.get_entry_qty():
	
	  get_entry_qty() -> size_t
	
	
	  Get number of entry points.
	  

idc.get_enum():
	
	  get_enum(name) -> enum_t
	
	
	  Get enum by name.
	  
	  
	  @param name (C++: const char *)
	  

idc.get_enum_cmt():
	
	  get_enum_cmt(id, repeatable) -> ssize_t
	
	
	  Get enum comment.
	  
	  
	  @param id (C++: enum_t)
	  @param repeatable (C++: bool)
	  

idc.get_enum_flag():
	
	  get_enum_flag(id) -> flags_t
	
	
	  Get flags determining the representation of the enum. (currently they
	  define the numeric base: octal, decimal, hex, bin) and signness.
	  
	  @param id (C++: enum_t)
	  

idc.get_enum_idx():
	
	  get_enum_idx(id) -> uval_t
	
	
	  Get serial number of enum. The serial number determines the place of
	  the enum in the enum window.
	  
	  @param id (C++: enum_t)
	  

idc.get_enum_member():
	
	    Get id of constant
	
	    @param enum_id: id of enum
	    @param value: value of constant
	    @param serial: serial number of the constant in the
	              enumeration. See op_enum() for details.
	    @param bmask: bitmask of the constant
	              ordinary enums accept only ida_enum.DEFMASK as a bitmask
	
	    @return: id of constant or -1 if error
	    

idc.get_enum_member_bmask():
	
	  get_enum_member_bmask(id) -> bmask_t
	
	
	  Get bitmask of an enum member.
	  
	  
	  @param id (C++: const_t)
	  

idc.get_enum_member_by_name():
	
	  get_enum_member_by_name(name) -> const_t
	
	
	  Get a reference to an enum member by its name.
	  
	  
	  @param name (C++: const char *)
	  

idc.get_enum_member_cmt():
	
	    Get comment of a constant
	
	    @param const_id: id of const
	    @param repeatable: 0:get regular comment, 1:get repeatable comment
	
	    @return: comment string
	    

idc.get_enum_member_enum():
	
	  get_enum_member_enum(id) -> enum_t
	
	
	  Get the parent enum of an enum member.
	  
	  
	  @param id (C++: const_t)
	  

idc.get_enum_member_name():
	
	    Get name of a constant
	
	    @param const_id: id of const
	
	    Returns: name of constant
	    

idc.get_enum_member_value():
	
	  get_enum_member_value(id) -> uval_t
	
	
	  Get value of an enum member.
	  
	  
	  @param id (C++: const_t)
	  

idc.get_enum_name():
	
	  get_enum_name(id) -> ssize_t
	
	
	  Get name of enum.
	  
	  
	  @param id (C++: enum_t)
	  

idc.get_enum_qty():
	
	  get_enum_qty() -> size_t
	
	
	  Get number of declared 'enum_t' types.
	  

idc.get_enum_size():
	
	  get_enum_size(id) -> size_t
	
	
	  Get the number of the members of the enum.
	  
	  
	  @param id (C++: enum_t)
	  

idc.get_enum_width():
	
	  get_enum_width(id) -> size_t
	
	
	  Get the width of a enum element allowed values: 0
	  (unspecified),1,2,4,8,16,32,64
	  
	  @param id (C++: enum_t)
	  

idc.get_event_bpt_hea():
	
	    Get hardware address for BREAKPOINT event
	
	    @return: hardware address
	    

idc.get_event_ea():
	
	    Get ea for debug event
	
	    @return: ea
	    

idc.get_event_exc_code():
	
	    Get exception code for EXCEPTION event
	
	    @return: exception code
	    

idc.get_event_exc_ea():
	
	    Get address for EXCEPTION event
	
	    @return: adress of exception
	    

idc.get_event_exc_info():
	
	    Get info for EXCEPTION event
	
	    @return: info string
	    

idc.get_event_exit_code():
	
	    Get exit code for debug event
	
	    @return: exit code for PROCESS_EXITED, THREAD_EXITED events
	    

idc.get_event_id():
	
	    Get ID of debug event
	
	    @return: event ID
	    

idc.get_event_info():
	
	    Get debug event info
	
	    @return: event info: for THREAD_STARTED (thread name)
	                         for LIB_UNLOADED (unloaded library name)
	                         for INFORMATION (message to display)
	    

idc.get_event_module_base():
	
	    Get module base for debug event
	
	    @return: module base
	    

idc.get_event_module_name():
	
	    Get module name for debug event
	
	    @return: module name
	    

idc.get_event_module_size():
	
	    Get module size for debug event
	
	    @return: module size
	    

idc.get_event_pid():
	
	    Get process ID for debug event
	
	    @return: process ID
	    

idc.get_event_tid():
	
	    Get type ID for debug event
	
	    @return: type ID
	    

idc.get_extra_cmt():
	
	  get_extra_cmt(ea, what) -> ssize_t
	  

idc.get_fchunk_attr():
	
	    Get a function chunk attribute
	
	    @param ea: any address in the chunk
	    @param attr: one of: FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER, FUNCATTR_REFQTY
	
	    @return: desired attribute or -1
	    

idc.get_fchunk_referer():
	
	    Get a function chunk referer
	
	    @param ea: any address in the chunk
	    @param idx: referer index (0..get_fchunk_attr(FUNCATTR_REFQTY))
	
	    @return: referer address or BADADDR
	    

idc.get_first_bmask():
	
	  get_first_bmask(id) -> bmask_t
	
	
	  Get first bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @return: the smallest bitmask for enum, or DEFMASK
	  

idc.get_first_cref_from():
	
	  get_first_cref_from(frm) -> ea_t
	
	
	  Get first instruction referenced from the specified instruction. If
	  the specified instruction passes execution to the next instruction
	  then the next instruction is returned. Otherwise the lowest referenced
	  address is returned (remember that xrefs are kept sorted!).
	  
	  @return: first referenced address. The  lastXR  variable contains type
	           of the reference. If the specified instruction doesn't
	           reference to other instructions then returns  BADADDR .
	  

idc.get_first_cref_to():
	
	  get_first_cref_to(to) -> ea_t
	
	
	  Get first instruction referencing to the specified instruction. If the
	  specified instruction may be executed immediately after its previous
	  instruction then the previous instruction is returned. Otherwise the
	  lowest referencing address is returned. (remember that xrefs are kept
	  sorted!).
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @return: linear address of the first referencing instruction or
	           BADADDR . The  lastXR  variable contains type of the
	           reference.
	  

idc.get_first_dref_from():
	
	  get_first_dref_from(frm) -> ea_t
	
	
	  Get first data referenced from the specified address.
	  
	  @return: linear address of first (lowest) data referenced from the
	           specified address. The  lastXR  variable contains type of the
	           reference. Return  BADADDR  if the specified instruction/data
	           doesn't reference to anything.
	  

idc.get_first_dref_to():
	
	  get_first_dref_to(to) -> ea_t
	
	
	  Get address of instruction/data referencing to the specified data.
	  
	  @param to: linear address of referencing instruction or data (C++:
	             ea_t)
	  @return: BADADDR  if nobody refers to the specified data. The  lastXR
	           variable contains type of the reference.
	  

idc.get_first_enum_member():
	
	    Get first constant in the enum
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
	
	    @return: value of constant or idaapi.BADNODE no constants are defined
	             All constants are sorted by their values as unsigned longs.
	    

idc.get_first_fcref_from():
	
	  get_first_fcref_from(frm) -> ea_t
	  

idc.get_first_fcref_to():
	
	  get_first_fcref_to(to) -> ea_t
	  

idc.get_first_hash_key():
	
	    Get the first key in the hash.
	
	    @param hash_id: The hash ID.
	
	    @return: the key, 0 otherwise.
	    

idc.get_first_index():
	
	    Get index of the first existing array element.
	
	    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
	    @param array_id: The array ID.
	
	    @return: -1 if the array is empty, otherwise index of first array
	             element of given type.
	    

idc.get_first_member():
	
	    Get offset of the first member of a structure
	
	    @param sid: structure type ID
	
	    @return: -1 if bad structure type ID is passed,
	             ida_idaapi.BADADDR if structure has no members,
	             otherwise returns offset of the first member.
	
	    @note: IDA allows 'holes' between members of a
	           structure. It treats these 'holes'
	           as unnamed arrays of bytes.
	
	    @note: Union members are, in IDA's internals, located
	           at subsequent byte offsets: member 0 -> offset 0x0,
	           member 1 -> offset 0x1, etc...
	    

idc.get_first_module():
	
	    Enumerate process modules
	
	    @return: first module's base address or None on failure
	    

idc.get_first_seg():
	
	    Get first segment
	
	    @return: address of the start of the first segment
	        BADADDR - no segments are defined
	    

idc.get_first_struc_idx():
	
	  get_first_struc_idx() -> uval_t
	
	
	  Get index of first structure.
	  
	  @return: BADADDR  if no known structures, 0 otherwise
	  

idc.get_fixup_target_dis():
	
	    Get fixup target displacement
	
	    @param ea: address to get information about
	
	    @return: 0 - no fixup at the specified address
	                 otherwise returns fixup target displacement
	    

idc.get_fixup_target_flags():
	
	    Get fixup target flags
	
	    @param ea: address to get information about
	
	    @return: 0 - no fixup at the specified address
	                 otherwise returns fixup target flags
	    

idc.get_fixup_target_off():
	
	    Get fixup target offset
	
	    @param ea: address to get information about
	
	    @return: BADADDR - no fixup at the specified address
	                       otherwise returns fixup target offset
	    

idc.get_fixup_target_sel():
	
	    Get fixup target selector
	
	    @param ea: address to get information about
	
	    @return: BADSEL - no fixup at the specified address
	                      otherwise returns fixup target selector
	    

idc.get_fixup_target_type():
	
	    Get fixup target type
	
	    @param ea: address to get information about
	
	    @return: 0 - no fixup at the specified address
	                 otherwise returns fixup type
	    

idc.get_forced_operand():
	
	  get_forced_operand(ea, n) -> ssize_t
	
	
	  Get forced operand.
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, 2) (C++: int)
	  @return: size of forced operand or -1
	  

idc.get_frame_args_size():
	
	    Get size of arguments in function frame which are purged upon return
	
	    @param ea: any address belonging to the function
	
	    @return: Size of function arguments in bytes.
	             If the function doesn't have a frame, return 0
	             If the function does't exist, return -1
	    

idc.get_frame_id():
	
	    Get ID of function frame structure
	
	    @param ea: any address belonging to the function
	
	    @return: ID of function frame or None In order to access stack variables
	             you need to use structure member manipulaion functions with the
	             obtained ID.
	    

idc.get_frame_lvar_size():
	
	    Get size of local variables in function frame
	
	    @param ea: any address belonging to the function
	
	    @return: Size of local variables in bytes.
	             If the function doesn't have a frame, return 0
	             If the function does't exist, return None
	    

idc.get_frame_regs_size():
	
	    Get size of saved registers in function frame
	
	    @param ea: any address belonging to the function
	
	    @return: Size of saved registers in bytes.
	             If the function doesn't have a frame, return 0
	             This value is used as offset for BP (if FUNC_FRAME is set)
	             If the function does't exist, return None
	    

idc.get_frame_size():
	
	    Get full size of function frame
	
	    @param ea: any address belonging to the function
	    @returns: Size of function frame in bytes.
	                This function takes into account size of local
	                variables + size of saved registers + size of
	                return address + size of function arguments
	                If the function doesn't have a frame, return size of
	                function return address in the stack.
	                If the function does't exist, return 0
	    

idc.get_full_flags():
	
	  get_full_flags(ea) -> flags_t
	
	
	  Get flags value for address 'ea'.
	  
	  @param ea (C++: ea_t)
	  @return: 0 if address is not present in the program
	  

idc.get_func_attr():
	
	    Get a function attribute
	
	    @param ea: any address belonging to the function
	    @param attr: one of FUNCATTR_... constants
	
	    @return: BADADDR - error otherwise returns the attribute value
	    

idc.get_func_cmt():
	
	    Retrieve function comment
	
	    @param ea: any address belonging to the function
	    @param repeatable: 1: get repeatable comment
	            0: get regular comment
	
	    @return: function comment string
	    

idc.get_func_flags():
	
	    Retrieve function flags
	
	    @param ea: any address belonging to the function
	
	    @return: -1 - function doesn't exist otherwise returns the flags
	    

idc.get_func_name():
	
	    Retrieve function name
	
	    @param ea: any address belonging to the function
	
	    @return: null string - function doesn't exist
	            otherwise returns function name
	    

idc.get_func_off_str():
	
	    Convert address to 'funcname+offset' string
	
	    @param ea: address to convert
	
	    @return: if the address belongs to a function then return a string
	             formed as 'name+offset' where 'name' is a function name
	             'offset' is offset within the function else return null string
	    

idc.get_hash_long():
	
	    Gets the long value of a hash element.
	
	    @param hash_id: The hash ID.
	    @param key: Key of an element.
	
	    @return: the 32bit or 64bit value of the element, or 0 if no such
	             element.
	    

idc.get_hash_string():
	
	    Gets the string value of a hash element.
	
	    @param hash_id: The hash ID.
	    @param key: Key of an element.
	
	    @return: the string value of the element, or None if no such
	             element.
	    

idc.get_idb_path():
	
	    Get IDB full path
	
	    This function returns full path of the current IDB database
	    

idc.get_inf_attr():
	
	    

idc.get_input_file_path():
	
	  get_input_file_path() -> ssize_t
	
	
	  Get full path of the input file.
	  

idc.get_item_end():
	
	  get_item_end(ea) -> ea_t
	
	
	  Get the end address of the item at 'ea'. The returned address doesn't
	  belong to the current item. Unexplored bytes are counted as 1 byte
	  entities.
	  
	  @param ea (C++: ea_t)
	  

idc.get_item_head():
	
	  get_item_head(ea) -> ea_t
	
	
	  Get the start address of the item at 'ea'. If there is no current
	  item, then 'ea' will be returned (see definition at the end of
	  'bytes.hpp' source)
	  
	  @param ea (C++: ea_t)
	  

idc.get_item_size():
	
	    Get size of instruction or data item in bytes
	
	    @param ea: linear address
	
	    @return: 1..n
	    

idc.get_last_bmask():
	
	  get_last_bmask(id) -> bmask_t
	
	
	  Get last bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @return: the biggest bitmask for enum, or DEFMASK
	  

idc.get_last_enum_member():
	
	    Get last constant in the enum
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
	
	    @return: value of constant or idaapi.BADNODE no constants are defined
	             All constants are sorted by their values
	             as unsigned longs.
	    

idc.get_last_hash_key():
	
	    Get the last key in the hash.
	
	    @param hash_id: The hash ID.
	
	    @return: the key, 0 otherwise.
	    

idc.get_last_index():
	
	    Get index of last existing array element.
	
	    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
	    @param array_id: The array ID.
	
	    @return: -1 if the array is empty, otherwise index of first array
	             element of given type.
	    

idc.get_last_member():
	
	    Get offset of the last member of a structure
	
	    @param sid: structure type ID
	
	    @return: -1 if bad structure type ID is passed,
	             ida_idaapi.BADADDR if structure has no members,
	             otherwise returns offset of the last member.
	
	    @note: IDA allows 'holes' between members of a
	          structure. It treats these 'holes'
	          as unnamed arrays of bytes.
	
	    @note: Union members are, in IDA's internals, located
	           at subsequent byte offsets: member 0 -> offset 0x0,
	           member 1 -> offset 0x1, etc...
	    

idc.get_last_struc_idx():
	
	  get_last_struc_idx() -> uval_t
	
	
	  Get index of last structure.
	  
	  @return: BADADDR  if no known structures,  get_struc_qty() -1
	           otherwise
	  

idc.get_local_tinfo():
	
	    Get local type information as 'typeinfo' object
	
	    @param ordinal:  slot number (1...NumberOfLocalTypes)
	    @return: None on failure, or (type, fields, name) tuple.
	    

idc.get_manual_insn():
	
	  get_manual_insn(ea) -> ssize_t
	
	
	  Retrieve the user-specified string for the manual instruction.
	  
	  @param ea: linear address of the instruction or data item (C++: ea_t)
	  @return: size of manual instruction or -1
	  

idc.get_member_cmt():
	
	    Get comment of a member
	
	    @param sid: structure type ID
	    @param member_offset: member offset. The offset can be
	                          any offset in the member. For example,
	                          is a member is 4 bytes long and starts
	                          at offset 2, then 2,3,4,5 denote
	                          the same structure member.
	    @param repeatable: 1: get repeatable comment
	                       0: get regular comment
	
	    @return: None if bad structure type ID is passed
	             or no such member in the structure
	             otherwise returns comment of the specified member.
	    

idc.get_member_flag():
	
	    Get type of a member
	
	    @param sid: structure type ID
	    @param member_offset: member offset. The offset can be
	                          any offset in the member. For example,
	                          is a member is 4 bytes long and starts
	                          at offset 2, then 2,3,4,5 denote
	                          the same structure member.
	
	    @return: -1 if bad structure type ID is passed
	             or no such member in the structure
	             otherwise returns type of the member, see bit
	             definitions above. If the member type is a structure
	             then function GetMemberStrid() should be used to
	             get the structure type id.
	    

idc.get_member_id():
	
	    @param sid: structure type ID
	    @param member_offset:. The offset can be
	    any offset in the member. For example,
	    is a member is 4 bytes long and starts
	    at offset 2, then 2,3,4,5 denote
	    the same structure member.
	
	    @return: -1 if bad structure type ID is passed or there is
	    no member at the specified offset.
	    otherwise returns the member id.
	    

idc.get_member_name():
	
	    Get name of a member of a structure
	
	    @param sid: structure type ID
	    @param member_offset: member offset. The offset can be
	                          any offset in the member. For example,
	                          is a member is 4 bytes long and starts
	                          at offset 2, then 2,3,4,5 denote
	                          the same structure member.
	
	    @return: None if bad structure type ID is passed
	             or no such member in the structure
	             otherwise returns name of the specified member.
	    

idc.get_member_offset():
	
	    Get offset of a member of a structure by the member name
	
	    @param sid: structure type ID
	    @param member_name: name of structure member
	
	    @return: -1 if bad structure type ID is passed
	             or no such member in the structure
	             otherwise returns offset of the specified member.
	
	    @note: Union members are, in IDA's internals, located
	           at subsequent byte offsets: member 0 -> offset 0x0,
	           member 1 -> offset 0x1, etc...
	    

idc.get_member_qty():
	
	    Get number of members of a structure
	
	    @param sid: structure type ID
	
	    @return: -1 if bad structure type ID is passed otherwise
	             returns number of members.
	
	    @note: Union members are, in IDA's internals, located
	           at subsequent byte offsets: member 0 -> offset 0x0,
	           member 1 -> offset 0x1, etc...
	    

idc.get_member_size():
	
	    Get size of a member
	
	    @param sid: structure type ID
	    @param member_offset: member offset. The offset can be
	                          any offset in the member. For example,
	                          is a member is 4 bytes long and starts
	                          at offset 2, then 2,3,4,5 denote
	                          the same structure member.
	
	    @return: None if bad structure type ID is passed,
	             or no such member in the structure
	             otherwise returns size of the specified
	             member in bytes.
	    

idc.get_member_strid():
	
	    Get structure id of a member
	
	    @param sid: structure type ID
	    @param member_offset: member offset. The offset can be
	                          any offset in the member. For example,
	                          is a member is 4 bytes long and starts
	                          at offset 2, then 2,3,4,5 denote
	                          the same structure member.
	    @return: -1 if bad structure type ID is passed
	             or no such member in the structure
	             otherwise returns structure id of the member.
	             If the current member is not a structure, returns -1.
	    

idc.get_min_spd_ea():
	
	    Return the address with the minimal spd (stack pointer delta)
	    If there are no SP change points, then return BADADDR.
	
	    @param func_ea: function start
	    @return: BADDADDR - no such function
	    

idc.get_module_name():
	
	    Get process module name
	
	    @param base: the base address of the module
	
	    @return: required info or None
	    

idc.get_module_size():
	
	    Get process module size
	
	    @param base: the base address of the module
	
	    @return: required info or -1
	    

idc.get_name():
	
	    Get name at the specified address
	
	    @param ea: linear address
	    @param gtn_flags: how exactly the name should be retrieved.
	                      combination of GN_ bits
	
	    @return: "" - byte has no name
	    

idc.get_name_ea():
	
	  get_name_ea(_from, name) -> ea_t
	
	
	  Get address of the name. Dummy names (like byte_xxxx where xxxx are
	  hex digits) are parsed by this function to obtain the address. The
	  database is not consulted for them. This function works only with
	  regular names.
	  
	  @param _from: linear address where the name is used. if not
	                applicable, then should be  BADADDR . (C++: ea_t)
	  @param name: any name in the program or NULL (C++: const char *)
	  @return: address of the name or  BADADDR
	  

idc.get_name_ea_simple():
	
	    Get linear address of a name
	
	    @param name: name of program byte
	
	    @return: address of the name
	             BADADDR - No such name
	    

idc.get_next_bmask():
	
	  get_next_bmask(id, bmask) -> bmask_t
	
	
	  Get next bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @param bmask (C++: bmask_t)
	  @return: value of a bitmask with value higher than the specified
	           value, or DEFMASK
	  

idc.get_next_cref_from():
	
	  get_next_cref_from(frm, current) -> ea_t
	
	
	  Get next instruction referenced from the specified instruction.
	  
	  @param current: linear address of current referenced instruction This
	                  value is returned by  get_first_cref_from()  or
	                  previous call to  get_next_cref_from()  functions.
	                  (C++: ea_t)
	  @return: next referenced address or  BADADDR . The  lastXR  variable
	           contains type of the reference.
	  

idc.get_next_cref_to():
	
	  get_next_cref_to(to, current) -> ea_t
	
	
	  Get next instruction referencing to the specified instruction.
	  
	  @param to: linear address of referenced instruction (C++: ea_t)
	  @param current: linear address of current referenced instruction This
	                  value is returned by  get_first_cref_to()  or previous
	                  call to  get_next_cref_to()  functions. (C++: ea_t)
	  @return: linear address of the next referencing instruction or
	           BADADDR . The  lastXR  variable contains type of the
	           reference.
	  

idc.get_next_dref_from():
	
	  get_next_dref_from(frm, current) -> ea_t
	
	
	  Get next data referenced from the specified address.
	  
	  @param current: linear address of current referenced data. This value
	                  is returned by  get_first_dref_from()  or previous
	                  call to  get_next_dref_from()  functions. (C++: ea_t)
	  @return: linear address of next data or  BADADDR . The  lastXR
	           variable contains type of the reference
	  

idc.get_next_dref_to():
	
	  get_next_dref_to(to, current) -> ea_t
	
	
	  Get address of instruction/data referencing to the specified data
	  
	  @param to: linear address of referencing instruction or data (C++:
	             ea_t)
	  @param current: current linear address. This value is returned by
	                  get_first_dref_to()  or previous call to
	                  get_next_dref_to()  functions. (C++: ea_t)
	  @return: BADADDR  if nobody refers to the specified data. The  lastXR
	           variable contains type of the reference.
	  

idc.get_next_enum_member():
	
	    Get next constant in the enum
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant ordinary enums accept only ida_enum.DEFMASK as a bitmask
	    @param value: value of the current constant
	
	    @return: value of a constant with value higher than the specified
	             value. idaapi.BADNODE no such constants exist.
	             All constants are sorted by their values as unsigned longs.
	    

idc.get_next_fchunk():
	
	    Get next function chunk
	
	    @param ea: any address
	
	    @return:  the starting address of the next function chunk or BADADDR
	
	    @note: This function enumerates all chunks of all functions in the database
	    

idc.get_next_fcref_from():
	
	  get_next_fcref_from(frm, current) -> ea_t
	  

idc.get_next_fcref_to():
	
	  get_next_fcref_to(to, current) -> ea_t
	  

idc.get_next_fixup_ea():
	
	  get_next_fixup_ea(ea) -> ea_t
	
	
	  Find next address with fixup information
	  
	  @param ea: current address (C++: ea_t)
	  @return: the next address with fixup information, or BADADDR
	  

idc.get_next_func():
	
	    Find next function
	
	    @param ea: any address belonging to the function
	
	    @return:        BADADDR - no more functions
	            otherwise returns the next function start address
	    

idc.get_next_hash_key():
	
	    Get the next key in the hash.
	
	    @param hash_id: The hash ID.
	    @param key: The current key.
	
	    @return: the next key, 0 otherwise
	    

idc.get_next_index():
	
	    Get index of the next existing array element.
	
	    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
	    @param array_id: The array ID.
	    @param idx: Index of the current element.
	
	    @return: -1 if no more elements, otherwise returns index of the
	             next array element of given type.
	    

idc.get_next_module():
	
	    Enumerate process modules
	
	    @param base: previous module's base address
	
	    @return: next module's base address or None on failure
	    

idc.get_next_offset():
	
	    Get next offset in a structure
	
	    @param sid:     structure type ID
	    @param offset: current offset
	
	    @return: -1 if bad structure type ID is passed,
	             ida_idaapi.BADADDR if no (more) offsets in the structure,
	             otherwise returns next offset in a structure.
	
	    @note: IDA allows 'holes' between members of a
	           structure. It treats these 'holes'
	           as unnamed arrays of bytes.
	           This function returns a member offset or a hole offset.
	           It will return size of the structure if input
	           'offset' belongs to the last member of the structure.
	
	    @note: Union members are, in IDA's internals, located
	           at subsequent byte offsets: member 0 -> offset 0x0,
	           member 1 -> offset 0x1, etc...
	    

idc.get_next_seg():
	
	    Get next segment
	
	    @param ea: linear address
	
	    @return: start of the next segment
	             BADADDR - no next segment
	    

idc.get_next_struc_idx():
	
	  get_next_struc_idx(idx) -> uval_t
	
	
	  Get next struct index.
	  
	  @param idx (C++: uval_t)
	  @return: BADADDR  if resulting index is out of bounds, otherwise idx++
	  

idc.get_numbered_type_name():
	
	    Retrieve a local type name
	
	    @param ordinal:  slot number (1...NumberOfLocalTypes)
	
	    returns: local type name or None
	    

idc.get_operand_type():
	
	    Get type of instruction operand
	
	    @param ea: linear address of instruction
	    @param n: number of operand:
	        0 - the first operand
	        1 - the second operand
	
	    @return: any of o_* constants or -1 on error
	    

idc.get_operand_value():
	
	    Get number used in the operand
	
	    This function returns an immediate number used in the operand
	
	    @param ea: linear address of instruction
	    @param n: the operand number
	
	    @return: value
	        operand is an immediate value  => immediate value
	        operand has a displacement     => displacement
	        operand is a direct memory ref => memory address
	        operand is a register          => register number
	        operand is a register phrase   => phrase number
	        otherwise                      => -1
	    

idc.get_ordinal_qty():
	
	    Get number of local types + 1
	
	    @return: value >= 1. 1 means that there are no local types.
	    

idc.get_original_byte():
	
	  get_original_byte(ea) -> uint64
	
	
	  Get original byte value (that was before patching). This function
	  works for wide byte processors too.
	  
	  @param ea (C++: ea_t)
	  

idc.get_prev_bmask():
	
	  get_prev_bmask(id, bmask) -> bmask_t
	
	
	  Get prev bitmask in the enum (bitfield)
	  
	  @param id (C++: enum_t)
	  @param bmask (C++: bmask_t)
	  @return: value of a bitmask with value lower than the specified value,
	           or DEFMASK
	  

idc.get_prev_enum_member():
	
	    Get prev constant in the enum
	
	    @param enum_id: id of enum
	    @param bmask  : bitmask of the constant
	              ordinary enums accept only ida_enum.DEFMASK as a bitmask
	    @param value: value of the current constant
	
	    @return: value of a constant with value lower than the specified
	        value. idaapi.BADNODE no such constants exist.
	        All constants are sorted by their values as unsigned longs.
	    

idc.get_prev_fchunk():
	
	    Get previous function chunk
	
	    @param ea: any address
	
	    @return: the starting address of the function chunk or BADADDR
	
	    @note: This function enumerates all chunks of all functions in the database
	    

idc.get_prev_fixup_ea():
	
	  get_prev_fixup_ea(ea) -> ea_t
	
	
	  Find previous address with fixup information
	  
	  @param ea: current address (C++: ea_t)
	  @return: the previous address with fixup information, or BADADDR
	  

idc.get_prev_func():
	
	    Find previous function
	
	    @param ea: any address belonging to the function
	
	    @return: BADADDR - no more functions
	            otherwise returns the previous function start address
	    

idc.get_prev_hash_key():
	
	    Get the previous key in the hash.
	
	    @param hash_id: The hash ID.
	    @param key: The current key.
	
	    @return: the previous key, 0 otherwise
	    

idc.get_prev_index():
	
	    Get index of the previous existing array element.
	
	    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
	    @param array_id: The array ID.
	    @param idx: Index of the current element.
	
	    @return: -1 if no more elements, otherwise returns index of the
	             previous array element of given type.
	    

idc.get_prev_offset():
	
	    Get previous offset in a structure
	
	    @param sid: structure type ID
	    @param offset: current offset
	
	    @return: -1 if bad structure type ID is passed,
	             ida_idaapi.BADADDR if no (more) offsets in the structure,
	             otherwise returns previous offset in a structure.
	
	    @note: IDA allows 'holes' between members of a
	           structure. It treats these 'holes'
	           as unnamed arrays of bytes.
	           This function returns a member offset or a hole offset.
	           It will return size of the structure if input
	           'offset' is bigger than the structure size.
	
	    @note: Union members are, in IDA's internals, located
	           at subsequent byte offsets: member 0 -> offset 0x0,
	           member 1 -> offset 0x1, etc...
	    

idc.get_prev_struc_idx():
	
	  get_prev_struc_idx(idx) -> uval_t
	
	
	  Get previous struct index.
	  
	  @param idx (C++: uval_t)
	  @return: BADADDR  if resulting index is negative, otherwise idx - 1
	  

idc.get_process_state():
	
	  get_process_state() -> int
	
	
	  Return the state of the currently debugged process. {Type, Synchronous
	  function, Notification, none (synchronous function)}
	  
	  @return: one of  Debugged process states
	  

idc.get_processes():
	
	  get_processes(proclist) -> ssize_t
	
	
	  Take a snapshot of running processes and return their description.
	  {Type, Synchronous function, Notification, none (synchronous
	  function)}
	  
	  @param proclist (C++: procinfo_vec_t  *)
	  @return: number of processes or -1 on error
	  

idc.get_qword():
	
	  get_qword(ea) -> uint64
	
	
	  Get one qword (64-bit) of the program at 'ea'. This function takes
	  into account order of bytes specified in {is_be()} This function works
	  only for 8bit byte processors.
	  
	  @param ea (C++: ea_t)
	  

idc.get_reg_value():
	
	    Get register value
	
	    @param name: the register name
	
	    @note: The debugger should be running. otherwise the function fails
	           the register name should be valid.
	           It is not necessary to use this function to get register values
	           because a register name in the script will do too.
	
	    @return: register value (integer or floating point)
	    

idc.get_ret_tev_return():
	
	  get_ret_tev_return(n) -> ea_t
	
	
	  Get the return address from a function return trace event. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  
	  @param n: number of trace event, is in range 0.. get_bpt_qty() -1. 0
	            represents the latest added trace event. (C++: int)
	  @return: BADADDR  if not a function return event.
	  

idc.get_root_filename():
	
	  get_root_filename() -> ssize_t
	
	
	  Get file name only of the input file.
	  

idc.get_screen_ea():
	
	  get_screen_ea() -> ea_t
	
	
	  Get the address at the screen cursor ( 'ui_screenea' )
	  

idc.get_segm_attr():
	
	    Get segment attribute
	
	    @param segea: any address within segment
	    @param attr: one of SEGATTR_... constants
	    

idc.get_segm_by_sel():
	
	    Get segment by segment base
	
	    @param base: segment base paragraph or selector
	
	    @return: linear address of the start of the segment or BADADDR
	             if no such segment
	    

idc.get_segm_end():
	
	    Get end address of a segment
	
	    @param ea: any address in the segment
	
	    @return: end of segment (an address past end of the segment)
	             BADADDR - the specified address doesn't belong to any segment
	    

idc.get_segm_name():
	
	    Get name of a segment
	
	    @param ea: any address in the segment
	
	    @return: "" - no segment at the specified address
	    

idc.get_segm_start():
	
	    Get start address of a segment
	
	    @param ea: any address in the segment
	
	    @return: start of segment
	             BADADDR - the specified address doesn't belong to any segment
	    

idc.get_source_linnum():
	
	  get_source_linnum(ea) -> uval_t
	  

idc.get_sourcefile():
	
	  get_sourcefile(ea, bounds=None) -> char const *
	
	
	  Get name of source file occupying the given address.
	  
	  @param ea: linear address (C++: ea_t)
	  @param bounds: pointer to the output buffer with the address range for
	                 the current file. May be NULL. (C++: range_t  *)
	  @return: NULL if source file information is not found, otherwise
	           returns pointer to file name
	  

idc.get_sp_delta():
	
	    Get modification of SP made by the instruction
	
	    @param ea: end address of the instruction
	               i.e.the last address of the instruction+1
	
	    @return: Get modification of SP made at the specified location
	             If the specified location doesn't contain a SP change point, return 0
	             Otherwise return delta of SP modification
	    

idc.get_spd():
	
	    Get current delta for the stack pointer
	
	    @param ea: end address of the instruction
	               i.e.the last address of the instruction+1
	
	    @return: The difference between the original SP upon
	             entering the function and SP for the specified address
	    

idc.get_sreg():
	
	    Get value of segment register at the specified address
	
	    @param ea: linear address
	    @param reg: name of segment register
	
	    @return: the value of the segment register or -1 on error
	
	    @note: The segment registers in 32bit program usually contain selectors,
	           so to get paragraph pointed to by the segment register you need to
	           call sel2para() function.
	    

idc.get_step_trace_options():
	
	  get_step_trace_options() -> int
	
	
	  Get current step tracing options. {Type, Synchronous function,
	  Notification, none (synchronous function)}
	  
	  @return: Step trace options
	  

idc.get_str_type():
	
	    Get string type
	
	    @param ea: linear address
	
	    @return: One of STRTYPE_... constants
	    

idc.get_strlit_contents():
	
	    Get string contents
	    @param ea: linear address
	    @param length: string length. -1 means to calculate the max string length
	    @param strtype: the string type (one of STRTYPE_... constants)
	
	    @return: string contents or empty string
	    

idc.get_struc_by_idx():
	
	  get_struc_by_idx(idx) -> tid_t
	
	
	  Get struct id by struct number.
	  
	  
	  @param idx (C++: uval_t)
	  

idc.get_struc_cmt():
	
	  get_struc_cmt(id, repeatable) -> ssize_t
	
	
	  Get struct comment.
	  
	  
	  @param id (C++: tid_t)
	  @param repeatable (C++: bool)
	  

idc.get_struc_id():
	
	  get_struc_id(name) -> tid_t
	
	
	  Get struct id by name.
	  
	  
	  @param name (C++: const char *)
	  

idc.get_struc_idx():
	
	  get_struc_idx(id) -> uval_t
	
	
	  Get internal number of the structure.
	  
	  
	  @param id (C++: tid_t)
	  

idc.get_struc_name():
	
	  get_struc_name(id) -> ssize_t
	
	
	  Get struct name by id.
	  
	  
	  @param id (C++: tid_t)
	  

idc.get_struc_qty():
	
	  get_struc_qty() -> size_t
	
	
	  Get number of known structures.
	  

idc.get_struc_size():
	
	    get_struc_size(sptr) -> asize_t
	    get_struc_size(id) -> asize_t
	
	
	  Get struct size (also see 'get_struc_size(tid_t)' )
	  
	  
	  @param sptr (C++: const  struc_t  *)
	    

idc.get_tev_ea():
	
	  get_tev_ea(n) -> ea_t
	  

idc.get_tev_qty():
	
	  get_tev_qty() -> int
	
	
	  Get number of trace events available in trace buffer. {Type,
	  Synchronous function, Notification, none (synchronous function)}
	  

idc.get_tev_tid():
	
	  get_tev_tid(n) -> int
	  

idc.get_tev_type():
	
	  get_tev_type(n) -> int
	  

idc.get_thread_qty():
	
	  get_thread_qty() -> int
	
	
	  Get number of threads. {Type, Synchronous function, Notification, none
	  (synchronous function)}
	  

idc.get_tinfo():
	
	    Get type information of function/variable as 'typeinfo' object
	
	    @param ea: the address of the object
	    @return: None on failure, or (type, fields) tuple.
	    

idc.get_trace_file_desc():
	
	  get_trace_file_desc(filename) -> bool
	
	
	  Get the file header of the specified trace file.
	  
	  
	  @param filename (C++: const char *)
	  

idc.get_type():
	
	    Get type of function/variable
	
	    @param ea: the address of the object
	
	    @return: type string or None if failed
	    

idc.get_wide_byte():
	
	  get_wide_byte(ea) -> uint64
	
	
	  Get one wide byte of the program at 'ea'. Some processors may access
	  more than 8bit quantity at an address. These processors have 32-bit
	  byte organization from the IDA's point of view.
	  
	  @param ea (C++: ea_t)
	  

idc.get_wide_dword():
	
	  get_wide_dword(ea) -> uint64
	
	
	  Get two wide words (4 'bytes') of the program at 'ea'. Some processors
	  may access more than 8bit quantity at an address. These processors
	  have 32-bit byte organization from the IDA's point of view. This
	  function takes into account order of bytes specified in {is_be()}this
	  function works incorrectly if {nbits} > 16
	  
	  @param ea (C++: ea_t)
	  

idc.get_wide_word():
	
	  get_wide_word(ea) -> uint64
	
	
	  Get one wide word (2 'byte') of the program at 'ea'. Some processors
	  may access more than 8bit quantity at an address. These processors
	  have 32-bit byte organization from the IDA's point of view. This
	  function takes into account order of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  

idc.get_xref_type():
	
	    Return type of the last xref obtained by
	    [RD]first/next[B0] functions.
	
	    @return: constants fl_* or dr_*
	    

idc.getn_enum():
	
	  getn_enum(n) -> enum_t
	
	
	  Get enum by its ordinal number (0..n).
	  
	  
	  @param n (C++: size_t)
	  

idc.getn_thread():
	
	  getn_thread(n) -> thid_t
	
	
	  Get the ID of a thread. {Type, Synchronous function, Notification,
	  none (synchronous function)}
	  
	  @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
	            int)
	  @return: NO_THREAD  if the thread doesn't exist.
	  

idc.getn_thread_name():
	
	  getn_thread_name(n) -> char const *
	
	
	  Get the NAME of a thread {Type, Synchronous function, Notification,
	  none (synchronous function)}
	  
	  @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
	            for the current thread (C++: int)
	  @return: thread name or NULL if the thread doesn't exist.
	  

idc.guess_type():
	
	    Guess type of function/variable
	
	    @param ea: the address of the object, can be the structure member id too
	
	    @return: type string or None if failed
	    

idc.idadir():
	
	    Get IDA directory
	
	    This function returns the directory where IDA.EXE resides
	    

idc.import_type():
	
	    Copy information from type library to database
	    Copy structure, union, or enum definition from the type library
	    to the IDA database.
	
	    @param idx: the position of the new type in the list of
	                types (structures or enums) -1 means at the end of the list
	    @param type_name: name of type to copy
	
	    @return: BADNODE-failed, otherwise the type id (structure id or enum id)
	    

idc.is_bf():
	
	  is_bf(id) -> bool
	
	
	  Is enum a bitfield? (otherwise - plain enum, no bitmasks except for
	  'DEFMASK' are allowed)
	  
	  @param id (C++: enum_t)
	  

idc.is_event_handled():
	
	    Is the debug event handled?
	
	    @return: boolean
	    

idc.is_loaded():
	Is the byte initialized?

idc.is_union():
	
	    Is a structure a union?
	
	    @param sid: structure type ID
	
	    @return: 1: yes, this is a union id
	             0: no
	
	    @note: Unions are a special kind of structures
	    

idc.is_valid_trace_file():
	
	  is_valid_trace_file(filename) -> bool
	
	
	  Is the specified file a valid trace file for the current database?
	  
	  
	  @param filename (C++: const char *)
	  

idc.jumpto():
	
	    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
	    jumpto(custom_viewer, place, x, y) -> bool
	
	
	  Jump to the specified address ( 'ui_jumpto' ).
	  
	  @param ea: destination (C++: ea_t)
	  @param opnum: -1: don't change x coord (C++: int)
	  @param uijmp_flags: Jump flags (C++: int)
	  @return: success
	    

idc.load_and_run_plugin():
	
	  load_and_run_plugin(name, arg) -> bool
	
	
	  Load & run a plugin.
	  
	  
	  @param name (C++: const char *)
	  @param arg (C++: size_t)
	  

idc.load_debugger():
	
	  load_debugger(dbgname, use_remote) -> bool
	  

idc.load_trace_file():
	
	  load_trace_file(filename) -> bool
	
	
	  Load a recorded trace file in the trace window. If the call succeeds
	  and 'buf' is not null, the description of the trace stored in the
	  binary trace file will be returned in 'buf'
	  
	  @param filename (C++: const char *)
	  

idc.make_array():
	
	    Create an array.
	
	    @param ea: linear address
	    @param nitems: size of array in items
	
	    @note: This function will create an array of the items with the same type as
	    the type of the item at 'ea'. If the byte at 'ea' is undefined, then
	    this function will create an array of bytes.
	    

idc.move_segm():
	
	    Move a segment to a new address
	    This function moves all information to the new address
	    It fixes up address sensitive information in the kernel
	    The total effect is equal to reloading the segment to the target address
	
	    @param ea: any address within the segment to move
	    @param to: new segment start address
	    @param flags: combination MFS_... constants
	
	    @returns: MOVE_SEGM_... error code
	    

idc.msg():
	
	  msg(o) -> PyObject *
	
	
	  Display an UTF-8 string in the message window
	  
	  The result of the stringification of the arguments
	  will be treated as an UTF-8 string.
	  
	  @param message: message to print (formatting is done in Python)
	  
	  This function can be used to debug IDAPython scripts
	  

idc.next_addr():
	
	  next_addr(ea) -> ea_t
	
	
	  Get next address in the program (i.e. next address which has flags).
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if no such address exist.
	  

idc.next_func_chunk():
	
	    Get the next function chunk of the specified function
	
	    @param funcea: any address in the function
	    @param tailea: any address in the current chunk
	
	    @return: the starting address of the next function chunk or BADADDR
	
	    @note: This function returns the next chunk of the specified function
	    

idc.next_head():
	
	    Get next defined item (instruction or data) in the program
	
	    @param ea: linear address to start search from
	    @param maxea: the search will stop at the address
	        maxea is not included in the search range
	
	    @return: BADADDR - no (more) defined items
	    

idc.next_not_tail():
	
	  next_not_tail(ea) -> ea_t
	
	
	  Get address of next non-tail byte.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if none exists.
	  

idc.op_bin():
	
	  op_bin(ea, n) -> bool
	
	
	  set op type to 'bin_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_chr():
	
	  op_chr(ea, n) -> bool
	
	
	  set op type to 'char_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_dec():
	
	  op_dec(ea, n) -> bool
	
	
	  set op type to 'dec_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_enum():
	
	  op_enum(ea, n, id, serial) -> bool
	
	
	  Set operand representation to be 'enum_t'. If applied to unexplored
	  bytes, converts them to 16/32bit word data
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @param id: id of enum (C++: enum_t)
	  @param serial: the serial number of the constant in the enumeration,
	                 usually 0. the serial numbers are used if the
	                 enumeration contains several constants with the same
	                 value (C++: uchar)
	  @return: success
	  

idc.op_flt():
	
	  op_flt(ea, n) -> bool
	
	
	  set op type to 'flt_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_hex():
	
	  op_hex(ea, n) -> bool
	
	
	  set op type to 'hex_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_man():
	
	  set_forced_operand(ea, n, op) -> bool
	
	
	  Set forced operand.
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, 2) (C++: int)
	  @param op: text of operand   NULL: do nothing (return 0) "" : delete
	             forced operand (C++: const char *)
	  @return: success
	  

idc.op_num():
	
	  op_num(ea, n) -> bool
	
	
	  set op type to 'num_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_oct():
	
	  op_oct(ea, n) -> bool
	
	
	  set op type to 'oct_flag()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.op_offset():
	
	  op_offset(ea, n, type, target=BADADDR, base=0, tdelta=0) -> int
	
	
	  See 'op_offset_ex()'
	  
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  @param type (C++: reftype_t)
	  @param target (C++: ea_t)
	  @param base (C++: ea_t)
	  @param tdelta (C++: adiff_t)
	  

idc.op_offset_high16():
	
	    Convert operand to a high offset
	    High offset is the upper 16bits of an offset.
	    This type is used by TMS320C6 processors (and probably by other
	    RISC processors too)
	
	    @param ea: linear address
	    @param n: number of operand
	        - 0 - the first operand
	        - 1 - the second, third and all other operands
	        - -1 - all operands
	    @param target: the full value (all 32bits) of the offset
	    

idc.op_plain_offset():
	
	    Convert operand to an offset
	    (for the explanations of 'ea' and 'n' please see op_bin())
	
	    Example:
	    ========
	
	        seg000:2000 dw      1234h
	
	        and there is a segment at paragraph 0x1000 and there is a data item
	        within the segment at 0x1234:
	
	        seg000:1234 MyString        db 'Hello, world!',0
	
	        Then you need to specify a linear address of the segment base to
	        create a proper offset:
	
	        op_plain_offset(["seg000",0x2000],0,0x10000);
	
	        and you will have:
	
	        seg000:2000 dw      offset MyString
	
	    Motorola 680x0 processor have a concept of "outer offsets".
	    If you want to create an outer offset, you need to combine number
	    of the operand with the following bit:
	
	    Please note that the outer offsets are meaningful only for
	    Motorola 680x0.
	
	    @param ea: linear address
	    @param n: number of operand
	        - 0 - the first operand
	        - 1 - the second, third and all other operands
	        - -1 - all operands
	    @param base: base of the offset as a linear address
	        If base == BADADDR then the current operand becomes non-offset
	    

idc.op_seg():
	
	  op_seg(ea, n) -> bool
	
	
	  Set operand representation to be 'segment'. If applied to unexplored
	  bytes, converts them to 16/32bit word data
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: success
	  

idc.op_stkvar():
	
	  op_stkvar(ea, n) -> bool
	
	
	  Set operand representation to be 'stack variable'. Should be applied
	  to an instruction within a function. Should be applied after creating
	  a stack var using 'insn_t::create_stkvar()' .
	  
	  @param ea: linear address (C++: ea_t)
	  @param n: number of operand (0, 1, -1) (C++: int)
	  @return: success
	  

idc.op_stroff():
	
	    Convert operand to an offset in a structure
	
	    @param ea: linear address
	    @param n: number of operand
	        - 0 - the first operand
	        - 1 - the second, third and all other operands
	        - -1 - all operands
	    @param strid: id of a structure type
	    @param delta: struct offset delta. usually 0. denotes the difference
	                    between the structure base and the pointer into the structure.
	
	    

idc.parse_decl():
	
	    Parse type declaration
	
	    @param inputtype: file name or C declarations (depending on the flags)
	    @param flags: combination of PT_... constants or 0
	
	    @return: None on failure or (name, type, fields) tuple
	    

idc.parse_decls():
	
	    Parse type declarations
	
	    @param inputtype: file name or C declarations (depending on the flags)
	    @param flags: combination of PT_... constants or 0
	
	    @return: number of parsing errors (0 no errors)
	    

idc.patch_byte():
	
	  patch_byte(ea, x) -> bool
	
	
	  Patch a byte of the program. The original value of the byte is saved
	  and can be obtained by 'get_original_byte()' . This function works for
	  wide byte processors too.
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

idc.patch_dbg_byte():
	
	  put_dbg_byte(ea, x) -> bool
	
	
	  Change one byte of the debugged process memory.
	  
	  @param ea: linear address (C++: ea_t)
	  @param x: byte value (C++: uint32)
	  @return: true if the process memory has been modified
	  

idc.patch_dword():
	
	  patch_dword(ea, x) -> bool
	
	
	  Patch a dword of the program. The original value of the dword is saved
	  and can be obtained by 'get_original_dword()' . This function DOESN'T
	  work for wide byte processors. This function takes into account order
	  of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

idc.patch_qword():
	
	  patch_qword(ea, x) -> bool
	
	
	  Patch a qword of the program. The original value of the qword is saved
	  and can be obtained by 'get_original_qword()' . This function DOESN'T
	  work for wide byte processors. This function takes into account order
	  of bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

idc.patch_word():
	
	  patch_word(ea, x) -> bool
	
	
	  Patch a word of the program. The original value of the word is saved
	  and can be obtained by 'get_original_word()' . This function works for
	  wide byte processors too. This function takes into account order of
	  bytes specified in {is_be()}
	  
	  @param ea (C++: ea_t)
	  @param x (C++: uint64)
	  

idc.plan_and_wait():
	
	    Perform full analysis of the range
	
	    @param sEA: starting linear address
	    @param eEA: ending linear address (excluded)
	    @param final_pass: make the final pass over the specified range
	
	    @return: 1-ok, 0-Ctrl-Break was pressed.
	    

idc.plan_to_apply_idasgn():
	
	  plan_to_apply_idasgn(fname) -> int
	
	
	  Add a signature file to the list of planned signature files.
	  
	  @param fname: file name. should not contain directory part. (C++:
	                const char *)
	  @return: 0 if failed, otherwise number of planned (and applied)
	           signatures
	  

idc.prev_addr():
	
	  prev_addr(ea) -> ea_t
	
	
	  Get previous address in the program.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if no such address exist.
	  

idc.prev_head():
	
	    Get previous defined item (instruction or data) in the program
	
	    @param ea: linear address to start search from
	    @param minea: the search will stop at the address
	            minea is included in the search range
	
	    @return: BADADDR - no (more) defined items
	    

idc.prev_not_tail():
	
	  prev_not_tail(ea) -> ea_t
	
	
	  Get address of previous non-tail byte.
	  
	  @param ea (C++: ea_t)
	  @return: BADADDR  if none exists.
	  

idc.print_decls():
	
	    Print types in a format suitable for use in a header file
	
	    @param ordinals: comma-separated list of type ordinals
	    @param flags: combination of PDF_... constants or 0
	
	    @return: string containing the type definitions
	    

idc.print_insn_mnem():
	
	    Get instruction mnemonics
	
	    @param ea: linear address of instruction
	
	    @return: "" - no instruction at the specified location
	
	    @note: this function may not return exactly the same mnemonics
	    as you see on the screen.
	    

idc.print_operand():
	
	    Get operand of an instruction or data
	
	    @param ea: linear address of the item
	    @param n: number of operand:
	        0 - the first operand
	        1 - the second operand
	
	    @return: the current text representation of operand or ""
	    

idc.process_config_line():
	
	    Parse one or more ida.cfg config directives
	    @param directive: directives to process, for example: PACK_DATABASE=2
	
	    @note: If the directives are erroneous, a fatal error will be generated.
	           The settings are permanent: effective for the current session and the next ones
	    

idc.process_ui_action():
	
	    Invokes an IDA UI action by name
	
	    @param name: Command name
	    @param flags: Reserved. Must be zero
	    @return: Boolean
	    

idc.put_bookmark():
	
	  mark_position(ea, lnnum, x, y, slot, comment)
	  

idc.qexit():
	
	  qexit(code)
	
	
	  Call qatexit functions, shut down UI and kernel, and exit.
	  
	  @param code: exit code (C++: int)
	  

idc.qsleep():
	
	    qsleep the specified number of milliseconds
	    This function suspends IDA for the specified amount of time
	
	    @param milliseconds: time to sleep
	    

idc.read_dbg_byte():
	
	    Get value of program byte using the debugger memory
	
	    @param ea: linear address
	    @return: The value or None on failure.
	    

idc.read_dbg_dword():
	
	    Get value of program double-word using the debugger memory
	
	    @param ea: linear address
	    @return: The value or None on failure.
	    

idc.read_dbg_memory():
	
	  dbg_read_memory(py_ea, py_sz) -> PyObject *
	
	
	  Reads from the debugee's memory at the specified ea
	  @return:
	      - The read buffer (as a string)
	      - Or None on failure
	  

idc.read_dbg_qword():
	
	    Get value of program quadro-word using the debugger memory
	
	    @param ea: linear address
	    @return: The value or None on failure.
	    

idc.read_dbg_word():
	
	    Get value of program word using the debugger memory
	
	    @param ea: linear address
	    @return: The value or None on failure.
	    

idc.read_selection_end():
	
	    Get end address of the selected range
	
	    @return: BADADDR - the user has not selected an range
	    

idc.read_selection_start():
	
	    Get start address of the selected range
	    returns BADADDR - the user has not selected an range
	    

idc.rebase_program():
	
	  rebase_program(delta, flags) -> int
	
	
	  Rebase the whole program by 'delta' bytes.
	  
	  @param delta: number of bytes to move the program (C++: adiff_t)
	  @param flags: Move segment flags  it is recommended to use
	                MSF_FIXONCE  so that the loader takes care of global
	                variables it stored in the database (C++: int)
	  @return: Move segment result codes
	  

idc.recalc_spd():
	
	  recalc_spd(cur_ea) -> bool
	
	
	  Recalculate SP delta for an instruction that stops execution. The next
	  instruction is not reached from the current instruction. We need to
	  recalculate SP for the next instruction.This function will create a
	  new automatic SP register change point if necessary. It should be
	  called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
	  current instruction doesn't pass the execution flow to the next
	  instruction.
	  
	  @param cur_ea: linear address of the current instruction (C++: ea_t)
	  

idc.refresh_debugger_memory():
	
	  refresh_debugger_memory() -> PyObject *
	
	
	  Refreshes the debugger memory
	  @return: Nothing
	  

idc.refresh_idaview_anyway():
	
	  refresh_idaview_anyway()
	
	
	  Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
	  refresh. Please consider 'request_refresh()' instead
	  

idc.refresh_lists():
	
	  refresh_choosers()
	  

idc.remove_fchunk():
	
	    Remove a function chunk from the function
	
	    @param funcea: any address in the function
	    @param tailea: any address in the function chunk to remove
	
	    @return: 0 if failed, 1 if success
	    

idc.rename_array():
	
	    Rename array, by its ID.
	
	    @param id: The ID of the array to rename.
	    @param newname: The new name of the array.
	
	    @return: 1 in case of success, 0 otherwise
	    

idc.rename_entry():
	
	  rename_entry(ord, name, flags=0x0) -> bool
	
	
	  Rename entry point.
	  
	  @param ord: ordinal number of the entry point (C++: uval_t)
	  @param name: name of entry point. If the specified location already
	               has a name, the old name will be appended to a repeatable
	               comment. (C++: const char *)
	  @param flags: See AEF_* (C++: int)
	  @return: success
	  

idc.resume_thread():
	
	  resume_thread(tid) -> int
	
	
	  Resume thread. {Type, Synchronous function - available as request,
	  Notification, none (synchronous function)}
	  
	  @param tid: thread id (C++: thid_t)
	  

idc.retrieve_input_file_md5():
	
	  retrieve_input_file_md5() -> bool
	
	
	  Get input file md5.
	  

idc.rotate_left():
	
	    Rotate a value to the left (or right)
	
	    @param value: value to rotate
	    @param count: number of times to rotate. negative counter means
	                  rotate to the right
	    @param nbits: number of bits to rotate
	    @param offset: offset of the first bit to rotate
	
	    @return: the value with the specified field rotated
	             all other bits are not modified
	    

idc.run_to():
	
	  run_to(ea, pid=pid_t(-1), tid=0) -> bool
	
	
	  Execute the process until the given address is reached. If no process
	  is active, a new process is started. Technically, the debugger sets up
	  a temporary breakpoint at the given address, and continues (or starts)
	  the execution of the whole process. So, all threads continue their
	  execution! {Type, Asynchronous function - available as Request,
	  Notification, 'dbg_run_to' }
	  
	  @param ea: target address (C++: ea_t)
	  @param pid: not used yet. please do not specify this parameter. (C++:
	              pid_t)
	  @param tid: not used yet. please do not specify this parameter. (C++:
	              thid_t)
	  

idc.save_database():
	
	    Save current database to the specified idb file
	
	    @param idbname: name of the idb file. if empty, the current idb
	                    file will be used.
	    @param flags: combination of ida_loader.DBFL_... bits or 0
	    

idc.save_trace_file():
	
	  save_trace_file(filename, description) -> bool
	
	
	  Save the current trace in the specified file.
	  
	  
	  @param filename (C++: const char *)
	  @param description (C++: const char *)
	  

idc.sel2para():
	
	    Get a selector value
	
	    @param sel: the selector number
	
	    @return: selector value if found
	             otherwise the input value (sel)
	
	    @note: selector values are always in paragraphs
	    

idc.select_thread():
	
	  select_thread(tid) -> bool
	
	
	  Select the given thread as the current debugged thread. All thread
	  related execution functions will work on this thread. The process must
	  be suspended to select a new thread. {Type, Synchronous function -
	  available as request, Notification, none (synchronous function)}
	  
	  @param tid: ID of the thread to select (C++: thid_t)
	  @return: false if the thread doesn't exist.
	  

idc.selector_by_name():
	
	    Get segment selector by name
	
	    @param segname: name of segment
	
	    @return: segment selector or BADADDR
	    

idc.send_dbg_command():
	Sends a command to the debugger module and returns the output string.
	    An exception will be raised if the debugger is not running or the current debugger does not export
	    the 'send_dbg_command' IDC command.
	    

idc.set_array_long():
	
	    Sets the long value of an array element.
	
	    @param array_id: The array ID.
	    @param idx: Index of an element.
	    @param value: 32bit or 64bit value to store in the array
	
	    @return: 1 in case of success, 0 otherwise
	    

idc.set_array_params():
	
	    Set array representation format
	
	    @param ea: linear address
	    @param flags: combination of AP_... constants or 0
	    @param litems: number of items per line. 0 means auto
	    @param align: element alignment
	                  - -1: do not align
	                  - 0:  automatic alignment
	                  - other values: element width
	
	    @return: 1-ok, 0-failure
	    

idc.set_array_string():
	
	    Sets the string value of an array element.
	
	    @param array_id: The array ID.
	    @param idx: Index of an element.
	    @param value: String value to store in the array
	
	    @return: 1 in case of success, 0 otherwise
	    

idc.set_bmask_cmt():
	
	    Set bitmask comment (only for bitfields)
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant
	    @param cmt: comment
	    repeatable - type of comment, 0-regular, 1-repeatable
	
	    @return: 1-ok, 0-failed
	    

idc.set_bmask_name():
	
	    Set bitmask name (only for bitfields)
	
	    @param enum_id: id of enum
	    @param bmask: bitmask of the constant
	    @param name: name of bitmask
	
	    @return: 1-ok, 0-failed
	    

idc.set_bpt_attr():
	
	        modifiable characteristics of a breakpoint
	
	    @param address: any address in the breakpoint range
	    @param bptattr: the attribute code, one of BPTATTR_* constants
	                    BPTATTR_CND is not allowed, see set_bpt_cond()
	    @param value: the attibute value
	
	    @return: success
	    

idc.set_bpt_cond():
	
	    Set breakpoint condition
	
	    @param ea: any address in the breakpoint range
	    @param cnd: breakpoint condition
	    @param is_lowcnd: 0 - regular condition, 1 - low level condition
	
	    @return: success
	    

idc.set_cmt():
	
	  set_cmt(ea, comm, rptble) -> bool
	
	
	  Set an indented comment.
	  
	  @param ea: linear address (C++: ea_t)
	  @param comm: comment string   NULL: do nothing (return 0) "" : delete
	               comment (C++: const char *)
	  @param rptble: is repeatable? (C++: bool)
	  @return: success
	  

idc.set_color():
	
	    Set item color
	
	    @param ea: address of the item
	    @param what: type of the item (one of CIC_* constants)
	    @param color: new color code in RGB (hex 0xBBGGRR)
	
	    @return: success (True or False)
	    

idc.set_debugger_event_cond():
	
	  set_debugger_event_cond(nonnul_cond)
	  

idc.set_debugger_options():
	
	  set_debugger_options(options) -> uint
	
	
	  Set debugger options. Replaces debugger options with the specification
	  combination 'Debugger options'
	  
	  @param options (C++: uint)
	  @return: the old debugger options
	  

idc.set_default_sreg_value():
	
	    Set default segment register value for a segment
	
	    @param ea: any address in the segment
	               if no segment is present at the specified address
	               then all segments will be affected
	    @param reg: name of segment register
	    @param value: default value of the segment register. -1-undefined.
	    

idc.set_enum_bf():
	
	  set_enum_bf(id, bf) -> bool
	
	
	  Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
	  
	  
	  @param id (C++: enum_t)
	  @param bf (C++: bool)
	  

idc.set_enum_cmt():
	
	  set_enum_cmt(id, cmt, repeatable) -> bool
	
	
	  Set comment for enum type.
	  
	  
	  @param id (C++: enum_t)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

idc.set_enum_flag():
	
	  set_enum_flag(id, flag) -> bool
	
	
	  Set data representation flags.
	  
	  
	  @param id (C++: enum_t)
	  @param flag (C++: flags_t)
	  

idc.set_enum_idx():
	
	  set_enum_idx(id, idx) -> bool
	
	
	  Set serial number of enum. Also see 'get_enum_idx()' .
	  
	  @param id (C++: enum_t)
	  @param idx (C++: size_t)
	  

idc.set_enum_member_cmt():
	
	  set_enum_member_cmt(id, cmt, repeatable) -> bool
	
	
	  Set comment for enum member.
	  
	  
	  @param id (C++: const_t)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

idc.set_enum_member_name():
	
	  set_enum_member_name(id, name) -> bool
	
	
	  Set name of enum member.
	  
	  
	  @param id (C++: const_t)
	  @param name (C++: const char *)
	  

idc.set_enum_name():
	
	  set_enum_name(id, name) -> bool
	
	
	  Set name of enum type.
	  
	  
	  @param id (C++: enum_t)
	  @param name (C++: const char *)
	  

idc.set_enum_width():
	
	  set_enum_width(id, width) -> bool
	
	
	  See comment for 'get_enum_width()'
	  
	  
	  @param id (C++: enum_t)
	  @param width (C++: int)
	  

idc.set_fchunk_attr():
	
	    Set a function chunk attribute
	
	    @param ea: any address in the chunk
	    @param attr: only FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER
	    @param value: desired value
	
	    @return: 0 if failed, 1 if success
	    

idc.set_fixup():
	
	    Set fixup information
	
	    @param ea: address to set fixup information about
	    @param fixuptype:  fixup type. see get_fixup_target_type()
	                       for possible fixup types.
	    @param fixupflags: fixup flags. see get_fixup_target_flags()
	                       for possible fixup types.
	    @param targetsel:  target selector
	    @param targetoff:  target offset
	    @param displ:      displacement
	
	    @return:        none
	    

idc.set_frame_size():
	
	    Make function frame
	
	    @param ea: any address belonging to the function
	    @param lvsize: size of function local variables
	    @param frregs: size of saved registers
	    @param argsize: size of function arguments
	
	    @return: ID of function frame or -1
	             If the function did not have a frame, the frame
	             will be created. Otherwise the frame will be modified
	    

idc.set_func_attr():
	
	    Set a function attribute
	
	    @param ea: any address belonging to the function
	    @param attr: one of FUNCATTR_... constants
	    @param value: new value of the attribute
	
	    @return: 1-ok, 0-failed
	    

idc.set_func_cmt():
	
	    Set function comment
	
	    @param ea: any address belonging to the function
	    @param cmt: a function comment line
	    @param repeatable: 1: get repeatable comment
	            0: get regular comment
	    

idc.set_func_end():
	
	  set_func_end(ea, newend) -> bool
	
	
	  Move function chunk end address.
	  
	  @param ea: any address in the function (C++: ea_t)
	  @param newend: new end address of the function (C++: ea_t)
	  @return: success
	  

idc.set_func_flags():
	
	    Change function flags
	
	    @param ea: any address belonging to the function
	    @param flags: see get_func_flags() for explanations
	
	    @return: !=0 - ok
	    

idc.set_hash_long():
	
	    Sets the long value of a hash element.
	
	    @param hash_id: The hash ID.
	    @param key: Key of an element.
	    @param value: 32bit or 64bit value to store in the hash
	
	    @return: 1 in case of success, 0 otherwise
	    

idc.set_hash_string():
	
	    Sets the string value of a hash element.
	
	    @param hash_id: The hash ID.
	    @param key: Key of an element.
	    @param value: string value to store in the hash
	
	    @return: 1 in case of success, 0 otherwise
	    

idc.set_ida_state():
	
	  set_ida_state(st) -> idastate_t
	
	
	  Change IDA status indicator value
	  
	  @param st: - new indicator status (C++: idastate_t)
	  @return: old indicator status
	  

idc.set_local_type():
	
	    Parse one type declaration and store it in the specified slot
	
	    @param ordinal:  slot number (1...NumberOfLocalTypes)
	                     -1 means allocate new slot or reuse the slot
	                     of the existing named type
	    @param input:  C declaration. Empty input empties the slot
	    @param flags:  combination of PT_... constants or 0
	
	    @return: slot number or 0 if error
	    

idc.set_manual_insn():
	
	  set_manual_insn(ea, manual_insn)
	
	
	  Set manual instruction string.
	  
	  @param ea: linear address of the instruction or data item (C++: ea_t)
	  @param manual_insn: "" - delete manual string. NULL - do nothing (C++:
	                      const char *)
	  

idc.set_member_cmt():
	
	    Change structure member comment
	
	    @param sid: structure type ID
	    @param member_offset: offset of the member
	    @param comment: new comment of the structure member
	    @param repeatable: 1: change repeatable comment
	                       0: change regular comment
	
	    @return: != 0 - ok
	    

idc.set_member_name():
	
	    Change structure member name
	
	    @param sid: structure type ID
	    @param member_offset: offset of the member
	    @param name: new name of the member
	
	    @return: != 0 - ok.
	    

idc.set_member_type():
	
	    Change structure member type
	
	    @param sid: structure type ID
	    @param member_offset: offset of the member
	    @param flag: new type of the member. Should be one of
	                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
	    @param typeid: if isStruc(flag) then typeid specifies the structure id for the member
	                   if is_off0(flag) then typeid specifies the offset base.
	                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
	                   if is_stroff(flag) then typeid specifies the structure id
	                   if is_enum(flag) then typeid specifies the enum id
	                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
	                   Otherwise typeid should be -1.
	    @param nitems: number of items in the member
	
	    @param target: target address of the offset expr. You may specify it as
	                   -1, ida will calculate it itself
	    @param tdelta: offset target delta. usually 0
	    @param reftype: see REF_... definitions
	
	    @note: The remaining arguments are allowed only if is_off0(flag) and you want
	           to specify a complex offset expression
	
	    @return: !=0 - ok.
	    

idc.set_name():
	
	    Rename an address
	
	    @param ea: linear address
	    @param name: new name of address. If name == "", then delete old name
	    @param flags: combination of SN_... constants
	
	    @return: 1-ok, 0-failure
	    

idc.set_processor_type():
	
	  set_processor_type(procname, level) -> bool
	
	
	  Set target processor type. Once a processor module is loaded, it can
	  not be replaced until we close the idb.
	  
	  @param procname: name of processor type (one of names present in
	                   {psnames}) (C++: const char *)
	  @param level: SETPROC_ (C++: setproc_level_t)
	  @return: success
	  

idc.set_reg_value():
	
	    Set register value
	
	    @param name: the register name
	    @param value: new register value
	
	    @note: The debugger should be running
	           It is not necessary to use this function to set register values.
	           A register name in the left side of an assignment will do too.
	    

idc.set_remote_debugger():
	
	  set_remote_debugger(host, _pass, port=-1)
	
	
	  Set remote debugging options. Should be used before starting the
	  debugger.
	  
	  @param host: If empty, IDA will use local debugger. If NULL, the host
	               will not be set. (C++: const char *)
	  @param port: If -1, the default port number will be used (C++: int)
	  

idc.set_root_filename():
	
	  set_root_filename(file)
	
	
	  Set full path of the input file.
	  
	  
	  @param file (C++: const char *)
	  

idc.set_segm_addressing():
	
	    Change segment addressing
	
	    @param ea: any address in the segment
	    @param bitness: 0: 16bit, 1: 32bit, 2: 64bit
	
	    @return: success (boolean)
	    

idc.set_segm_alignment():
	
	    Change alignment of the segment
	
	    @param ea: any address in the segment
	    @param alignment: new alignment of the segment (one of the sa... constants)
	
	    @return: success (boolean)
	    

idc.set_segm_attr():
	
	    Set segment attribute
	
	    @param segea: any address within segment
	    @param attr: one of SEGATTR_... constants
	
	    @note: Please note that not all segment attributes are modifiable.
	           Also some of them should be modified using special functions
	           like set_segm_addressing, etc.
	    

idc.set_segm_class():
	
	    Change class of the segment
	
	    @param ea: any address in the segment
	    @param segclass: new class of the segment
	
	    @return: success (boolean)
	    

idc.set_segm_combination():
	
	    Change combination of the segment
	
	    @param segea: any address in the segment
	    @param comb: new combination of the segment (one of the sc... constants)
	
	    @return: success (boolean)
	    

idc.set_segm_name():
	
	    Change name of the segment
	
	    @param ea: any address in the segment
	    @param name: new name of the segment
	
	    @return: success (boolean)
	    

idc.set_segm_type():
	
	    Set segment type
	
	    @param segea: any address within segment
	    @param segtype: new segment type:
	
	    @return: !=0 - ok
	    

idc.set_segment_bounds():
	
	    Change segment boundaries
	
	    @param ea: any address in the segment
	    @param startea: new start address of the segment
	    @param endea: new end address of the segment
	    @param flags: combination of SEGMOD_... flags
	
	    @return: boolean success
	    

idc.set_selector():
	
	  set_selector(selector, paragraph) -> int
	
	
	  Set mapping of selector to a paragraph. You should call this
	  functionbeforecreating a segment which uses the selector, otherwise
	  the creation of the segment will fail.
	  
	  @param selector: number of selector to map   if selector ==  BADSEL ,
	                   then return 0 (fail) if the selector has had a
	                   mapping, old mapping is destroyed if the selector
	                   number is equal to paragraph value, then the mapping
	                   is destroyed because we don't need to keep trivial
	                   mappings. (C++: sel_t)
	  @param paragraph: paragraph to map selector (C++: ea_t)
	  

idc.set_source_linnum():
	
	  set_source_linnum(ea, lnnum)
	  

idc.set_step_trace_options():
	
	  set_step_trace_options(options)
	
	
	  Modify step tracing options. {Type, Synchronous function - available
	  as request, Notification, none (synchronous function)}
	  
	  @param options (C++: int)
	  

idc.set_storage_type():
	
	  change_storage_type(start_ea, end_ea, stt) -> error_t
	
	
	  Change flag storage type for address range.
	  
	  @param start_ea: should be lower than end_ea. (C++: ea_t)
	  @param end_ea: does not belong to the range. (C++: ea_t)
	  @param stt: storage_type_t (C++: storage_type_t)
	  @return: error code
	  

idc.set_struc_cmt():
	
	  set_struc_cmt(id, cmt, repeatable) -> bool
	
	
	  Set structure comment.
	  
	  
	  @param id (C++: tid_t)
	  @param cmt (C++: const char *)
	  @param repeatable (C++: bool)
	  

idc.set_struc_idx():
	
	    Change structure index
	
	    @param sid: structure type ID
	    @param index: new index of the structure
	
	    @return: != 0 - ok
	
	    @note: See get_first_struc_idx() for the explanation of
	           structure indices and IDs.
	    

idc.set_struc_name():
	
	  set_struc_name(id, name) -> bool
	
	
	  Set structure name.
	  
	  
	  @param id (C++: tid_t)
	  @param name (C++: const char *)
	  

idc.set_tail_owner():
	
	    Change the function chunk owner
	
	    @param tailea: any address in the function chunk
	    @param funcea: the starting address of the new owner
	
	    @return: False if failed, True if success
	
	    @note: The new owner must already have the chunk appended before the call
	    

idc.set_target_assembler():
	
	  set_target_assembler(asmnum) -> bool
	
	
	  Set target assembler.
	  
	  @param asmnum: number of assembler in the current processor module
	                 (C++: int)
	  @return: success
	  

idc.set_trace_file_desc():
	
	  set_trace_file_desc(filename, description) -> bool
	
	
	  Change the description of the specified trace file.
	  
	  
	  @param filename (C++: const char *)
	  @param description (C++: const char *)
	  

idc.split_sreg_range():
	
	    Set value of a segment register.
	
	    @param ea: linear address
	    @param reg: name of a register, like "cs", "ds", "es", etc.
	    @param value: new value of the segment register.
	    @param tag: of SR_... constants
	
	    @note: IDA keeps tracks of all the points where segment register change their
	           values. This function allows you to specify the correct value of a segment
	           register if IDA is not able to find the corrent value.
	    

idc.start_process():
	
	  start_process(path=None, args=None, sdir=None) -> int
	
	
	  Start a process in the debugger. {Type, Asynchronous function -
	  available as Request, Notification, 'dbg_process_start' }You can also
	  use the 'run_to()' function to easily start the execution of a process
	  until a given address is reached.For all parameters, a NULL value
	  indicates the debugger will take the value from the defined Process
	  Options.
	  
	  @param path: path to the executable to start (C++: const char *)
	  @param args: arguments to pass to process (C++: const char *)
	  @param sdir: starting directory for the process (C++: const char *)
	  

idc.step_into():
	
	  step_into() -> bool
	
	
	  Execute one instruction in the current thread. Other threads are kept
	  suspended. {Type, Asynchronous function - available as Request,
	  Notification, 'dbg_step_into' }
	  

idc.step_over():
	
	  step_over() -> bool
	
	
	  Execute one instruction in the current thread, but without entering
	  into functions. Others threads keep suspended. {Type, Asynchronous
	  function - available as Request, Notification, 'dbg_step_over' }
	  

idc.step_until_ret():
	
	  step_until_ret() -> bool
	
	
	  Execute instructions in the current thread until a function return
	  instruction is executed (aka "step out"). Other threads are kept
	  suspended. {Type, Asynchronous function - available as Request,
	  Notification, 'dbg_step_until_ret' }
	  

idc.suspend_process():
	
	  suspend_process() -> bool
	
	
	  Suspend the process in the debugger. { Type,Synchronous function (if
	  in a notification handler)Asynchronous function (everywhere
	  else)available as Request, Notification,none (if in a notification
	  handler) 'dbg_suspend_process' (everywhere else) }The
	  'suspend_process()' function can be called from a notification handler
	  to force the stopping of the process. In this case, no notification
	  will be generated. When you suspend a process, the running command is
	  always aborted.
	  

idc.suspend_thread():
	
	  suspend_thread(tid) -> int
	
	
	  Suspend thread. Suspending a thread may deadlock the whole application
	  if the suspended was owning some synchronization objects. {Type,
	  Synchronous function - available as request, Notification, none
	  (synchronous function)}
	  
	  @param tid: thread id (C++: thid_t)
	  

idc.take_memory_snapshot():
	
	  take_memory_snapshot(only_loader_segs) -> bool
	
	
	  Take a memory snapshot of the running process.
	  
	  @param only_loader_segs: only is_loader_segm() segments will be
	                           affected (C++: bool)
	  @return: success
	  

idc.to_ea():
	
	    Return value of expression: ((seg<<4) + off)
	    

idc.toggle_bnot():
	
	    Toggle the bitwise not operator for the operand
	
	    @param ea: linear address
	    @param n: number of operand
	        - 0 - the first operand
	        - 1 - the second, third and all other operands
	        - -1 - all operands
	    

idc.toggle_sign():
	
	  toggle_sign(ea, n) -> bool
	
	
	  Toggle sign of n-th operand. allowed values of n: 0-first operand,
	  1-other operands
	  
	  @param ea (C++: ea_t)
	  @param n (C++: int)
	  

idc.update_extra_cmt():
	
	  update_extra_cmt(ea, what, str)
	  

idc.update_hidden_range():
	
	    Set hidden range state
	
	    @param ea:      any address belonging to the hidden range
	    @param visible: new state of the range
	
	    @return: != 0 - ok
	    

idc.validate_idb_names():
	
	    check consistency of IDB name records
	    @param do_repair: try to repair netnode header it TRUE
	    @return: number of inconsistent name records
	    

idc.wait_for_next_event():
	
	  wait_for_next_event(wfne, timeout) -> dbg_event_code_t
	
	
	  Wait for the next event.This function (optionally) resumes the process
	  execution, and waits for a debugger event until a possible timeout
	  occurs.
	  
	  @param wfne: combination of  Wait for debugger event flags  constants
	               (C++: int)
	  @param timeout: number of seconds to wait, -1-infinity (C++: int)
	  @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
	           0)
	  

idc.warning():
	
	  warning(format)
	
	
	  Display a message in a message box
	  
	  @param message: message to print (formatting is done in Python)
	  
	  This function can be used to debug IDAPython scripts
	  The user will be able to hide messages if they appear twice in a row on
	  the screen
	  

idc.write_dbg_memory():
	
	    Write to debugger memory.
	
	    @param ea: linear address
	    @param data: string to write
	    @return: number of written bytes (-1 - network/debugger error)
	
	    Thread-safe function (may be called only from the main thread and debthread)
	    


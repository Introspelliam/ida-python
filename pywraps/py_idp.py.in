#<pycode(py_idp)>

#----------------------------------------------------------------------------
#               P R O C E S S O R  M O D U L E S  C O N S T A N T S
#----------------------------------------------------------------------------

# ----------------------------------------------------------------------
# processor_t related constants

CUSTOM_INSN_ITYPE   = 0x8000
REG_SPOIL           = 0x80000000

REAL_ERROR_FORMAT   = -1   #  not supported format for current .idp
REAL_ERROR_RANGE    = -2   #  number too big (small) for store (mem NOT modifyed)
REAL_ERROR_BADDATA  = -3   #  illegal real data for load (IEEE data not filled)

#
#  Check whether the operand is relative to stack pointer or frame pointer.
#  This function is used to determine how to output a stack variable
#  This function may be absent. If it is absent, then all operands
#  are sp based by default.
#  Define this function only if some stack references use frame pointer
#  instead of stack pointer.
#  returns flags:
OP_FP_BASED   = 0x00000000   #  operand is FP based
OP_SP_BASED   = 0x00000001   #  operand is SP based
OP_SP_ADD     = 0x00000000   #  operand value is added to the pointer
OP_SP_SUB     = 0x00000002   #  operand value is substracted from the pointer

# processor_t.id
${PLFM_DECLS}

#
# processor_t.flag
#
PR_SEGS        = 0x000001    #  has segment registers?
PR_USE32       = 0x000002    #  supports 32-bit addressing?
PR_DEFSEG32    = 0x000004    #  segments are 32-bit by default
PR_RNAMESOK    = 0x000008    #  allow to user register names for location names
PR_ADJSEGS     = 0x000020    #  IDA may adjust segments moving their starting/ending addresses.
PR_DEFNUM      = 0x0000C0    #  default number representation:
PRN_HEX        = 0x000000    #       hex
PRN_OCT        = 0x000040    #       octal
PRN_DEC        = 0x000080    #       decimal
PRN_BIN        = 0x0000C0    #       binary
PR_WORD_INS    = 0x000100    #  instruction codes are grouped 2bytes in binrary line prefix
PR_NOCHANGE    = 0x000200    #  The user can't change segments and code/data attributes (display only)
PR_ASSEMBLE    = 0x000400    #  Module has a built-in assembler and understands IDP_ASSEMBLE
PR_ALIGN       = 0x000800    #  All data items should be aligned properly
PR_TYPEINFO    = 0x001000    #  the processor module supports
                             #     type information callbacks
                             #     ALL OF THEM SHOULD BE IMPLEMENTED!
PR_USE64       = 0x002000    #  supports 64-bit addressing?
PR_SGROTHER    = 0x004000    #  the segment registers don't contain
                             #     the segment selectors, something else
PR_STACK_UP    = 0x008000    #  the stack grows up
PR_BINMEM      = 0x010000    #  the processor module provides correct
                             #     segmentation for binary files
                             #     (i.e. it creates additional segments)
                             #     The kernel will not ask the user
                             #     to specify the RAM/ROM sizes
PR_SEGTRANS    = 0x020000    #  the processor module supports
                             #     the segment translation feature
                             #     (it means it calculates the code
                             #     addresses using the map_code_ea() function)
PR_CHK_XREF    = 0x040000    #  don't allow near xrefs between segments
                             #     with different bases
PR_NO_SEGMOVE  = 0x080000    #  the processor module doesn't support move_segm()
                             #     (i.e. the user can't move segments)
PR_USE_ARG_TYPES = 0x200000  #  use ph.use_arg_types callback
PR_SCALE_STKVARS = 0x400000  #  use ph.get_stkvar_scale callback
PR_DELAYED     = 0x800000    #  has delayed jumps and calls
PR_ALIGN_INSN  = 0x1000000   #  allow ida to create alignment instructions
                             #     arbirtrarily. Since these instructions
                             #     might lead to other wrong instructions
                             #     and spoil the listing, IDA does not create
                             #     them by default anymore
PR_PURGING     = 0x2000000   #  there are calling conventions which may
                             #     purge bytes from the stack
PR_CNDINSNS    = 0x4000000   #  has conditional instructions
PR_USE_TBYTE   = 0x8000000   #  BTMT_SPECFLT means _TBYTE type
PR_DEFSEG64    = 0x10000000  #  segments are 64-bit by default


# ----------------------------------------------------------------------
# instruc_t related constants

#
# instruc_t.feature
#
CF_STOP = 0x00001 #  Instruction doesn't pass execution to the next instruction
CF_CALL = 0x00002 #  CALL instruction (should make a procedure here)
CF_CHG1 = 0x00004 #  The instruction modifies the first operand
CF_CHG2 = 0x00008 #  The instruction modifies the second operand
CF_CHG3 = 0x00010 #  The instruction modifies the third operand
CF_CHG4 = 0x00020 #  The instruction modifies 4 operand
CF_CHG5 = 0x00040 #  The instruction modifies 5 operand
CF_CHG6 = 0x00080 #  The instruction modifies 6 operand
CF_USE1 = 0x00100 #  The instruction uses value of the first operand
CF_USE2 = 0x00200 #  The instruction uses value of the second operand
CF_USE3 = 0x00400 #  The instruction uses value of the third operand
CF_USE4 = 0x00800 #  The instruction uses value of the 4 operand
CF_USE5 = 0x01000 #  The instruction uses value of the 5 operand
CF_USE6 = 0x02000 #  The instruction uses value of the 6 operand
CF_JUMP = 0x04000 #  The instruction passes execution using indirect jump or call (thus needs additional analysis)
CF_SHFT = 0x08000 #  Bit-shift instruction (shl,shr...)
CF_HLL  = 0x10000 #  Instruction may be present in a high level language function.

#
# Set IDP options constants
#
IDPOPT_STR        =  1    # string constant
IDPOPT_NUM        =  2    # number
IDPOPT_BIT        =  3    # bit, yes/no
IDPOPT_FLT        =  4    # float
IDPOPT_I64        =  5    # 64bit number

IDPOPT_OK         =  0    # ok
IDPOPT_BADKEY     =  1    # illegal keyword
IDPOPT_BADTYPE    =  2    # illegal type of value
IDPOPT_BADVALUE   =  3    # illegal value (bad range, for example)

# ----------------------------------------------------------------------
import ida_ua
class processor_t(ida_idaapi.pyidc_opaque_object_t):
    """Base class for all processor module scripts"""
    def __init__(self):
        pass

    def get_idpdesc(self):
        """
        This function must be present and should return the list of
        short processor names similar to the one in ph.psnames.
        This method can be overridden to return to the kernel a different IDP description.
        """
        return '\x01'.join(map(lambda t: '\x01'.join(t), zip(self.plnames, self.psnames)))

    def get_uFlag(self):
        """Use this utility function to retrieve the 'uFlag' global variable"""
        return ida_ua.cvar.uFlag

    def get_auxpref(self, insn):
        """This function returns insn.auxpref value"""
        return insn.auxpref


# ----------------------------------------------------------------------
class __ph(object):
    id = property(lambda self: ph_get_id())
    cnbits = property(lambda self: ph_get_cnbits())
    dnbits = property(lambda self: ph_get_dnbits())
    flag = property(lambda self: ph_get_flag())
    icode_return = property(lambda self: ph_get_icode_return())
    instruc = property(lambda self: ph_get_instruc())
    instruc_end = property(lambda self: ph_get_instruc_end())
    instruc_start = property(lambda self: ph_get_instruc_start())
    reg_code_sreg = property(lambda self: ph_get_reg_code_sreg())
    reg_data_sreg = property(lambda self: ph_get_reg_data_sreg())
    reg_first_sreg = property(lambda self: ph_get_reg_first_sreg())
    reg_last_sreg = property(lambda self: ph_get_reg_last_sreg())
    regnames = property(lambda self: ph_get_regnames())
    segreg_size = property(lambda self: ph_get_segreg_size())
    tbyte_size = property(lambda self: ph_get_tbyte_size())
    version = property(lambda self: ph_get_version())

ph = __ph()

#</pycode(py_idp)>

#<pycode_BC695(py_idp)>
AS_NOTAB=0
CUSTOM_CMD_ITYPE=CUSTOM_INSN_ITYPE
InstrIsSet=has_insn_feature
NEXTEAS_ANSWER_SIZE=0
PR_FULL_HIFXP=0
SETPROC_ALL=SETPROC_LOADER_NON_FATAL
SETPROC_COMPAT=SETPROC_IDB
SETPROC_FATAL=SETPROC_LOADER
area_cmt_changed=range_cmt_changed
changed_stkpnts=stkpnts_changed
changed_struc=struc_align_changed
changing_area_cmt=changing_range_cmt
changing_struc=changing_struc_align
func_tail_removed=func_tail_deleted
get_reg_info2=get_reg_info
ph_get_regCodeSreg=ph_get_reg_code_sreg
ph_get_regDataSreg=ph_get_reg_data_sreg
ph_get_regFirstSreg=ph_get_reg_first_sreg
ph_get_regLastSreg=ph_get_reg_last_sreg
removing_func_tail=deleting_func_tail
segm_attrs_changed=segm_attrs_updated
str2regf=str2reg
def __wrap_insn_func(name):
    def __wrapper(*args):
        arg0 = args[0]
        import ida_ua
        if not isinstance(arg0, ida_ua.insn_t):
            tmp = ida_ua.insn_t()
            if not ida_ua.decode_insn(tmp, arg0):
                return False
            arg0 = tmp
        return getattr(_ida_idp, name)(arg0, *args[1:])
    globals()[name] = __wrapper
__wrap_insn_func("is_call_insn")
__wrap_insn_func("is_ret_insn")
__wrap_insn_func("is_indirect_jump_insn")
__wrap_insn_func("is_basic_block_end")
def parse_reg_name(*args):
    if isinstance(args[1], reg_info_t): # 6.95: regname, reg_info_t
          regname, ri = args
    else:                               # 7.00: reg_info_t, regname
          ri, regname = args
    return _ida_idp.parse_reg_name(ri, regname)

def __call_IDP_Hooks_auto_queue_empty(cb, qtype):
    old_rc = cb(qtype)
    if old_rc == 0: # 6.95's queue not empty anymore
        rc = -1 # 7.0's queue not empty anymore
    else:
        rc = old_rc
    return rc

import ida_ida
ida_ida.__wrap_hooks_callback(
    IDP_Hooks,
    "ev_auto_queue_empty",
    "auto_queue_empty",
    __call_IDP_Hooks_auto_queue_empty)

#</pycode_BC695(py_idp)>
